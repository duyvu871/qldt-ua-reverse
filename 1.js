(function($, K) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = $.document ? K($, !0) : function(Ke) {
        if (!Ke.document)
            throw new Error("jQuery requires a window with a document");
        return K(Ke)
    }
    : K($)
}
)(typeof window < "u" ? window : this, function($, K) {
    "use strict";
    var Ke = []
      , Q = Object.getPrototypeOf
      , we = Ke.slice
      , Te = Ke.flat ? function(c) {
        return Ke.flat.call(c)
    }
    : function(c) {
        return Ke.concat.apply([], c)
    }
      , Re = Ke.push
      , pe = Ke.indexOf
      , ie = {}
      , re = ie.toString
      , De = ie.hasOwnProperty
      , He = De.toString
      , F = He.call(Object)
      , J = {}
      , Y = function(c) {
        return "function" == typeof c && "number" != typeof c.nodeType && "function" != typeof c.item
    }
      , ne = function(c) {
        return null != c && c === c.window
    }
      , D = $.document
      , Se = {
        type: !0,
        src: !0,
        nonce: !0,
        noModule: !0
    };
    function _e(c, g, y) {
        var A, T, L = (y = y || D).createElement("script");
        if (L.text = c,
        g)
            for (A in Se)
                (T = g[A] || g.getAttribute && g.getAttribute(A)) && L.setAttribute(A, T);
        y.head.appendChild(L).parentNode.removeChild(L)
    }
    function U(c) {
        return null == c ? c + "" : "object" == typeof c || "function" == typeof c ? ie[re.call(c)] || "object" : typeof c
    }
    var he = /HTML$/i
      , m = function(c, g) {
        return new m.fn.init(c,g)
    };
    function Ce(c) {
        var g = !!c && "length"in c && c.length
          , y = U(c);
        return !Y(c) && !ne(c) && ("array" === y || 0 === g || "number" == typeof g && 0 < g && g - 1 in c)
    }
    function qe(c, g) {
        return c.nodeName && c.nodeName.toLowerCase() === g.toLowerCase()
    }
    m.fn = m.prototype = {
        jquery: "3.7.1",
        constructor: m,
        length: 0,
        toArray: function() {
            return we.call(this)
        },
        get: function(c) {
            return null == c ? we.call(this) : c < 0 ? this[c + this.length] : this[c]
        },
        pushStack: function(c) {
            var g = m.merge(this.constructor(), c);
            return g.prevObject = this,
            g
        },
        each: function(c) {
            return m.each(this, c)
        },
        map: function(c) {
            return this.pushStack(m.map(this, function(g, y) {
                return c.call(g, y, g)
            }))
        },
        slice: function() {
            return this.pushStack(we.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        even: function() {
            return this.pushStack(m.grep(this, function(c, g) {
                return (g + 1) % 2
            }))
        },
        odd: function() {
            return this.pushStack(m.grep(this, function(c, g) {
                return g % 2
            }))
        },
        eq: function(c) {
            var g = this.length
              , y = +c + (c < 0 ? g : 0);
            return this.pushStack(0 <= y && y < g ? [this[y]] : [])
        },
        end: function() {
            return this.prevObject || this.constructor()
        },
        push: Re,
        sort: Ke.sort,
        splice: Ke.splice
    },
    m.extend = m.fn.extend = function() {
        var c, g, y, A, T, L, O = arguments[0] || {}, W = 1, N = arguments.length, ee = !1;
        for ("boolean" == typeof O && (ee = O,
        O = arguments[W] || {},
        W++),
        "object" == typeof O || Y(O) || (O = {}),
        W === N && (O = this,
        W--); W < N; W++)
            if (null != (c = arguments[W]))
                for (g in c)
                    A = c[g],
                    "__proto__" !== g && O !== A && (ee && A && (m.isPlainObject(A) || (T = Array.isArray(A))) ? (y = O[g],
                    L = T && !Array.isArray(y) ? [] : T || m.isPlainObject(y) ? y : {},
                    T = !1,
                    O[g] = m.extend(ee, L, A)) : void 0 !== A && (O[g] = A));
        return O
    }
    ,
    m.extend({
        expando: "jQuery" + ("3.7.1" + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(c) {
            throw new Error(c)
        },
        noop: function() {},
        isPlainObject: function(c) {
            var g, y;
            return !(!c || "[object Object]" !== re.call(c) || (g = Q(c)) && ("function" != typeof (y = De.call(g, "constructor") && g.constructor) || He.call(y) !== F))
        },
        isEmptyObject: function(c) {
            var g;
            for (g in c)
                return !1;
            return !0
        },
        globalEval: function(c, g, y) {
            _e(c, {
                nonce: g && g.nonce
            }, y)
        },
        each: function(c, g) {
            var y, A = 0;
            if (Ce(c))
                for (y = c.length; A < y && !1 !== g.call(c[A], A, c[A]); A++)
                    ;
            else
                for (A in c)
                    if (!1 === g.call(c[A], A, c[A]))
                        break;
            return c
        },
        text: function(c) {
            var g, y = "", A = 0, T = c.nodeType;
            if (!T)
                for (; g = c[A++]; )
                    y += m.text(g);
            return 1 === T || 11 === T ? c.textContent : 9 === T ? c.documentElement.textContent : 3 === T || 4 === T ? c.nodeValue : y
        },
        makeArray: function(c, g) {
            var y = g || [];
            return null != c && (Ce(Object(c)) ? m.merge(y, "string" == typeof c ? [c] : c) : Re.call(y, c)),
            y
        },
        inArray: function(c, g, y) {
            return null == g ? -1 : pe.call(g, c, y)
        },
        isXMLDoc: function(c) {
            var y = c && (c.ownerDocument || c).documentElement;
            return !he.test(c && c.namespaceURI || y && y.nodeName || "HTML")
        },
        merge: function(c, g) {
            for (var y = +g.length, A = 0, T = c.length; A < y; A++)
                c[T++] = g[A];
            return c.length = T,
            c
        },
        grep: function(c, g, y) {
            for (var A = [], T = 0, L = c.length, O = !y; T < L; T++)
                !g(c[T], T) !== O && A.push(c[T]);
            return A
        },
        map: function(c, g, y) {
            var A, T, L = 0, O = [];
            if (Ce(c))
                for (A = c.length; L < A; L++)
                    null != (T = g(c[L], L, y)) && O.push(T);
            else
                for (L in c)
                    null != (T = g(c[L], L, y)) && O.push(T);
            return Te(O)
        },
        guid: 1,
        support: J
    }),
    "function" == typeof Symbol && (m.fn[Symbol.iterator] = Ke[Symbol.iterator]),
    m.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(c, g) {
        ie["[object " + g + "]"] = g.toLowerCase()
    });
    var gt = Ke.pop
      , kt = Ke.sort
      , Kt = Ke.splice
      , We = "[\\x20\\t\\r\\n\\f]"
      , At = new RegExp("^" + We + "+|((?:^|[^\\\\])(?:\\\\.)*)" + We + "+$","g");
    m.contains = function(c, g) {
        var y = g && g.parentNode;
        return c === y || !(!y || 1 !== y.nodeType || !(c.contains ? c.contains(y) : c.compareDocumentPosition && 16 & c.compareDocumentPosition(y)))
    }
    ;
    var Oe = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
    function pt(c, g) {
        return g ? "\0" === c ? "\ufffd" : c.slice(0, -1) + "\\" + c.charCodeAt(c.length - 1).toString(16) + " " : "\\" + c
    }
    m.escapeSelector = function(c) {
        return (c + "").replace(Oe, pt)
    }
    ;
    var xt = D
      , St = Re;
    !function() {
        var c, g, y, A, T, L, O, W, N, ee, le = St, ge = m.expando, se = 0, ke = 0, Ze = Rt(), it = Rt(), at = Rt(), Nt = Rt(), Zt = function(z, Z) {
            return z === Z && (T = !0),
            0
        }, zi = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", Fi = "(?:\\\\[\\da-fA-F]{1,6}" + We + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", lt = "\\[" + We + "*(" + Fi + ")(?:" + We + "*([*^$|!~]?=)" + We + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + Fi + "))|)" + We + "*\\]", Ni = ":(" + Fi + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + lt + ")*)|.*)\\)|)", dt = new RegExp(We + "+","g"), Dt = new RegExp("^" + We + "*," + We + "*"), qi = new RegExp("^" + We + "*([>+~]|" + We + ")" + We + "*"), fa = new RegExp(We + "|>"), Xi = new RegExp(Ni), pa = new RegExp("^" + Fi + "$"), Ui = {
            ID: new RegExp("^#(" + Fi + ")"),
            CLASS: new RegExp("^\\.(" + Fi + ")"),
            TAG: new RegExp("^(" + Fi + "|[*])"),
            ATTR: new RegExp("^" + lt),
            PSEUDO: new RegExp("^" + Ni),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + We + "*(even|odd|(([+-]|)(\\d*)n|)" + We + "*(?:([+-]|)" + We + "*(\\d+)|))" + We + "*\\)|)","i"),
            bool: new RegExp("^(?:" + zi + ")$","i"),
            needsContext: new RegExp("^" + We + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + We + "*((?:-\\d)?\\d*)" + We + "*\\)|)(?=[^-]|$)","i")
        }, di = /^(?:input|select|textarea|button)$/i, ha = /^h\d$/i, Si = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, Xt = /[+~]/, Ht = new RegExp("\\\\[\\da-fA-F]{1,6}" + We + "?|\\\\([^\\r\\n\\f])","g"), oi = function(z, Z) {
            var oe = "0x" + z.slice(1) - 65536;
            return Z || (oe < 0 ? String.fromCharCode(oe + 65536) : String.fromCharCode(oe >> 10 | 55296, 1023 & oe | 56320))
        }, Zi = function() {
            ta()
        }, li = Sa(function(z) {
            return !0 === z.disabled && qe(z, "fieldset")
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            le.apply(Ke = we.call(xt.childNodes), xt.childNodes)
        } catch {
            le = {
                apply: function(Z, oe) {
                    St.apply(Z, we.call(oe))
                },
                call: function(Z) {
                    St.apply(Z, we.call(arguments, 1))
                }
            }
        }
        function $e(z, Z, oe, de) {
            var be, ze, Ne, je, Xe, ct, Je, ot = Z && Z.ownerDocument, ut = Z ? Z.nodeType : 9;
            if (oe = oe || [],
            "string" != typeof z || !z || 1 !== ut && 9 !== ut && 11 !== ut)
                return oe;
            if (!de && (ta(Z),
            Z = Z || L,
            W)) {
                if (11 !== ut && (Xe = Si.exec(z)))
                    if (be = Xe[1]) {
                        if (9 === ut) {
                            if (!(Ne = Z.getElementById(be)))
                                return oe;
                            if (Ne.id === be)
                                return le.call(oe, Ne),
                                oe
                        } else if (ot && (Ne = ot.getElementById(be)) && $e.contains(Z, Ne) && Ne.id === be)
                            return le.call(oe, Ne),
                            oe
                    } else {
                        if (Xe[2])
                            return le.apply(oe, Z.getElementsByTagName(z)),
                            oe;
                        if ((be = Xe[3]) && Z.getElementsByClassName)
                            return le.apply(oe, Z.getElementsByClassName(be)),
                            oe
                    }
                if (!(Nt[z + " "] || N && N.test(z))) {
                    if (Je = z,
                    ot = Z,
                    1 === ut && (fa.test(z) || qi.test(z))) {
                        for ((ot = Xt.test(z) && Oa(Z.parentNode) || Z) == Z && J.scope || ((je = Z.getAttribute("id")) ? je = m.escapeSelector(je) : Z.setAttribute("id", je = ge)),
                        ze = (ct = ma(z)).length; ze--; )
                            ct[ze] = (je ? "#" + je : ":scope") + " " + Aa(ct[ze]);
                        Je = ct.join(",")
                    }
                    try {
                        return le.apply(oe, ot.querySelectorAll(Je)),
                        oe
                    } catch {
                        Nt(z, !0)
                    } finally {
                        je === ge && Z.removeAttribute("id")
                    }
                }
            }
            return Ea(z.replace(At, "$1"), Z, oe, de)
        }
        function Rt() {
            var z = [];
            return function Z(oe, de) {
                return z.push(oe + " ") > g.cacheLength && delete Z[z.shift()],
                Z[oe + " "] = de
            }
        }
        function zt(z) {
            return z[ge] = !0,
            z
        }
        function Et(z) {
            var Z = L.createElement("fieldset");
            try {
                return !!z(Z)
            } catch {
                return !1
            } finally {
                Z.parentNode && Z.parentNode.removeChild(Z),
                Z = null
            }
        }
        function Yi(z) {
            return function(Z) {
                return qe(Z, "input") && Z.type === z
            }
        }
        function da(z) {
            return function(Z) {
                return (qe(Z, "input") || qe(Z, "button")) && Z.type === z
            }
        }
        function ea(z) {
            return function(Z) {
                return "form"in Z ? Z.parentNode && !1 === Z.disabled ? "label"in Z ? "label"in Z.parentNode ? Z.parentNode.disabled === z : Z.disabled === z : Z.isDisabled === z || Z.isDisabled !== !z && li(Z) === z : Z.disabled === z : "label"in Z && Z.disabled === z
            }
        }
        function wi(z) {
            return zt(function(Z) {
                return Z = +Z,
                zt(function(oe, de) {
                    for (var be, ze = z([], oe.length, Z), Ne = ze.length; Ne--; )
                        oe[be = ze[Ne]] && (oe[be] = !(de[be] = oe[be]))
                })
            })
        }
        function Oa(z) {
            return z && typeof z.getElementsByTagName < "u" && z
        }
        function ta(z) {
            var Z, oe = z ? z.ownerDocument || z : xt;
            return oe != L && 9 === oe.nodeType && oe.documentElement && (O = (L = oe).documentElement,
            W = !m.isXMLDoc(L),
            ee = O.matches || O.webkitMatchesSelector || O.msMatchesSelector,
            O.msMatchesSelector && xt != L && (Z = L.defaultView) && Z.top !== Z && Z.addEventListener("unload", Zi),
            J.getById = Et(function(de) {
                return O.appendChild(de).id = m.expando,
                !L.getElementsByName || !L.getElementsByName(m.expando).length
            }),
            J.disconnectedMatch = Et(function(de) {
                return ee.call(de, "*")
            }),
            J.scope = Et(function() {
                return L.querySelectorAll(":scope")
            }),
            J.cssHas = Et(function() {
                try {
                    return L.querySelector(":has(*,:jqfake)"),
                    !1
                } catch {
                    return !0
                }
            }),
            J.getById ? (g.filter.ID = function(de) {
                var be = de.replace(Ht, oi);
                return function(ze) {
                    return ze.getAttribute("id") === be
                }
            }
            ,
            g.find.ID = function(de, be) {
                if (typeof be.getElementById < "u" && W) {
                    var ze = be.getElementById(de);
                    return ze ? [ze] : []
                }
            }
            ) : (g.filter.ID = function(de) {
                var be = de.replace(Ht, oi);
                return function(ze) {
                    var Ne = typeof ze.getAttributeNode < "u" && ze.getAttributeNode("id");
                    return Ne && Ne.value === be
                }
            }
            ,
            g.find.ID = function(de, be) {
                if (typeof be.getElementById < "u" && W) {
                    var ze, Ne, je, Xe = be.getElementById(de);
                    if (Xe) {
                        if ((ze = Xe.getAttributeNode("id")) && ze.value === de)
                            return [Xe];
                        for (je = be.getElementsByName(de),
                        Ne = 0; Xe = je[Ne++]; )
                            if ((ze = Xe.getAttributeNode("id")) && ze.value === de)
                                return [Xe]
                    }
                    return []
                }
            }
            ),
            g.find.TAG = function(de, be) {
                return typeof be.getElementsByTagName < "u" ? be.getElementsByTagName(de) : be.querySelectorAll(de)
            }
            ,
            g.find.CLASS = function(de, be) {
                if (typeof be.getElementsByClassName < "u" && W)
                    return be.getElementsByClassName(de)
            }
            ,
            N = [],
            Et(function(de) {
                var be;
                O.appendChild(de).innerHTML = "<a id='" + ge + "' href='' disabled='disabled'></a><select id='" + ge + "-\r\\' disabled='disabled'><option selected=''></option></select>",
                de.querySelectorAll("[selected]").length || N.push("\\[" + We + "*(?:value|" + zi + ")"),
                de.querySelectorAll("[id~=" + ge + "-]").length || N.push("~="),
                de.querySelectorAll("a#" + ge + "+*").length || N.push(".#.+[+~]"),
                de.querySelectorAll(":checked").length || N.push(":checked"),
                (be = L.createElement("input")).setAttribute("type", "hidden"),
                de.appendChild(be).setAttribute("name", "D"),
                O.appendChild(de).disabled = !0,
                2 !== de.querySelectorAll(":disabled").length && N.push(":enabled", ":disabled"),
                (be = L.createElement("input")).setAttribute("name", ""),
                de.appendChild(be),
                de.querySelectorAll("[name='']").length || N.push("\\[" + We + "*name" + We + "*=" + We + "*(?:''|\"\")")
            }),
            J.cssHas || N.push(":has"),
            N = N.length && new RegExp(N.join("|")),
            Zt = function(de, be) {
                if (de === be)
                    return T = !0,
                    0;
                var ze = !de.compareDocumentPosition - !be.compareDocumentPosition;
                return ze || (1 & (ze = (de.ownerDocument || de) == (be.ownerDocument || be) ? de.compareDocumentPosition(be) : 1) || !J.sortDetached && be.compareDocumentPosition(de) === ze ? de === L || de.ownerDocument == xt && $e.contains(xt, de) ? -1 : be === L || be.ownerDocument == xt && $e.contains(xt, be) ? 1 : A ? pe.call(A, de) - pe.call(A, be) : 0 : 4 & ze ? -1 : 1)
            }
            ),
            L
        }
        for (c in $e.matches = function(z, Z) {
            return $e(z, null, null, Z)
        }
        ,
        $e.matchesSelector = function(z, Z) {
            if (ta(z),
            W && !Nt[Z + " "] && (!N || !N.test(Z)))
                try {
                    var oe = ee.call(z, Z);
                    if (oe || J.disconnectedMatch || z.document && 11 !== z.document.nodeType)
                        return oe
                } catch {
                    Nt(Z, !0)
                }
            return 0 < $e(Z, L, null, [z]).length
        }
        ,
        $e.contains = function(z, Z) {
            return (z.ownerDocument || z) != L && ta(z),
            m.contains(z, Z)
        }
        ,
        $e.attr = function(z, Z) {
            (z.ownerDocument || z) != L && ta(z);
            var oe = g.attrHandle[Z.toLowerCase()]
              , de = oe && De.call(g.attrHandle, Z.toLowerCase()) ? oe(z, Z, !W) : void 0;
            return void 0 !== de ? de : z.getAttribute(Z)
        }
        ,
        $e.error = function(z) {
            throw new Error("Syntax error, unrecognized expression: " + z)
        }
        ,
        m.uniqueSort = function(z) {
            var Z, oe = [], de = 0, be = 0;
            if (T = !J.sortStable,
            A = !J.sortStable && we.call(z, 0),
            kt.call(z, Zt),
            T) {
                for (; Z = z[be++]; )
                    Z === z[be] && (de = oe.push(be));
                for (; de--; )
                    Kt.call(z, oe[de], 1)
            }
            return A = null,
            z
        }
        ,
        m.fn.uniqueSort = function() {
            return this.pushStack(m.uniqueSort(we.apply(this)))
        }
        ,
        (g = m.expr = {
            cacheLength: 50,
            createPseudo: zt,
            match: Ui,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(z) {
                    return z[1] = z[1].replace(Ht, oi),
                    z[3] = (z[3] || z[4] || z[5] || "").replace(Ht, oi),
                    "~=" === z[2] && (z[3] = " " + z[3] + " "),
                    z.slice(0, 4)
                },
                CHILD: function(z) {
                    return z[1] = z[1].toLowerCase(),
                    "nth" === z[1].slice(0, 3) ? (z[3] || $e.error(z[0]),
                    z[4] = +(z[4] ? z[5] + (z[6] || 1) : 2 * ("even" === z[3] || "odd" === z[3])),
                    z[5] = +(z[7] + z[8] || "odd" === z[3])) : z[3] && $e.error(z[0]),
                    z
                },
                PSEUDO: function(z) {
                    var Z, oe = !z[6] && z[2];
                    return Ui.CHILD.test(z[0]) ? null : (z[3] ? z[2] = z[4] || z[5] || "" : oe && Xi.test(oe) && (Z = ma(oe, !0)) && (Z = oe.indexOf(")", oe.length - Z) - oe.length) && (z[0] = z[0].slice(0, Z),
                    z[2] = oe.slice(0, Z)),
                    z.slice(0, 3))
                }
            },
            filter: {
                TAG: function(z) {
                    var Z = z.replace(Ht, oi).toLowerCase();
                    return "*" === z ? function() {
                        return !0
                    }
                    : function(oe) {
                        return qe(oe, Z)
                    }
                },
                CLASS: function(z) {
                    var Z = Ze[z + " "];
                    return Z || (Z = new RegExp("(^|" + We + ")" + z + "(" + We + "|$)")) && Ze(z, function(oe) {
                        return Z.test("string" == typeof oe.className && oe.className || typeof oe.getAttribute < "u" && oe.getAttribute("class") || "")
                    })
                },
                ATTR: function(z, Z, oe) {
                    return function(de) {
                        var be = $e.attr(de, z);
                        return null == be ? "!=" === Z : !Z || (be += "",
                        "=" === Z ? be === oe : "!=" === Z ? be !== oe : "^=" === Z ? oe && 0 === be.indexOf(oe) : "*=" === Z ? oe && -1 < be.indexOf(oe) : "$=" === Z ? oe && be.slice(-oe.length) === oe : "~=" === Z ? -1 < (" " + be.replace(dt, " ") + " ").indexOf(oe) : "|=" === Z && (be === oe || be.slice(0, oe.length + 1) === oe + "-"))
                    }
                },
                CHILD: function(z, Z, oe, de, be) {
                    var ze = "nth" !== z.slice(0, 3)
                      , Ne = "last" !== z.slice(-4)
                      , je = "of-type" === Z;
                    return 1 === de && 0 === be ? function(Xe) {
                        return !!Xe.parentNode
                    }
                    : function(Xe, ct, Je) {
                        var ot, ut, et, jt, si, $t = ze !== Ne ? "nextSibling" : "previousSibling", ui = Xe.parentNode, ki = je && Xe.nodeName.toLowerCase(), Ci = !Je && !je, bt = !1;
                        if (ui) {
                            if (ze) {
                                for (; $t; ) {
                                    for (et = Xe; et = et[$t]; )
                                        if (je ? qe(et, ki) : 1 === et.nodeType)
                                            return !1;
                                    si = $t = "only" === z && !si && "nextSibling"
                                }
                                return !0
                            }
                            if (si = [Ne ? ui.firstChild : ui.lastChild],
                            Ne && Ci) {
                                for (bt = (jt = (ot = (ut = ui[ge] || (ui[ge] = {}))[z] || [])[0] === se && ot[1]) && ot[2],
                                et = jt && ui.childNodes[jt]; et = ++jt && et && et[$t] || (bt = jt = 0) || si.pop(); )
                                    if (1 === et.nodeType && ++bt && et === Xe) {
                                        ut[z] = [se, jt, bt];
                                        break
                                    }
                            } else if (Ci && (bt = jt = (ot = (ut = Xe[ge] || (Xe[ge] = {}))[z] || [])[0] === se && ot[1]),
                            !1 === bt)
                                for (; (et = ++jt && et && et[$t] || (bt = jt = 0) || si.pop()) && (!(je ? qe(et, ki) : 1 === et.nodeType) || !++bt || (Ci && ((ut = et[ge] || (et[ge] = {}))[z] = [se, bt]),
                                et !== Xe)); )
                                    ;
                            return (bt -= be) === de || bt % de == 0 && 0 <= bt / de
                        }
                    }
                },
                PSEUDO: function(z, Z) {
                    var oe, de = g.pseudos[z] || g.setFilters[z.toLowerCase()] || $e.error("unsupported pseudo: " + z);
                    return de[ge] ? de(Z) : 1 < de.length ? (oe = [z, z, "", Z],
                    g.setFilters.hasOwnProperty(z.toLowerCase()) ? zt(function(be, ze) {
                        for (var Ne, je = de(be, Z), Xe = je.length; Xe--; )
                            be[Ne = pe.call(be, je[Xe])] = !(ze[Ne] = je[Xe])
                    }) : function(be) {
                        return de(be, 0, oe)
                    }
                    ) : de
                }
            },
            pseudos: {
                not: zt(function(z) {
                    var Z = []
                      , oe = []
                      , de = _a(z.replace(At, "$1"));
                    return de[ge] ? zt(function(be, ze, Ne, je) {
                        for (var Xe, ct = de(be, null, je, []), Je = be.length; Je--; )
                            (Xe = ct[Je]) && (be[Je] = !(ze[Je] = Xe))
                    }) : function(be, ze, Ne) {
                        return Z[0] = be,
                        de(Z, null, Ne, oe),
                        Z[0] = null,
                        !oe.pop()
                    }
                }),
                has: zt(function(z) {
                    return function(Z) {
                        return 0 < $e(z, Z).length
                    }
                }),
                contains: zt(function(z) {
                    return z = z.replace(Ht, oi),
                    function(Z) {
                        return -1 < (Z.textContent || m.text(Z)).indexOf(z)
                    }
                }),
                lang: zt(function(z) {
                    return pa.test(z || "") || $e.error("unsupported lang: " + z),
                    z = z.replace(Ht, oi).toLowerCase(),
                    function(Z) {
                        var oe;
                        do {
                            if (oe = W ? Z.lang : Z.getAttribute("xml:lang") || Z.getAttribute("lang"))
                                return (oe = oe.toLowerCase()) === z || 0 === oe.indexOf(z + "-")
                        } while ((Z = Z.parentNode) && 1 === Z.nodeType);
                        return !1
                    }
                }),
                target: function(z) {
                    var Z = $.location && $.location.hash;
                    return Z && Z.slice(1) === z.id
                },
                root: function(z) {
                    return z === O
                },
                focus: function(z) {
                    return z === function() {
                        try {
                            return L.activeElement
                        } catch {}
                    }() && L.hasFocus() && !!(z.type || z.href || ~z.tabIndex)
                },
                enabled: ea(!1),
                disabled: ea(!0),
                checked: function(z) {
                    return qe(z, "input") && !!z.checked || qe(z, "option") && !!z.selected
                },
                selected: function(z) {
                    return !0 === z.selected
                },
                empty: function(z) {
                    for (z = z.firstChild; z; z = z.nextSibling)
                        if (z.nodeType < 6)
                            return !1;
                    return !0
                },
                parent: function(z) {
                    return !g.pseudos.empty(z)
                },
                header: function(z) {
                    return ha.test(z.nodeName)
                },
                input: function(z) {
                    return di.test(z.nodeName)
                },
                button: function(z) {
                    return qe(z, "input") && "button" === z.type || qe(z, "button")
                },
                text: function(z) {
                    var Z;
                    return qe(z, "input") && "text" === z.type && (null == (Z = z.getAttribute("type")) || "text" === Z.toLowerCase())
                },
                first: wi(function() {
                    return [0]
                }),
                last: wi(function(z, Z) {
                    return [Z - 1]
                }),
                eq: wi(function(z, Z, oe) {
                    return [oe < 0 ? oe + Z : oe]
                }),
                even: wi(function(z, Z) {
                    for (var oe = 0; oe < Z; oe += 2)
                        z.push(oe);
                    return z
                }),
                odd: wi(function(z, Z) {
                    for (var oe = 1; oe < Z; oe += 2)
                        z.push(oe);
                    return z
                }),
                lt: wi(function(z, Z, oe) {
                    var de;
                    for (de = oe < 0 ? oe + Z : Z < oe ? Z : oe; 0 <= --de; )
                        z.push(de);
                    return z
                }),
                gt: wi(function(z, Z, oe) {
                    for (var de = oe < 0 ? oe + Z : oe; ++de < Z; )
                        z.push(de);
                    return z
                })
            }
        }).pseudos.nth = g.pseudos.eq,
        {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        })
            g.pseudos[c] = Yi(c);
        for (c in {
            submit: !0,
            reset: !0
        })
            g.pseudos[c] = da(c);
        function Ga() {}
        function ma(z, Z) {
            var oe, de, be, ze, Ne, je, Xe, ct = it[z + " "];
            if (ct)
                return Z ? 0 : ct.slice(0);
            for (Ne = z,
            je = [],
            Xe = g.preFilter; Ne; ) {
                for (ze in oe && !(de = Dt.exec(Ne)) || (de && (Ne = Ne.slice(de[0].length) || Ne),
                je.push(be = [])),
                oe = !1,
                (de = qi.exec(Ne)) && (oe = de.shift(),
                be.push({
                    value: oe,
                    type: de[0].replace(At, " ")
                }),
                Ne = Ne.slice(oe.length)),
                g.filter)
                    !(de = Ui[ze].exec(Ne)) || Xe[ze] && !(de = Xe[ze](de)) || (oe = de.shift(),
                    be.push({
                        value: oe,
                        type: ze,
                        matches: de
                    }),
                    Ne = Ne.slice(oe.length));
                if (!oe)
                    break
            }
            return Z ? Ne.length : Ne ? $e.error(z) : it(z, je).slice(0)
        }
        function Aa(z) {
            for (var Z = 0, oe = z.length, de = ""; Z < oe; Z++)
                de += z[Z].value;
            return de
        }
        function Sa(z, Z, oe) {
            var de = Z.dir
              , be = Z.next
              , ze = be || de
              , Ne = oe && "parentNode" === ze
              , je = ke++;
            return Z.first ? function(Xe, ct, Je) {
                for (; Xe = Xe[de]; )
                    if (1 === Xe.nodeType || Ne)
                        return z(Xe, ct, Je);
                return !1
            }
            : function(Xe, ct, Je) {
                var ot, ut, et = [se, je];
                if (Je) {
                    for (; Xe = Xe[de]; )
                        if ((1 === Xe.nodeType || Ne) && z(Xe, ct, Je))
                            return !0
                } else
                    for (; Xe = Xe[de]; )
                        if (1 === Xe.nodeType || Ne)
                            if (ut = Xe[ge] || (Xe[ge] = {}),
                            be && qe(Xe, be))
                                Xe = Xe[de] || Xe;
                            else {
                                if ((ot = ut[ze]) && ot[0] === se && ot[1] === je)
                                    return et[2] = ot[2];
                                if ((ut[ze] = et)[2] = z(Xe, ct, Je))
                                    return !0
                            }
                return !1
            }
        }
        function Ha(z) {
            return 1 < z.length ? function(Z, oe, de) {
                for (var be = z.length; be--; )
                    if (!z[be](Z, oe, de))
                        return !1;
                return !0
            }
            : z[0]
        }
        function Ca(z, Z, oe, de, be) {
            for (var ze, Ne = [], je = 0, Xe = z.length, ct = null != Z; je < Xe; je++)
                (ze = z[je]) && (oe && !oe(ze, de, be) || (Ne.push(ze),
                ct && Z.push(je)));
            return Ne
        }
        function Ta(z, Z, oe, de, be, ze) {
            return de && !de[ge] && (de = Ta(de)),
            be && !be[ge] && (be = Ta(be, ze)),
            zt(function(Ne, je, Xe, ct) {
                var Je, ot, ut, et, jt = [], si = [], $t = je.length, ui = Ne || function(Ci, bt, Wi) {
                    for (var Ii = 0, La = bt.length; Ii < La; Ii++)
                        $e(Ci, bt[Ii], Wi);
                    return Wi
                }(Z || "*", Xe.nodeType ? [Xe] : Xe, []), ki = !z || !Ne && Z ? ui : Ca(ui, jt, z, Xe, ct);
                if (oe ? oe(ki, et = be || (Ne ? z : $t || de) ? [] : je, Xe, ct) : et = ki,
                de)
                    for (Je = Ca(et, si),
                    de(Je, [], Xe, ct),
                    ot = Je.length; ot--; )
                        (ut = Je[ot]) && (et[si[ot]] = !(ki[si[ot]] = ut));
                if (Ne) {
                    if (be || z) {
                        if (be) {
                            for (Je = [],
                            ot = et.length; ot--; )
                                (ut = et[ot]) && Je.push(ki[ot] = ut);
                            be(null, et = [], Je, ct)
                        }
                        for (ot = et.length; ot--; )
                            (ut = et[ot]) && -1 < (Je = be ? pe.call(Ne, ut) : jt[ot]) && (Ne[Je] = !(je[Je] = ut))
                    }
                } else
                    et = Ca(et === je ? et.splice($t, et.length) : et),
                    be ? be(null, je, et, ct) : le.apply(je, et)
            })
        }
        function za(z) {
            for (var Z, oe, de, be = z.length, ze = g.relative[z[0].type], Ne = ze || g.relative[" "], je = ze ? 1 : 0, Xe = Sa(function(ot) {
                return ot === Z
            }, Ne, !0), ct = Sa(function(ot) {
                return -1 < pe.call(Z, ot)
            }, Ne, !0), Je = [function(ot, ut, et) {
                var jt = !ze && (et || ut != y) || ((Z = ut).nodeType ? Xe(ot, ut, et) : ct(ot, ut, et));
                return Z = null,
                jt
            }
            ]; je < be; je++)
                if (oe = g.relative[z[je].type])
                    Je = [Sa(Ha(Je), oe)];
                else {
                    if ((oe = g.filter[z[je].type].apply(null, z[je].matches))[ge]) {
                        for (de = ++je; de < be && !g.relative[z[de].type]; de++)
                            ;
                        return Ta(1 < je && Ha(Je), 1 < je && Aa(z.slice(0, je - 1).concat({
                            value: " " === z[je - 2].type ? "*" : ""
                        })).replace(At, "$1"), oe, je < de && za(z.slice(je, de)), de < be && za(z = z.slice(de)), de < be && Aa(z))
                    }
                    Je.push(oe)
                }
            return Ha(Je)
        }
        function _a(z, Z) {
            var oe, de, be, ze, Ne, je, Xe = [], ct = [], Je = at[z + " "];
            if (!Je) {
                for (Z || (Z = ma(z)),
                oe = Z.length; oe--; )
                    (Je = za(Z[oe]))[ge] ? Xe.push(Je) : ct.push(Je);
                (Je = at(z, (de = ct,
                ze = 0 < (be = Xe).length,
                Ne = 0 < de.length,
                je = function(ot, ut, et, jt, si) {
                    var $t, ui, ki, Ci = 0, bt = "0", Wi = ot && [], Ii = [], La = y, ua = ot || Ne && g.find.TAG("*", si), G = se += null == La ? 1 : Math.random() || .1, v = ua.length;
                    for (si && (y = ut == L || ut || si); bt !== v && null != ($t = ua[bt]); bt++) {
                        if (Ne && $t) {
                            for (ui = 0,
                            ut || $t.ownerDocument == L || (ta($t),
                            et = !W); ki = de[ui++]; )
                                if (ki($t, ut || L, et)) {
                                    le.call(jt, $t);
                                    break
                                }
                            si && (se = G)
                        }
                        ze && (($t = !ki && $t) && Ci--,
                        ot && Wi.push($t))
                    }
                    if (Ci += bt,
                    ze && bt !== Ci) {
                        for (ui = 0; ki = be[ui++]; )
                            ki(Wi, Ii, ut, et);
                        if (ot) {
                            if (0 < Ci)
                                for (; bt--; )
                                    Wi[bt] || Ii[bt] || (Ii[bt] = gt.call(jt));
                            Ii = Ca(Ii)
                        }
                        le.apply(jt, Ii),
                        si && !ot && 0 < Ii.length && 1 < Ci + be.length && m.uniqueSort(jt)
                    }
                    return si && (se = G,
                    y = La),
                    Wi
                }
                ,
                ze ? zt(je) : je))).selector = z
            }
            return Je
        }
        function Ea(z, Z, oe, de) {
            var be, ze, Ne, je, Xe, ct = "function" == typeof z && z, Je = !de && ma(z = ct.selector || z);
            if (oe = oe || [],
            1 === Je.length) {
                if (2 < (ze = Je[0] = Je[0].slice(0)).length && "ID" === (Ne = ze[0]).type && 9 === Z.nodeType && W && g.relative[ze[1].type]) {
                    if (!(Z = (g.find.ID(Ne.matches[0].replace(Ht, oi), Z) || [])[0]))
                        return oe;
                    ct && (Z = Z.parentNode),
                    z = z.slice(ze.shift().value.length)
                }
                for (be = Ui.needsContext.test(z) ? 0 : ze.length; be-- && !g.relative[je = (Ne = ze[be]).type]; )
                    if ((Xe = g.find[je]) && (de = Xe(Ne.matches[0].replace(Ht, oi), Xt.test(ze[0].type) && Oa(Z.parentNode) || Z))) {
                        if (ze.splice(be, 1),
                        !(z = de.length && Aa(ze)))
                            return le.apply(oe, de),
                            oe;
                        break
                    }
            }
            return (ct || _a(z, Je))(de, Z, !W, oe, !Z || Xt.test(z) && Oa(Z.parentNode) || Z),
            oe
        }
        Ga.prototype = g.filters = g.pseudos,
        g.setFilters = new Ga,
        J.sortStable = ge.split("").sort(Zt).join("") === ge,
        ta(),
        J.sortDetached = Et(function(z) {
            return 1 & z.compareDocumentPosition(L.createElement("fieldset"))
        }),
        m.find = $e,
        m.expr[":"] = m.expr.pseudos,
        m.unique = m.uniqueSort,
        $e.compile = _a,
        $e.select = Ea,
        $e.setDocument = ta,
        $e.tokenize = ma,
        $e.escape = m.escapeSelector,
        $e.getText = m.text,
        $e.isXML = m.isXMLDoc,
        $e.selectors = m.expr,
        $e.support = m.support,
        $e.uniqueSort = m.uniqueSort
    }();
    var yt = function(c, g, y) {
        for (var A = [], T = void 0 !== y; (c = c[g]) && 9 !== c.nodeType; )
            if (1 === c.nodeType) {
                if (T && m(c).is(y))
                    break;
                A.push(c)
            }
        return A
    }
      , ri = function(c, g) {
        for (var y = []; c; c = c.nextSibling)
            1 === c.nodeType && c !== g && y.push(c);
        return y
    }
      , wt = m.expr.match.needsContext
      , ye = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function gi(c, g, y) {
        return Y(g) ? m.grep(c, function(A, T) {
            return !!g.call(A, T, A) !== y
        }) : g.nodeType ? m.grep(c, function(A) {
            return A === g !== y
        }) : "string" != typeof g ? m.grep(c, function(A) {
            return -1 < pe.call(g, A) !== y
        }) : m.filter(g, c, y)
    }
    m.filter = function(c, g, y) {
        var A = g[0];
        return y && (c = ":not(" + c + ")"),
        1 === g.length && 1 === A.nodeType ? m.find.matchesSelector(A, c) ? [A] : [] : m.find.matches(c, m.grep(g, function(T) {
            return 1 === T.nodeType
        }))
    }
    ,
    m.fn.extend({
        find: function(c) {
            var g, y, A = this.length, T = this;
            if ("string" != typeof c)
                return this.pushStack(m(c).filter(function() {
                    for (g = 0; g < A; g++)
                        if (m.contains(T[g], this))
                            return !0
                }));
            for (y = this.pushStack([]),
            g = 0; g < A; g++)
                m.find(c, T[g], y);
            return 1 < A ? m.uniqueSort(y) : y
        },
        filter: function(c) {
            return this.pushStack(gi(this, c || [], !1))
        },
        not: function(c) {
            return this.pushStack(gi(this, c || [], !0))
        },
        is: function(c) {
            return !!gi(this, "string" == typeof c && wt.test(c) ? m(c) : c || [], !1).length
        }
    });
    var It, Lt = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (m.fn.init = function(c, g, y) {
        var A, T;
        if (!c)
            return this;
        if (y = y || It,
        "string" == typeof c) {
            if (!(A = "<" === c[0] && ">" === c[c.length - 1] && 3 <= c.length ? [null, c, null] : Lt.exec(c)) || !A[1] && g)
                return !g || g.jquery ? (g || y).find(c) : this.constructor(g).find(c);
            if (A[1]) {
                if (m.merge(this, m.parseHTML(A[1], (g = g instanceof m ? g[0] : g) && g.nodeType ? g.ownerDocument || g : D, !0)),
                ye.test(A[1]) && m.isPlainObject(g))
                    for (A in g)
                        Y(this[A]) ? this[A](g[A]) : this.attr(A, g[A]);
                return this
            }
            return (T = D.getElementById(A[2])) && (this[0] = T,
            this.length = 1),
            this
        }
        return c.nodeType ? (this[0] = c,
        this.length = 1,
        this) : Y(c) ? void 0 !== y.ready ? y.ready(c) : c(m) : m.makeArray(c, this)
    }
    ).prototype = m.fn,
    It = m(D);
    var Ct = /^(?:parents|prev(?:Until|All))/
      , Mt = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    function Ft(c, g) {
        for (; (c = c[g]) && 1 !== c.nodeType; )
            ;
        return c
    }
    m.fn.extend({
        has: function(c) {
            var g = m(c, this)
              , y = g.length;
            return this.filter(function() {
                for (var A = 0; A < y; A++)
                    if (m.contains(this, g[A]))
                        return !0
            })
        },
        closest: function(c, g) {
            var y, A = 0, T = this.length, L = [], O = "string" != typeof c && m(c);
            if (!wt.test(c))
                for (; A < T; A++)
                    for (y = this[A]; y && y !== g; y = y.parentNode)
                        if (y.nodeType < 11 && (O ? -1 < O.index(y) : 1 === y.nodeType && m.find.matchesSelector(y, c))) {
                            L.push(y);
                            break
                        }
            return this.pushStack(1 < L.length ? m.uniqueSort(L) : L)
        },
        index: function(c) {
            return c ? "string" == typeof c ? pe.call(m(c), this[0]) : pe.call(this, c.jquery ? c[0] : c) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(c, g) {
            return this.pushStack(m.uniqueSort(m.merge(this.get(), m(c, g))))
        },
        addBack: function(c) {
            return this.add(null == c ? this.prevObject : this.prevObject.filter(c))
        }
    }),
    m.each({
        parent: function(c) {
            var g = c.parentNode;
            return g && 11 !== g.nodeType ? g : null
        },
        parents: function(c) {
            return yt(c, "parentNode")
        },
        parentsUntil: function(c, g, y) {
            return yt(c, "parentNode", y)
        },
        next: function(c) {
            return Ft(c, "nextSibling")
        },
        prev: function(c) {
            return Ft(c, "previousSibling")
        },
        nextAll: function(c) {
            return yt(c, "nextSibling")
        },
        prevAll: function(c) {
            return yt(c, "previousSibling")
        },
        nextUntil: function(c, g, y) {
            return yt(c, "nextSibling", y)
        },
        prevUntil: function(c, g, y) {
            return yt(c, "previousSibling", y)
        },
        siblings: function(c) {
            return ri((c.parentNode || {}).firstChild, c)
        },
        children: function(c) {
            return ri(c.firstChild)
        },
        contents: function(c) {
            return null != c.contentDocument && Q(c.contentDocument) ? c.contentDocument : (qe(c, "template") && (c = c.content || c),
            m.merge([], c.childNodes))
        }
    }, function(c, g) {
        m.fn[c] = function(y, A) {
            var T = m.map(this, g, y);
            return "Until" !== c.slice(-5) && (A = y),
            A && "string" == typeof A && (T = m.filter(A, T)),
            1 < this.length && (Mt[c] || m.uniqueSort(T),
            Ct.test(c) && T.reverse()),
            this.pushStack(T)
        }
    });
    var Ot = /[^\x20\t\r\n\f]+/g;
    function Be(c) {
        return c
    }
    function Jt(c) {
        throw c
    }
    function Di(c, g, y, A) {
        var T;
        try {
            c && Y(T = c.promise) ? T.call(c).done(g).fail(y) : c && Y(T = c.then) ? T.call(c, g, y) : g.apply(void 0, [c].slice(A))
        } catch (L) {
            y.apply(void 0, [L])
        }
    }
    m.Callbacks = function(c) {
        var y;
        c = "string" == typeof c ? (y = {},
        m.each(c.match(Ot) || [], function(se, ke) {
            y[ke] = !0
        }),
        y) : m.extend({}, c);
        var A, T, L, O, W = [], N = [], ee = -1, le = function() {
            for (O = O || c.once,
            L = A = !0; N.length; ee = -1)
                for (T = N.shift(); ++ee < W.length; )
                    !1 === W[ee].apply(T[0], T[1]) && c.stopOnFalse && (ee = W.length,
                    T = !1);
            c.memory || (T = !1),
            A = !1,
            O && (W = T ? [] : "")
        }, ge = {
            add: function() {
                return W && (T && !A && (ee = W.length - 1,
                N.push(T)),
                function se(ke) {
                    m.each(ke, function(Ze, it) {
                        Y(it) ? c.unique && ge.has(it) || W.push(it) : it && it.length && "string" !== U(it) && se(it)
                    })
                }(arguments),
                T && !A && le()),
                this
            },
            remove: function() {
                return m.each(arguments, function(se, ke) {
                    for (var Ze; -1 < (Ze = m.inArray(ke, W, Ze)); )
                        W.splice(Ze, 1),
                        Ze <= ee && ee--
                }),
                this
            },
            has: function(se) {
                return se ? -1 < m.inArray(se, W) : 0 < W.length
            },
            empty: function() {
                return W && (W = []),
                this
            },
            disable: function() {
                return O = N = [],
                W = T = "",
                this
            },
            disabled: function() {
                return !W
            },
            lock: function() {
                return O = N = [],
                T || A || (W = T = ""),
                this
            },
            locked: function() {
                return !!O
            },
            fireWith: function(se, ke) {
                return O || (ke = [se, (ke = ke || []).slice ? ke.slice() : ke],
                N.push(ke),
                A || le()),
                this
            },
            fire: function() {
                return ge.fireWith(this, arguments),
                this
            },
            fired: function() {
                return !!L
            }
        };
        return ge
    }
    ,
    m.extend({
        Deferred: function(c) {
            var g = [["notify", "progress", m.Callbacks("memory"), m.Callbacks("memory"), 2], ["resolve", "done", m.Callbacks("once memory"), m.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", m.Callbacks("once memory"), m.Callbacks("once memory"), 1, "rejected"]]
              , y = "pending"
              , A = {
                state: function() {
                    return y
                },
                always: function() {
                    return T.done(arguments).fail(arguments),
                    this
                },
                catch: function(L) {
                    return A.then(null, L)
                },
                pipe: function() {
                    var L = arguments;
                    return m.Deferred(function(O) {
                        m.each(g, function(W, N) {
                            var ee = Y(L[N[4]]) && L[N[4]];
                            T[N[1]](function() {
                                var le = ee && ee.apply(this, arguments);
                                le && Y(le.promise) ? le.promise().progress(O.notify).done(O.resolve).fail(O.reject) : O[N[0] + "With"](this, ee ? [le] : arguments)
                            })
                        }),
                        L = null
                    }).promise()
                },
                then: function(L, O, W) {
                    var N = 0;
                    function ee(le, ge, se, ke) {
                        return function() {
                            var Ze = this
                              , it = arguments
                              , at = function() {
                                var Zt, zi;
                                if (!(le < N)) {
                                    if ((Zt = se.apply(Ze, it)) === ge.promise())
                                        throw new TypeError("Thenable self-resolution");
                                    Y(zi = Zt && ("object" == typeof Zt || "function" == typeof Zt) && Zt.then) ? ke ? zi.call(Zt, ee(N, ge, Be, ke), ee(N, ge, Jt, ke)) : (N++,
                                    zi.call(Zt, ee(N, ge, Be, ke), ee(N, ge, Jt, ke), ee(N, ge, Be, ge.notifyWith))) : (se !== Be && (Ze = void 0,
                                    it = [Zt]),
                                    (ke || ge.resolveWith)(Ze, it))
                                }
                            }
                              , Nt = ke ? at : function() {
                                try {
                                    at()
                                } catch (Zt) {
                                    m.Deferred.exceptionHook && m.Deferred.exceptionHook(Zt, Nt.error),
                                    N <= le + 1 && (se !== Jt && (Ze = void 0,
                                    it = [Zt]),
                                    ge.rejectWith(Ze, it))
                                }
                            }
                            ;
                            le ? Nt() : (m.Deferred.getErrorHook ? Nt.error = m.Deferred.getErrorHook() : m.Deferred.getStackHook && (Nt.error = m.Deferred.getStackHook()),
                            $.setTimeout(Nt))
                        }
                    }
                    return m.Deferred(function(le) {
                        g[0][3].add(ee(0, le, Y(W) ? W : Be, le.notifyWith)),
                        g[1][3].add(ee(0, le, Y(L) ? L : Be)),
                        g[2][3].add(ee(0, le, Y(O) ? O : Jt))
                    }).promise()
                },
                promise: function(L) {
                    return null != L ? m.extend(L, A) : A
                }
            }
              , T = {};
            return m.each(g, function(L, O) {
                var W = O[2]
                  , N = O[5];
                A[O[1]] = W.add,
                N && W.add(function() {
                    y = N
                }, g[3 - L][2].disable, g[3 - L][3].disable, g[0][2].lock, g[0][3].lock),
                W.add(O[3].fire),
                T[O[0]] = function() {
                    return T[O[0] + "With"](this === T ? void 0 : this, arguments),
                    this
                }
                ,
                T[O[0] + "With"] = W.fireWith
            }),
            A.promise(T),
            c && c.call(T, T),
            T
        },
        when: function(c) {
            var g = arguments.length
              , y = g
              , A = Array(y)
              , T = we.call(arguments)
              , L = m.Deferred()
              , O = function(W) {
                return function(N) {
                    A[W] = this,
                    T[W] = 1 < arguments.length ? we.call(arguments) : N,
                    --g || L.resolveWith(A, T)
                }
            };
            if (g <= 1 && (Di(c, L.done(O(y)).resolve, L.reject, !g),
            "pending" === L.state() || Y(T[y] && T[y].then)))
                return L.then();
            for (; y--; )
                Di(T[y], O(y), L.reject);
            return L.promise()
        }
    });
    var ia = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    m.Deferred.exceptionHook = function(c, g) {
        $.console && $.console.warn && c && ia.test(c.name) && $.console.warn("jQuery.Deferred exception: " + c.message, c.stack, g)
    }
    ,
    m.readyException = function(c) {
        $.setTimeout(function() {
            throw c
        })
    }
    ;
    var aa = m.Deferred();
    function Ai() {
        D.removeEventListener("DOMContentLoaded", Ai),
        $.removeEventListener("load", Ai),
        m.ready()
    }
    m.fn.ready = function(c) {
        return aa.then(c).catch(function(g) {
            m.readyException(g)
        }),
        this
    }
    ,
    m.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(c) {
            (!0 === c ? --m.readyWait : m.isReady) || (m.isReady = !0) !== c && 0 < --m.readyWait || aa.resolveWith(D, [m])
        }
    }),
    m.ready.then = aa.then,
    "complete" === D.readyState || "loading" !== D.readyState && !D.documentElement.doScroll ? $.setTimeout(m.ready) : (D.addEventListener("DOMContentLoaded", Ai),
    $.addEventListener("load", Ai));
    var ni = function(c, g, y, A, T, L, O) {
        var W = 0
          , N = c.length
          , ee = null == y;
        if ("object" === U(y))
            for (W in T = !0,
            y)
                ni(c, g, W, y[W], !0, L, O);
        else if (void 0 !== A && (T = !0,
        Y(A) || (O = !0),
        ee && (O ? (g.call(c, A),
        g = null) : (ee = g,
        g = function(le, ge, se) {
            return ee.call(m(le), se)
        }
        )),
        g))
            for (; W < N; W++)
                g(c[W], y, O ? A : A.call(c[W], W, g(c[W], y)));
        return T ? c : ee ? g.call(c) : N ? g(c[0], y) : L
    }
      , fi = /^-ms-/
      , _i = /-([a-z])/g;
    function pi(c, g) {
        return g.toUpperCase()
    }
    function Gt(c) {
        return c.replace(fi, "ms-").replace(_i, pi)
    }
    var Bi = function(c) {
        return 1 === c.nodeType || 9 === c.nodeType || !+c.nodeType
    };
    function ji() {
        this.expando = m.expando + ji.uid++
    }
    ji.uid = 1,
    ji.prototype = {
        cache: function(c) {
            var g = c[this.expando];
            return g || (g = {},
            Bi(c) && (c.nodeType ? c[this.expando] = g : Object.defineProperty(c, this.expando, {
                value: g,
                configurable: !0
            }))),
            g
        },
        set: function(c, g, y) {
            var A, T = this.cache(c);
            if ("string" == typeof g)
                T[Gt(g)] = y;
            else
                for (A in g)
                    T[Gt(A)] = g[A];
            return T
        },
        get: function(c, g) {
            return void 0 === g ? this.cache(c) : c[this.expando] && c[this.expando][Gt(g)]
        },
        access: function(c, g, y) {
            return void 0 === g || g && "string" == typeof g && void 0 === y ? this.get(c, g) : (this.set(c, g, y),
            void 0 !== y ? y : g)
        },
        remove: function(c, g) {
            var y, A = c[this.expando];
            if (void 0 !== A) {
                if (void 0 !== g)
                    for ((y = (g = Array.isArray(g) ? g.map(Gt) : (g = Gt(g))in A ? [g] : g.match(Ot) || []).length); y--; )
                        delete A[g[y]];
                (void 0 === g || m.isEmptyObject(A)) && (c.nodeType ? c[this.expando] = void 0 : delete c[this.expando])
            }
        },
        hasData: function(c) {
            var g = c[this.expando];
            return void 0 !== g && !m.isEmptyObject(g)
        }
    };
    var Ge = new ji
      , Wt = new ji
      , Gi = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
      , Ki = /[A-Z]/g;
    function ci(c, g, y) {
        var A, T;
        if (void 0 === y && 1 === c.nodeType)
            if (A = "data-" + g.replace(Ki, "-$&").toLowerCase(),
            "string" == typeof (y = c.getAttribute(A))) {
                try {
                    y = "true" === (T = y) || "false" !== T && ("null" === T ? null : T === +T + "" ? +T : Gi.test(T) ? JSON.parse(T) : T)
                } catch {}
                Wt.set(c, g, y)
            } else
                y = void 0;
        return y
    }
    m.extend({
        hasData: function(c) {
            return Wt.hasData(c) || Ge.hasData(c)
        },
        data: function(c, g, y) {
            return Wt.access(c, g, y)
        },
        removeData: function(c, g) {
            Wt.remove(c, g)
        },
        _data: function(c, g, y) {
            return Ge.access(c, g, y)
        },
        _removeData: function(c, g) {
            Ge.remove(c, g)
        }
    }),
    m.fn.extend({
        data: function(c, g) {
            var y, A, T, L = this[0], O = L && L.attributes;
            if (void 0 === c) {
                if (this.length && (T = Wt.get(L),
                1 === L.nodeType && !Ge.get(L, "hasDataAttrs"))) {
                    for (y = O.length; y--; )
                        O[y] && 0 === (A = O[y].name).indexOf("data-") && (A = Gt(A.slice(5)),
                        ci(L, A, T[A]));
                    Ge.set(L, "hasDataAttrs", !0)
                }
                return T
            }
            return "object" == typeof c ? this.each(function() {
                Wt.set(this, c)
            }) : ni(this, function(W) {
                var N;
                if (L && void 0 === W)
                    return void 0 !== (N = Wt.get(L, c)) || void 0 !== (N = ci(L, c)) ? N : void 0;
                this.each(function() {
                    Wt.set(this, c, W)
                })
            }, null, g, 1 < arguments.length, null, !0)
        },
        removeData: function(c) {
            return this.each(function() {
                Wt.remove(this, c)
            })
        }
    }),
    m.extend({
        queue: function(c, g, y) {
            var A;
            if (c)
                return A = Ge.get(c, g = (g || "fx") + "queue"),
                y && (!A || Array.isArray(y) ? A = Ge.access(c, g, m.makeArray(y)) : A.push(y)),
                A || []
        },
        dequeue: function(c, g) {
            var y = m.queue(c, g = g || "fx")
              , A = y.length
              , T = y.shift()
              , L = m._queueHooks(c, g);
            "inprogress" === T && (T = y.shift(),
            A--),
            T && ("fx" === g && y.unshift("inprogress"),
            delete L.stop,
            T.call(c, function() {
                m.dequeue(c, g)
            }, L)),
            !A && L && L.empty.fire()
        },
        _queueHooks: function(c, g) {
            var y = g + "queueHooks";
            return Ge.get(c, y) || Ge.access(c, y, {
                empty: m.Callbacks("once memory").add(function() {
                    Ge.remove(c, [g + "queue", y])
                })
            })
        }
    }),
    m.fn.extend({
        queue: function(c, g) {
            var y = 2;
            return "string" != typeof c && (g = c,
            c = "fx",
            y--),
            arguments.length < y ? m.queue(this[0], c) : void 0 === g ? this : this.each(function() {
                var A = m.queue(this, c, g);
                m._queueHooks(this, c),
                "fx" === c && "inprogress" !== A[0] && m.dequeue(this, c)
            })
        },
        dequeue: function(c) {
            return this.each(function() {
                m.dequeue(this, c)
            })
        },
        clearQueue: function(c) {
            return this.queue(c || "fx", [])
        },
        promise: function(c, g) {
            var y, A = 1, T = m.Deferred(), L = this, O = this.length, W = function() {
                --A || T.resolveWith(L, [L])
            };
            for ("string" != typeof c && (g = c,
            c = void 0),
            c = c || "fx"; O--; )
                (y = Ge.get(L[O], c + "queueHooks")) && y.empty && (A++,
                y.empty.add(W));
            return W(),
            T.promise(g)
        }
    });
    var mi = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
      , Pt = new RegExp("^(?:([+-])=|)(" + mi + ")([a-z%]*)$","i")
      , Bt = ["Top", "Right", "Bottom", "Left"]
      , Qt = D.documentElement
      , ei = function(c) {
        return m.contains(c.ownerDocument, c)
    }
      , sa = {
        composed: !0
    };
    Qt.getRootNode && (ei = function(c) {
        return m.contains(c.ownerDocument, c) || c.getRootNode(sa) === c.ownerDocument
    }
    );
    var xi = function(c, g) {
        return "none" === (c = g || c).style.display || "" === c.style.display && ei(c) && "none" === m.css(c, "display")
    };
    function I(c, g, y, A) {
        var T, L, O = 20, W = A ? function() {
            return A.cur()
        }
        : function() {
            return m.css(c, g, "")
        }
        , N = W(), ee = y && y[3] || (m.cssNumber[g] ? "" : "px"), le = c.nodeType && (m.cssNumber[g] || "px" !== ee && +N) && Pt.exec(m.css(c, g));
        if (le && le[3] !== ee) {
            for (ee = ee || le[3],
            le = +(N /= 2) || 1; O--; )
                m.style(c, g, le + ee),
                (1 - L) * (1 - (L = W() / N || .5)) <= 0 && (O = 0),
                le /= L;
            m.style(c, g, (le *= 2) + ee),
            y = y || []
        }
        return y && (le = +le || +N || 0,
        T = y[1] ? le + (y[1] + 1) * y[2] : +y[2],
        A && (A.unit = ee,
        A.start = le,
        A.end = T)),
        T
    }
    var X = {};
    function q(c, g) {
        for (var y, A, T, L, O, W, N, ee = [], le = 0, ge = c.length; le < ge; le++)
            (A = c[le]).style && (y = A.style.display,
            g ? ("none" === y && (ee[le] = Ge.get(A, "display") || null,
            ee[le] || (A.style.display = "")),
            "" === A.style.display && xi(A) && (ee[le] = (N = O = L = void 0,
            O = (T = A).ownerDocument,
            (N = X[W = T.nodeName]) || (L = O.body.appendChild(O.createElement(W)),
            N = m.css(L, "display"),
            L.parentNode.removeChild(L),
            "none" === N && (N = "block"),
            X[W] = N)))) : "none" !== y && (ee[le] = "none",
            Ge.set(A, "display", y)));
        for (le = 0; le < ge; le++)
            null != ee[le] && (c[le].style.display = ee[le]);
        return c
    }
    m.fn.extend({
        show: function() {
            return q(this, !0)
        },
        hide: function() {
            return q(this)
        },
        toggle: function(c) {
            return "boolean" == typeof c ? c ? this.show() : this.hide() : this.each(function() {
                xi(this) ? m(this).show() : m(this).hide()
            })
        }
    });
    var te, xe, ve = /^(?:checkbox|radio)$/i, fe = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, Le = /^$|^module$|\/(?:java|ecma)script/i;
    te = D.createDocumentFragment().appendChild(D.createElement("div")),
    (xe = D.createElement("input")).setAttribute("type", "radio"),
    xe.setAttribute("checked", "checked"),
    xe.setAttribute("name", "t"),
    te.appendChild(xe),
    J.checkClone = te.cloneNode(!0).cloneNode(!0).lastChild.checked,
    te.innerHTML = "<textarea>x</textarea>",
    J.noCloneChecked = !!te.cloneNode(!0).lastChild.defaultValue,
    te.innerHTML = "<option></option>",
    J.option = !!te.lastChild;
    var Pe = {
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    };
    function Fe(c, g) {
        var y;
        return y = typeof c.getElementsByTagName < "u" ? c.getElementsByTagName(g || "*") : typeof c.querySelectorAll < "u" ? c.querySelectorAll(g || "*") : [],
        void 0 === g || g && qe(c, g) ? m.merge([c], y) : y
    }
    function Qe(c, g) {
        for (var y = 0, A = c.length; y < A; y++)
            Ge.set(c[y], "globalEval", !g || Ge.get(g[y], "globalEval"))
    }
    Pe.tbody = Pe.tfoot = Pe.colgroup = Pe.caption = Pe.thead,
    Pe.th = Pe.td,
    J.option || (Pe.optgroup = Pe.option = [1, "<select multiple='multiple'>", "</select>"]);
    var Ye = /<|&#?\w+;/;
    function Ue(c, g, y, A, T) {
        for (var L, O, W, N, ee, le, ge = g.createDocumentFragment(), se = [], ke = 0, Ze = c.length; ke < Ze; ke++)
            if ((L = c[ke]) || 0 === L)
                if ("object" === U(L))
                    m.merge(se, L.nodeType ? [L] : L);
                else if (Ye.test(L)) {
                    for (O = O || ge.appendChild(g.createElement("div")),
                    W = (fe.exec(L) || ["", ""])[1].toLowerCase(),
                    O.innerHTML = (N = Pe[W] || Pe._default)[1] + m.htmlPrefilter(L) + N[2],
                    le = N[0]; le--; )
                        O = O.lastChild;
                    m.merge(se, O.childNodes),
                    (O = ge.firstChild).textContent = ""
                } else
                    se.push(g.createTextNode(L));
        for (ge.textContent = "",
        ke = 0; L = se[ke++]; )
            if (A && -1 < m.inArray(L, A))
                T && T.push(L);
            else if (ee = ei(L),
            O = Fe(ge.appendChild(L), "script"),
            ee && Qe(O),
            y)
                for (le = 0; L = O[le++]; )
                    Le.test(L.type || "") && y.push(L);
        return ge
    }
    var st = /^([^.]*)(?:\.(.+)|)/;
    function tt() {
        return !0
    }
    function Tt() {
        return !1
    }
    function ti(c, g, y, A, T, L) {
        var O, W;
        if ("object" == typeof g) {
            for (W in "string" != typeof y && (A = A || y,
            y = void 0),
            g)
                ti(c, W, y, A, g[W], L);
            return c
        }
        if (null == A && null == T ? (T = y,
        A = y = void 0) : null == T && ("string" == typeof y ? (T = A,
        A = void 0) : (T = A,
        A = y,
        y = void 0)),
        !1 === T)
            T = Tt;
        else if (!T)
            return c;
        return 1 === L && (O = T,
        (T = function(N) {
            return m().off(N),
            O.apply(this, arguments)
        }
        ).guid = O.guid || (O.guid = m.guid++)),
        c.each(function() {
            m.event.add(this, g, T, A, y)
        })
    }
    function hi(c, g, y) {
        y ? (Ge.set(c, g, !1),
        m.event.add(c, g, {
            namespace: !1,
            handler: function(A) {
                var T, L = Ge.get(this, g);
                if (1 & A.isTrigger && this[g]) {
                    if (L)
                        (m.event.special[g] || {}).delegateType && A.stopPropagation();
                    else if (L = we.call(arguments),
                    Ge.set(this, g, L),
                    this[g](),
                    T = Ge.get(this, g),
                    Ge.set(this, g, !1),
                    L !== T)
                        return A.stopImmediatePropagation(),
                        A.preventDefault(),
                        T
                } else
                    L && (Ge.set(this, g, m.event.trigger(L[0], L.slice(1), this)),
                    A.stopPropagation(),
                    A.isImmediatePropagationStopped = tt)
            }
        })) : void 0 === Ge.get(c, g) && m.event.add(c, g, tt)
    }
    m.event = {
        global: {},
        add: function(c, g, y, A, T) {
            var L, O, W, N, ee, le, ge, se, ke, Ze, it, at = Ge.get(c);
            if (Bi(c))
                for (y.handler && (y = (L = y).handler,
                T = L.selector),
                T && m.find.matchesSelector(Qt, T),
                y.guid || (y.guid = m.guid++),
                (N = at.events) || (N = at.events = Object.create(null)),
                (O = at.handle) || (O = at.handle = function(Nt) {
                    return typeof m < "u" && m.event.triggered !== Nt.type ? m.event.dispatch.apply(c, arguments) : void 0
                }
                ),
                ee = (g = (g || "").match(Ot) || [""]).length; ee--; )
                    ke = it = (W = st.exec(g[ee]) || [])[1],
                    Ze = (W[2] || "").split(".").sort(),
                    ke && (ge = m.event.special[ke] || {},
                    ge = m.event.special[ke = (T ? ge.delegateType : ge.bindType) || ke] || {},
                    le = m.extend({
                        type: ke,
                        origType: it,
                        data: A,
                        handler: y,
                        guid: y.guid,
                        selector: T,
                        needsContext: T && m.expr.match.needsContext.test(T),
                        namespace: Ze.join(".")
                    }, L),
                    (se = N[ke]) || ((se = N[ke] = []).delegateCount = 0,
                    ge.setup && !1 !== ge.setup.call(c, A, Ze, O) || c.addEventListener && c.addEventListener(ke, O)),
                    ge.add && (ge.add.call(c, le),
                    le.handler.guid || (le.handler.guid = y.guid)),
                    T ? se.splice(se.delegateCount++, 0, le) : se.push(le),
                    m.event.global[ke] = !0)
        },
        remove: function(c, g, y, A, T) {
            var L, O, W, N, ee, le, ge, se, ke, Ze, it, at = Ge.hasData(c) && Ge.get(c);
            if (at && (N = at.events)) {
                for (ee = (g = (g || "").match(Ot) || [""]).length; ee--; )
                    if (ke = it = (W = st.exec(g[ee]) || [])[1],
                    Ze = (W[2] || "").split(".").sort(),
                    ke) {
                        for (ge = m.event.special[ke] || {},
                        se = N[ke = (A ? ge.delegateType : ge.bindType) || ke] || [],
                        W = W[2] && new RegExp("(^|\\.)" + Ze.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                        O = L = se.length; L--; )
                            le = se[L],
                            !T && it !== le.origType || y && y.guid !== le.guid || W && !W.test(le.namespace) || A && A !== le.selector && ("**" !== A || !le.selector) || (se.splice(L, 1),
                            le.selector && se.delegateCount--,
                            ge.remove && ge.remove.call(c, le));
                        O && !se.length && (ge.teardown && !1 !== ge.teardown.call(c, Ze, at.handle) || m.removeEvent(c, ke, at.handle),
                        delete N[ke])
                    } else
                        for (ke in N)
                            m.event.remove(c, ke + g[ee], y, A, !0);
                m.isEmptyObject(N) && Ge.remove(c, "handle events")
            }
        },
        dispatch: function(c) {
            var g, y, A, T, L, O, W = new Array(arguments.length), N = m.event.fix(c), ee = (Ge.get(this, "events") || Object.create(null))[N.type] || [], le = m.event.special[N.type] || {};
            for (W[0] = N,
            g = 1; g < arguments.length; g++)
                W[g] = arguments[g];
            if (N.delegateTarget = this,
            !le.preDispatch || !1 !== le.preDispatch.call(this, N)) {
                for (O = m.event.handlers.call(this, N, ee),
                g = 0; (T = O[g++]) && !N.isPropagationStopped(); )
                    for (N.currentTarget = T.elem,
                    y = 0; (L = T.handlers[y++]) && !N.isImmediatePropagationStopped(); )
                        N.rnamespace && !1 !== L.namespace && !N.rnamespace.test(L.namespace) || (N.handleObj = L,
                        N.data = L.data,
                        void 0 !== (A = ((m.event.special[L.origType] || {}).handle || L.handler).apply(T.elem, W)) && !1 === (N.result = A) && (N.preventDefault(),
                        N.stopPropagation()));
                return le.postDispatch && le.postDispatch.call(this, N),
                N.result
            }
        },
        handlers: function(c, g) {
            var y, A, T, L, O, W = [], N = g.delegateCount, ee = c.target;
            if (N && ee.nodeType && !("click" === c.type && 1 <= c.button))
                for (; ee !== this; ee = ee.parentNode || this)
                    if (1 === ee.nodeType && ("click" !== c.type || !0 !== ee.disabled)) {
                        for (L = [],
                        O = {},
                        y = 0; y < N; y++)
                            void 0 === O[T = (A = g[y]).selector + " "] && (O[T] = A.needsContext ? -1 < m(T, this).index(ee) : m.find(T, this, null, [ee]).length),
                            O[T] && L.push(A);
                        L.length && W.push({
                            elem: ee,
                            handlers: L
                        })
                    }
            return ee = this,
            N < g.length && W.push({
                elem: ee,
                handlers: g.slice(N)
            }),
            W
        },
        addProp: function(c, g) {
            Object.defineProperty(m.Event.prototype, c, {
                enumerable: !0,
                configurable: !0,
                get: Y(g) ? function() {
                    if (this.originalEvent)
                        return g(this.originalEvent)
                }
                : function() {
                    if (this.originalEvent)
                        return this.originalEvent[c]
                }
                ,
                set: function(y) {
                    Object.defineProperty(this, c, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: y
                    })
                }
            })
        },
        fix: function(c) {
            return c[m.expando] ? c : new m.Event(c)
        },
        special: {
            load: {
                noBubble: !0
            },
            click: {
                setup: function(c) {
                    var g = this || c;
                    return ve.test(g.type) && g.click && qe(g, "input") && hi(g, "click", !0),
                    !1
                },
                trigger: function(c) {
                    var g = this || c;
                    return ve.test(g.type) && g.click && qe(g, "input") && hi(g, "click"),
                    !0
                },
                _default: function(c) {
                    var g = c.target;
                    return ve.test(g.type) && g.click && qe(g, "input") && Ge.get(g, "click") || qe(g, "a")
                }
            },
            beforeunload: {
                postDispatch: function(c) {
                    void 0 !== c.result && c.originalEvent && (c.originalEvent.returnValue = c.result)
                }
            }
        }
    },
    m.removeEvent = function(c, g, y) {
        c.removeEventListener && c.removeEventListener(g, y)
    }
    ,
    m.Event = function(c, g) {
        if (!(this instanceof m.Event))
            return new m.Event(c,g);
        c && c.type ? (this.originalEvent = c,
        this.type = c.type,
        this.isDefaultPrevented = c.defaultPrevented || void 0 === c.defaultPrevented && !1 === c.returnValue ? tt : Tt,
        this.target = c.target && 3 === c.target.nodeType ? c.target.parentNode : c.target,
        this.currentTarget = c.currentTarget,
        this.relatedTarget = c.relatedTarget) : this.type = c,
        g && m.extend(this, g),
        this.timeStamp = c && c.timeStamp || Date.now(),
        this[m.expando] = !0
    }
    ,
    m.Event.prototype = {
        constructor: m.Event,
        isDefaultPrevented: Tt,
        isPropagationStopped: Tt,
        isImmediatePropagationStopped: Tt,
        isSimulated: !1,
        preventDefault: function() {
            var c = this.originalEvent;
            this.isDefaultPrevented = tt,
            c && !this.isSimulated && c.preventDefault()
        },
        stopPropagation: function() {
            var c = this.originalEvent;
            this.isPropagationStopped = tt,
            c && !this.isSimulated && c.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var c = this.originalEvent;
            this.isImmediatePropagationStopped = tt,
            c && !this.isSimulated && c.stopImmediatePropagation(),
            this.stopPropagation()
        }
    },
    m.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: !0
    }, m.event.addProp),
    m.each({
        focus: "focusin",
        blur: "focusout"
    }, function(c, g) {
        function y(A) {
            if (D.documentMode) {
                var T = Ge.get(this, "handle")
                  , L = m.event.fix(A);
                L.type = "focusin" === A.type ? "focus" : "blur",
                L.isSimulated = !0,
                T(A),
                L.target === L.currentTarget && T(L)
            } else
                m.event.simulate(g, A.target, m.event.fix(A))
        }
        m.event.special[c] = {
            setup: function() {
                var A;
                if (hi(this, c, !0),
                !D.documentMode)
                    return !1;
                (A = Ge.get(this, g)) || this.addEventListener(g, y),
                Ge.set(this, g, (A || 0) + 1)
            },
            trigger: function() {
                return hi(this, c),
                !0
            },
            teardown: function() {
                var A;
                if (!D.documentMode)
                    return !1;
                (A = Ge.get(this, g) - 1) ? Ge.set(this, g, A) : (this.removeEventListener(g, y),
                Ge.remove(this, g))
            },
            _default: function(A) {
                return Ge.get(A.target, c)
            },
            delegateType: g
        },
        m.event.special[g] = {
            setup: function() {
                var A = this.ownerDocument || this.document || this
                  , T = D.documentMode ? this : A
                  , L = Ge.get(T, g);
                L || (D.documentMode ? this.addEventListener(g, y) : A.addEventListener(c, y, !0)),
                Ge.set(T, g, (L || 0) + 1)
            },
            teardown: function() {
                var A = this.ownerDocument || this.document || this
                  , T = D.documentMode ? this : A
                  , L = Ge.get(T, g) - 1;
                L ? Ge.set(T, g, L) : (D.documentMode ? this.removeEventListener(g, y) : A.removeEventListener(c, y, !0),
                Ge.remove(T, g))
            }
        }
    }),
    m.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(c, g) {
        m.event.special[c] = {
            delegateType: g,
            bindType: g,
            handle: function(y) {
                var A, T = y.relatedTarget, L = y.handleObj;
                return T && (T === this || m.contains(this, T)) || (y.type = L.origType,
                A = L.handler.apply(this, arguments),
                y.type = g),
                A
            }
        }
    }),
    m.fn.extend({
        on: function(c, g, y, A) {
            return ti(this, c, g, y, A)
        },
        one: function(c, g, y, A) {
            return ti(this, c, g, y, A, 1)
        },
        off: function(c, g, y) {
            var A, T;
            if (c && c.preventDefault && c.handleObj)
                return A = c.handleObj,
                m(c.delegateTarget).off(A.namespace ? A.origType + "." + A.namespace : A.origType, A.selector, A.handler),
                this;
            if ("object" == typeof c) {
                for (T in c)
                    this.off(T, g, c[T]);
                return this
            }
            return !1 !== g && "function" != typeof g || (y = g,
            g = void 0),
            !1 === y && (y = Tt),
            this.each(function() {
                m.event.remove(this, c, y, g)
            })
        }
    });
    var Vt = /<script|<style|<link/i
      , vi = /checked\s*(?:[^=]|=\s*.checked.)/i
      , bi = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function yi(c, g) {
        return qe(c, "table") && qe(11 !== g.nodeType ? g : g.firstChild, "tr") && m(c).children("tbody")[0] || c
    }
    function Ji(c) {
        return c.type = (null !== c.getAttribute("type")) + "/" + c.type,
        c
    }
    function la(c) {
        return "true/" === (c.type || "").slice(0, 5) ? c.type = c.type.slice(5) : c.removeAttribute("type"),
        c
    }
    function ba(c, g) {
        var y, A, T, L, O, W;
        if (1 === g.nodeType) {
            if (Ge.hasData(c) && (W = Ge.get(c).events))
                for (T in Ge.remove(g, "handle events"),
                W)
                    for (y = 0,
                    A = W[T].length; y < A; y++)
                        m.event.add(g, T, W[T][y]);
            Wt.hasData(c) && (L = Wt.access(c),
            O = m.extend({}, L),
            Wt.set(g, O))
        }
    }
    function Ri(c, g, y, A) {
        g = Te(g);
        var T, L, O, W, N, ee, le = 0, ge = c.length, se = ge - 1, ke = g[0], Ze = Y(ke);
        if (Ze || 1 < ge && "string" == typeof ke && !J.checkClone && vi.test(ke))
            return c.each(function(it) {
                var at = c.eq(it);
                Ze && (g[0] = ke.call(this, it, at.html())),
                Ri(at, g, y, A)
            });
        if (ge && (L = (T = Ue(g, c[0].ownerDocument, !1, c, A)).firstChild,
        1 === T.childNodes.length && (T = L),
        L || A)) {
            for (W = (O = m.map(Fe(T, "script"), Ji)).length; le < ge; le++)
                N = T,
                le !== se && (N = m.clone(N, !0, !0),
                W && m.merge(O, Fe(N, "script"))),
                y.call(c[le], N, le);
            if (W)
                for (ee = O[O.length - 1].ownerDocument,
                m.map(O, la),
                le = 0; le < W; le++)
                    Le.test((N = O[le]).type || "") && !Ge.access(N, "globalEval") && m.contains(ee, N) && (N.src && "module" !== (N.type || "").toLowerCase() ? m._evalUrl && !N.noModule && m._evalUrl(N.src, {
                        nonce: N.nonce || N.getAttribute("nonce")
                    }, ee) : _e(N.textContent.replace(bi, ""), N, ee))
        }
        return c
    }
    function ya(c, g, y) {
        for (var A, T = g ? m.filter(g, c) : c, L = 0; null != (A = T[L]); L++)
            y || 1 !== A.nodeType || m.cleanData(Fe(A)),
            A.parentNode && (y && ei(A) && Qe(Fe(A, "script")),
            A.parentNode.removeChild(A));
        return c
    }
    m.extend({
        htmlPrefilter: function(c) {
            return c
        },
        clone: function(c, g, y) {
            var A, T, L, O, W, N, ee, le = c.cloneNode(!0), ge = ei(c);
            if (!(J.noCloneChecked || 1 !== c.nodeType && 11 !== c.nodeType || m.isXMLDoc(c)))
                for (O = Fe(le),
                A = 0,
                T = (L = Fe(c)).length; A < T; A++)
                    W = L[A],
                    "input" === (ee = (N = O[A]).nodeName.toLowerCase()) && ve.test(W.type) ? N.checked = W.checked : "input" !== ee && "textarea" !== ee || (N.defaultValue = W.defaultValue);
            if (g)
                if (y)
                    for (L = L || Fe(c),
                    O = O || Fe(le),
                    A = 0,
                    T = L.length; A < T; A++)
                        ba(L[A], O[A]);
                else
                    ba(c, le);
            return 0 < (O = Fe(le, "script")).length && Qe(O, !ge && Fe(c, "script")),
            le
        },
        cleanData: function(c) {
            for (var g, y, A, T = m.event.special, L = 0; void 0 !== (y = c[L]); L++)
                if (Bi(y)) {
                    if (g = y[Ge.expando]) {
                        if (g.events)
                            for (A in g.events)
                                T[A] ? m.event.remove(y, A) : m.removeEvent(y, A, g.handle);
                        y[Ge.expando] = void 0
                    }
                    y[Wt.expando] && (y[Wt.expando] = void 0)
                }
        }
    }),
    m.fn.extend({
        detach: function(c) {
            return ya(this, c, !0)
        },
        remove: function(c) {
            return ya(this, c)
        },
        text: function(c) {
            return ni(this, function(g) {
                return void 0 === g ? m.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = g)
                })
            }, null, c, arguments.length)
        },
        append: function() {
            return Ri(this, arguments, function(c) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || yi(this, c).appendChild(c)
            })
        },
        prepend: function() {
            return Ri(this, arguments, function(c) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var g = yi(this, c);
                    g.insertBefore(c, g.firstChild)
                }
            })
        },
        before: function() {
            return Ri(this, arguments, function(c) {
                this.parentNode && this.parentNode.insertBefore(c, this)
            })
        },
        after: function() {
            return Ri(this, arguments, function(c) {
                this.parentNode && this.parentNode.insertBefore(c, this.nextSibling)
            })
        },
        empty: function() {
            for (var c, g = 0; null != (c = this[g]); g++)
                1 === c.nodeType && (m.cleanData(Fe(c, !1)),
                c.textContent = "");
            return this
        },
        clone: function(c, g) {
            return c = null != c && c,
            g = g ?? c,
            this.map(function() {
                return m.clone(this, c, g)
            })
        },
        html: function(c) {
            return ni(this, function(g) {
                var y = this[0] || {}
                  , A = 0
                  , T = this.length;
                if (void 0 === g && 1 === y.nodeType)
                    return y.innerHTML;
                if ("string" == typeof g && !Vt.test(g) && !Pe[(fe.exec(g) || ["", ""])[1].toLowerCase()]) {
                    g = m.htmlPrefilter(g);
                    try {
                        for (; A < T; A++)
                            1 === (y = this[A] || {}).nodeType && (m.cleanData(Fe(y, !1)),
                            y.innerHTML = g);
                        y = 0
                    } catch {}
                }
                y && this.empty().append(g)
            }, null, c, arguments.length)
        },
        replaceWith: function() {
            var c = [];
            return Ri(this, arguments, function(g) {
                var y = this.parentNode;
                m.inArray(this, c) < 0 && (m.cleanData(Fe(this)),
                y && y.replaceChild(g, this))
            }, c)
        }
    }),
    m.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(c, g) {
        m.fn[c] = function(y) {
            for (var A, T = [], L = m(y), O = L.length - 1, W = 0; W <= O; W++)
                A = W === O ? this : this.clone(!0),
                m(L[W])[g](A),
                Re.apply(T, A.get());
            return this.pushStack(T)
        }
    });
    var ca = new RegExp("^(" + mi + ")(?!px)[a-z%]+$","i")
      , Ei = /^--/
      , Vi = function(c) {
        var g = c.ownerDocument.defaultView;
        return g && g.opener || (g = $),
        g.getComputedStyle(c)
    }
      , Oi = function(c, g, y) {
        var A, T, L = {};
        for (T in g)
            L[T] = c.style[T],
            c.style[T] = g[T];
        for (T in A = y.call(c),
        g)
            c.style[T] = L[T];
        return A
    }
      , C = new RegExp(Bt.join("|"),"i");
    function e(c, g, y) {
        var A, T, L, O, W = Ei.test(g), N = c.style;
        return (y = y || Vi(c)) && (O = y.getPropertyValue(g) || y[g],
        W && O && (O = O.replace(At, "$1") || void 0),
        "" !== O || ei(c) || (O = m.style(c, g)),
        !J.pixelBoxStyles() && ca.test(O) && C.test(g) && (A = N.width,
        T = N.minWidth,
        L = N.maxWidth,
        N.minWidth = N.maxWidth = N.width = O,
        O = y.width,
        N.width = A,
        N.minWidth = T,
        N.maxWidth = L)),
        void 0 !== O ? O + "" : O
    }
    function t(c, g) {
        return {
            get: function() {
                if (!c())
                    return (this.get = g).apply(this, arguments);
                delete this.get
            }
        }
    }
    !function() {
        function c() {
            if (ee) {
                N.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                ee.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                Qt.appendChild(N).appendChild(ee);
                var le = $.getComputedStyle(ee);
                y = "1%" !== le.top,
                W = 12 === g(le.marginLeft),
                ee.style.right = "60%",
                L = 36 === g(le.right),
                A = 36 === g(le.width),
                ee.style.position = "absolute",
                T = 12 === g(ee.offsetWidth / 3),
                Qt.removeChild(N),
                ee = null
            }
        }
        function g(le) {
            return Math.round(parseFloat(le))
        }
        var y, A, T, L, O, W, N = D.createElement("div"), ee = D.createElement("div");
        ee.style && (ee.style.backgroundClip = "content-box",
        ee.cloneNode(!0).style.backgroundClip = "",
        J.clearCloneStyle = "content-box" === ee.style.backgroundClip,
        m.extend(J, {
            boxSizingReliable: function() {
                return c(),
                A
            },
            pixelBoxStyles: function() {
                return c(),
                L
            },
            pixelPosition: function() {
                return c(),
                y
            },
            reliableMarginLeft: function() {
                return c(),
                W
            },
            scrollboxSize: function() {
                return c(),
                T
            },
            reliableTrDimensions: function() {
                var le, ge, se, ke;
                return null == O && (le = D.createElement("table"),
                ge = D.createElement("tr"),
                se = D.createElement("div"),
                le.style.cssText = "position:absolute;left:-11111px;border-collapse:separate",
                ge.style.cssText = "box-sizing:content-box;border:1px solid",
                ge.style.height = "1px",
                se.style.height = "9px",
                se.style.display = "block",
                Qt.appendChild(le).appendChild(ge).appendChild(se),
                ke = $.getComputedStyle(ge),
                O = parseInt(ke.height, 10) + parseInt(ke.borderTopWidth, 10) + parseInt(ke.borderBottomWidth, 10) === ge.offsetHeight,
                Qt.removeChild(le)),
                O
            }
        }))
    }();
    var i = ["Webkit", "Moz", "ms"]
      , a = D.createElement("div").style
      , s = {};
    function r(c) {
        return m.cssProps[c] || s[c] || (c in a ? c : s[c] = function(y) {
            for (var A = y[0].toUpperCase() + y.slice(1), T = i.length; T--; )
                if ((y = i[T] + A)in a)
                    return y
        }(c) || c)
    }
    var n = /^(none|table(?!-c[ea]).+)/
      , o = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }
      , h = {
        letterSpacing: "0",
        fontWeight: "400"
    };
    function d(c, g, y) {
        var A = Pt.exec(g);
        return A ? Math.max(0, A[2] - (y || 0)) + (A[3] || "px") : g
    }
    function u(c, g, y, A, T, L) {
        var O = "width" === g ? 1 : 0
          , W = 0
          , N = 0
          , ee = 0;
        if (y === (A ? "border" : "content"))
            return 0;
        for (; O < 4; O += 2)
            "margin" === y && (ee += m.css(c, y + Bt[O], !0, T)),
            A ? ("content" === y && (N -= m.css(c, "padding" + Bt[O], !0, T)),
            "margin" !== y && (N -= m.css(c, "border" + Bt[O] + "Width", !0, T))) : (N += m.css(c, "padding" + Bt[O], !0, T),
            "padding" !== y ? N += m.css(c, "border" + Bt[O] + "Width", !0, T) : W += m.css(c, "border" + Bt[O] + "Width", !0, T));
        return !A && 0 <= L && (N += Math.max(0, Math.ceil(c["offset" + g[0].toUpperCase() + g.slice(1)] - L - N - W - .5)) || 0),
        N + ee
    }
    function p(c, g, y) {
        var A = Vi(c)
          , T = (!J.boxSizingReliable() || y) && "border-box" === m.css(c, "boxSizing", !1, A)
          , L = T
          , O = e(c, g, A)
          , W = "offset" + g[0].toUpperCase() + g.slice(1);
        if (ca.test(O)) {
            if (!y)
                return O;
            O = "auto"
        }
        return (!J.boxSizingReliable() && T || !J.reliableTrDimensions() && qe(c, "tr") || "auto" === O || !parseFloat(O) && "inline" === m.css(c, "display", !1, A)) && c.getClientRects().length && (T = "border-box" === m.css(c, "boxSizing", !1, A),
        (L = W in c) && (O = c[W])),
        (O = parseFloat(O) || 0) + u(c, g, y || (T ? "border" : "content"), L, A, O) + "px"
    }
    function x(c, g, y, A, T) {
        return new x.prototype.init(c,g,y,A,T)
    }
    m.extend({
        cssHooks: {
            opacity: {
                get: function(c, g) {
                    if (g) {
                        var y = e(c, "opacity");
                        return "" === y ? "1" : y
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageSlice: !0,
            columnCount: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            gridArea: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnStart: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowStart: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            scale: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0
        },
        cssProps: {},
        style: function(c, g, y, A) {
            if (c && 3 !== c.nodeType && 8 !== c.nodeType && c.style) {
                var T, L, O, W = Gt(g), N = Ei.test(g), ee = c.style;
                if (N || (g = r(W)),
                O = m.cssHooks[g] || m.cssHooks[W],
                void 0 === y)
                    return O && "get"in O && void 0 !== (T = O.get(c, !1, A)) ? T : ee[g];
                "string" == (L = typeof y) && (T = Pt.exec(y)) && T[1] && (y = I(c, g, T),
                L = "number"),
                null != y && y == y && ("number" !== L || N || (y += T && T[3] || (m.cssNumber[W] ? "" : "px")),
                J.clearCloneStyle || "" !== y || 0 !== g.indexOf("background") || (ee[g] = "inherit"),
                O && "set"in O && void 0 === (y = O.set(c, y, A)) || (N ? ee.setProperty(g, y) : ee[g] = y))
            }
        },
        css: function(c, g, y, A) {
            var T, L, O, W = Gt(g);
            return Ei.test(g) || (g = r(W)),
            (O = m.cssHooks[g] || m.cssHooks[W]) && "get"in O && (T = O.get(c, !0, y)),
            void 0 === T && (T = e(c, g, A)),
            "normal" === T && g in h && (T = h[g]),
            "" === y || y ? (L = parseFloat(T),
            !0 === y || isFinite(L) ? L || 0 : T) : T
        }
    }),
    m.each(["height", "width"], function(c, g) {
        m.cssHooks[g] = {
            get: function(y, A, T) {
                if (A)
                    return !n.test(m.css(y, "display")) || y.getClientRects().length && y.getBoundingClientRect().width ? p(y, g, T) : Oi(y, o, function() {
                        return p(y, g, T)
                    })
            },
            set: function(y, A, T) {
                var L, O = Vi(y), W = !J.scrollboxSize() && "absolute" === O.position, N = (W || T) && "border-box" === m.css(y, "boxSizing", !1, O), ee = T ? u(y, g, T, N, O) : 0;
                return N && W && (ee -= Math.ceil(y["offset" + g[0].toUpperCase() + g.slice(1)] - parseFloat(O[g]) - u(y, g, "border", !1, O) - .5)),
                ee && (L = Pt.exec(A)) && "px" !== (L[3] || "px") && (y.style[g] = A,
                A = m.css(y, g)),
                d(0, A, ee)
            }
        }
    }),
    m.cssHooks.marginLeft = t(J.reliableMarginLeft, function(c, g) {
        if (g)
            return (parseFloat(e(c, "marginLeft")) || c.getBoundingClientRect().left - Oi(c, {
                marginLeft: 0
            }, function() {
                return c.getBoundingClientRect().left
            })) + "px"
    }),
    m.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(c, g) {
        m.cssHooks[c + g] = {
            expand: function(y) {
                for (var A = 0, T = {}, L = "string" == typeof y ? y.split(" ") : [y]; A < 4; A++)
                    T[c + Bt[A] + g] = L[A] || L[A - 2] || L[0];
                return T
            }
        },
        "margin" !== c && (m.cssHooks[c + g].set = d)
    }),
    m.fn.extend({
        css: function(c, g) {
            return ni(this, function(y, A, T) {
                var L, O, W = {}, N = 0;
                if (Array.isArray(A)) {
                    for (L = Vi(y),
                    O = A.length; N < O; N++)
                        W[A[N]] = m.css(y, A[N], !1, L);
                    return W
                }
                return void 0 !== T ? m.style(y, A, T) : m.css(y, A)
            }, c, g, 1 < arguments.length)
        }
    }),
    ((m.Tween = x).prototype = {
        constructor: x,
        init: function(c, g, y, A, T, L) {
            this.elem = c,
            this.prop = y,
            this.easing = T || m.easing._default,
            this.options = g,
            this.start = this.now = this.cur(),
            this.end = A,
            this.unit = L || (m.cssNumber[y] ? "" : "px")
        },
        cur: function() {
            var c = x.propHooks[this.prop];
            return c && c.get ? c.get(this) : x.propHooks._default.get(this)
        },
        run: function(c) {
            var g, y = x.propHooks[this.prop];
            return this.pos = g = this.options.duration ? m.easing[this.easing](c, this.options.duration * c, 0, 1, this.options.duration) : c,
            this.now = (this.end - this.start) * g + this.start,
            this.options.step && this.options.step.call(this.elem, this.now, this),
            y && y.set ? y.set(this) : x.propHooks._default.set(this),
            this
        }
    }).init.prototype = x.prototype,
    (x.propHooks = {
        _default: {
            get: function(c) {
                var g;
                return 1 !== c.elem.nodeType || null != c.elem[c.prop] && null == c.elem.style[c.prop] ? c.elem[c.prop] : (g = m.css(c.elem, c.prop, "")) && "auto" !== g ? g : 0
            },
            set: function(c) {
                m.fx.step[c.prop] ? m.fx.step[c.prop](c) : 1 !== c.elem.nodeType || !m.cssHooks[c.prop] && null == c.elem.style[r(c.prop)] ? c.elem[c.prop] = c.now : m.style(c.elem, c.prop, c.now + c.unit)
            }
        }
    }).scrollTop = x.propHooks.scrollLeft = {
        set: function(c) {
            c.elem.nodeType && c.elem.parentNode && (c.elem[c.prop] = c.now)
        }
    },
    m.easing = {
        linear: function(c) {
            return c
        },
        swing: function(c) {
            return .5 - Math.cos(c * Math.PI) / 2
        },
        _default: "swing"
    },
    m.fx = x.prototype.init,
    m.fx.step = {};
    var b, k, S, E, M = /^(?:toggle|show|hide)$/, l = /queueHooks$/;
    function f() {
        k && (!1 === D.hidden && $.requestAnimationFrame ? $.requestAnimationFrame(f) : $.setTimeout(f, m.fx.interval),
        m.fx.tick())
    }
    function w() {
        return $.setTimeout(function() {
            b = void 0
        }),
        b = Date.now()
    }
    function _(c, g) {
        var y, A = 0, T = {
            height: c
        };
        for (g = g ? 1 : 0; A < 4; A += 2 - g)
            T["margin" + (y = Bt[A])] = T["padding" + y] = c;
        return g && (T.opacity = T.width = c),
        T
    }
    function R(c, g, y) {
        for (var A, T = (H.tweeners[g] || []).concat(H.tweeners["*"]), L = 0, O = T.length; L < O; L++)
            if (A = T[L].call(y, g, c))
                return A
    }
    function H(c, g, y) {
        var A, T, L = 0, O = H.prefilters.length, W = m.Deferred().always(function() {
            delete N.elem
        }), N = function() {
            if (T)
                return !1;
            for (var ge = b || w(), se = Math.max(0, ee.startTime + ee.duration - ge), ke = 1 - (se / ee.duration || 0), Ze = 0, it = ee.tweens.length; Ze < it; Ze++)
                ee.tweens[Ze].run(ke);
            return W.notifyWith(c, [ee, ke, se]),
            ke < 1 && it ? se : (it || W.notifyWith(c, [ee, 1, 0]),
            W.resolveWith(c, [ee]),
            !1)
        }, ee = W.promise({
            elem: c,
            props: m.extend({}, g),
            opts: m.extend(!0, {
                specialEasing: {},
                easing: m.easing._default
            }, y),
            originalProperties: g,
            originalOptions: y,
            startTime: b || w(),
            duration: y.duration,
            tweens: [],
            createTween: function(ge, se) {
                var ke = m.Tween(c, ee.opts, ge, se, ee.opts.specialEasing[ge] || ee.opts.easing);
                return ee.tweens.push(ke),
                ke
            },
            stop: function(ge) {
                var se = 0
                  , ke = ge ? ee.tweens.length : 0;
                if (T)
                    return this;
                for (T = !0; se < ke; se++)
                    ee.tweens[se].run(1);
                return ge ? (W.notifyWith(c, [ee, 1, 0]),
                W.resolveWith(c, [ee, ge])) : W.rejectWith(c, [ee, ge]),
                this
            }
        }), le = ee.props;
        for (function(ge, se) {
            var ke, Ze, it, at, Nt;
            for (ke in ge)
                if (it = se[Ze = Gt(ke)],
                at = ge[ke],
                Array.isArray(at) && (it = at[1],
                at = ge[ke] = at[0]),
                ke !== Ze && (ge[Ze] = at,
                delete ge[ke]),
                (Nt = m.cssHooks[Ze]) && "expand"in Nt)
                    for (ke in at = Nt.expand(at),
                    delete ge[Ze],
                    at)
                        ke in ge || (ge[ke] = at[ke],
                        se[ke] = it);
                else
                    se[Ze] = it
        }(le, ee.opts.specialEasing); L < O; L++)
            if (A = H.prefilters[L].call(ee, c, le, ee.opts))
                return Y(A.stop) && (m._queueHooks(ee.elem, ee.opts.queue).stop = A.stop.bind(A)),
                A;
        return m.map(le, R, ee),
        Y(ee.opts.start) && ee.opts.start.call(c, ee),
        ee.progress(ee.opts.progress).done(ee.opts.done, ee.opts.complete).fail(ee.opts.fail).always(ee.opts.always),
        m.fx.timer(m.extend(N, {
            elem: c,
            anim: ee,
            queue: ee.opts.queue
        })),
        ee
    }
    m.Animation = m.extend(H, {
        tweeners: {
            "*": [function(c, g) {
                var y = this.createTween(c, g);
                return I(y.elem, c, Pt.exec(g), y),
                y
            }
            ]
        },
        tweener: function(c, g) {
            Y(c) ? (g = c,
            c = ["*"]) : c = c.match(Ot);
            for (var y, A = 0, T = c.length; A < T; A++)
                (H.tweeners[y = c[A]] = H.tweeners[y] || []).unshift(g)
        },
        prefilters: [function(c, g, y) {
            var A, T, L, O, W, N, ee, le, ge = "width"in g || "height"in g, se = this, ke = {}, Ze = c.style, it = c.nodeType && xi(c), at = Ge.get(c, "fxshow");
            for (A in y.queue || (null == (O = m._queueHooks(c, "fx")).unqueued && (O.unqueued = 0,
            W = O.empty.fire,
            O.empty.fire = function() {
                O.unqueued || W()
            }
            ),
            O.unqueued++,
            se.always(function() {
                se.always(function() {
                    O.unqueued--,
                    m.queue(c, "fx").length || O.empty.fire()
                })
            })),
            g)
                if (M.test(T = g[A])) {
                    if (delete g[A],
                    L = L || "toggle" === T,
                    T === (it ? "hide" : "show")) {
                        if ("show" !== T || !at || void 0 === at[A])
                            continue;
                        it = !0
                    }
                    ke[A] = at && at[A] || m.style(c, A)
                }
            if ((N = !m.isEmptyObject(g)) || !m.isEmptyObject(ke))
                for (A in ge && 1 === c.nodeType && (y.overflow = [Ze.overflow, Ze.overflowX, Ze.overflowY],
                null == (ee = at && at.display) && (ee = Ge.get(c, "display")),
                "none" === (le = m.css(c, "display")) && (ee ? le = ee : (q([c], !0),
                ee = c.style.display || ee,
                le = m.css(c, "display"),
                q([c]))),
                ("inline" === le || "inline-block" === le && null != ee) && "none" === m.css(c, "float") && (N || (se.done(function() {
                    Ze.display = ee
                }),
                null == ee && (ee = "none" === (le = Ze.display) ? "" : le)),
                Ze.display = "inline-block")),
                y.overflow && (Ze.overflow = "hidden",
                se.always(function() {
                    Ze.overflow = y.overflow[0],
                    Ze.overflowX = y.overflow[1],
                    Ze.overflowY = y.overflow[2]
                })),
                N = !1,
                ke)
                    N || (at ? "hidden"in at && (it = at.hidden) : at = Ge.access(c, "fxshow", {
                        display: ee
                    }),
                    L && (at.hidden = !it),
                    it && q([c], !0),
                    se.done(function() {
                        for (A in it || q([c]),
                        Ge.remove(c, "fxshow"),
                        ke)
                            m.style(c, A, ke[A])
                    })),
                    N = R(it ? at[A] : 0, A, se),
                    A in at || (at[A] = N.start,
                    it && (N.end = N.start,
                    N.start = 0))
        }
        ],
        prefilter: function(c, g) {
            g ? H.prefilters.unshift(c) : H.prefilters.push(c)
        }
    }),
    m.speed = function(c, g, y) {
        var A = c && "object" == typeof c ? m.extend({}, c) : {
            complete: y || !y && g || Y(c) && c,
            duration: c,
            easing: y && g || g && !Y(g) && g
        };
        return m.fx.off ? A.duration = 0 : "number" != typeof A.duration && (A.duration = A.duration in m.fx.speeds ? m.fx.speeds[A.duration] : m.fx.speeds._default),
        null != A.queue && !0 !== A.queue || (A.queue = "fx"),
        A.old = A.complete,
        A.complete = function() {
            Y(A.old) && A.old.call(this),
            A.queue && m.dequeue(this, A.queue)
        }
        ,
        A
    }
    ,
    m.fn.extend({
        fadeTo: function(c, g, y, A) {
            return this.filter(xi).css("opacity", 0).show().end().animate({
                opacity: g
            }, c, y, A)
        },
        animate: function(c, g, y, A) {
            var T = m.isEmptyObject(c)
              , L = m.speed(g, y, A)
              , O = function() {
                var W = H(this, m.extend({}, c), L);
                (T || Ge.get(this, "finish")) && W.stop(!0)
            };
            return O.finish = O,
            T || !1 === L.queue ? this.each(O) : this.queue(L.queue, O)
        },
        stop: function(c, g, y) {
            var A = function(T) {
                var L = T.stop;
                delete T.stop,
                L(y)
            };
            return "string" != typeof c && (y = g,
            g = c,
            c = void 0),
            g && this.queue(c || "fx", []),
            this.each(function() {
                var T = !0
                  , L = null != c && c + "queueHooks"
                  , O = m.timers
                  , W = Ge.get(this);
                if (L)
                    W[L] && W[L].stop && A(W[L]);
                else
                    for (L in W)
                        W[L] && W[L].stop && l.test(L) && A(W[L]);
                for (L = O.length; L--; )
                    O[L].elem !== this || null != c && O[L].queue !== c || (O[L].anim.stop(y),
                    T = !1,
                    O.splice(L, 1));
                !T && y || m.dequeue(this, c)
            })
        },
        finish: function(c) {
            return !1 !== c && (c = c || "fx"),
            this.each(function() {
                var g, y = Ge.get(this), A = y[c + "queue"], T = y[c + "queueHooks"], L = m.timers, O = A ? A.length : 0;
                for (y.finish = !0,
                m.queue(this, c, []),
                T && T.stop && T.stop.call(this, !0),
                g = L.length; g--; )
                    L[g].elem === this && L[g].queue === c && (L[g].anim.stop(!0),
                    L.splice(g, 1));
                for (g = 0; g < O; g++)
                    A[g] && A[g].finish && A[g].finish.call(this);
                delete y.finish
            })
        }
    }),
    m.each(["toggle", "show", "hide"], function(c, g) {
        var y = m.fn[g];
        m.fn[g] = function(A, T, L) {
            return null == A || "boolean" == typeof A ? y.apply(this, arguments) : this.animate(_(g, !0), A, T, L)
        }
    }),
    m.each({
        slideDown: _("show"),
        slideUp: _("hide"),
        slideToggle: _("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(c, g) {
        m.fn[c] = function(y, A, T) {
            return this.animate(g, y, A, T)
        }
    }),
    m.timers = [],
    m.fx.tick = function() {
        var c, g = 0, y = m.timers;
        for (b = Date.now(); g < y.length; g++)
            (c = y[g])() || y[g] !== c || y.splice(g--, 1);
        y.length || m.fx.stop(),
        b = void 0
    }
    ,
    m.fx.timer = function(c) {
        m.timers.push(c),
        m.fx.start()
    }
    ,
    m.fx.interval = 13,
    m.fx.start = function() {
        k || (k = !0,
        f())
    }
    ,
    m.fx.stop = function() {
        k = null
    }
    ,
    m.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    },
    m.fn.delay = function(c, g) {
        return c = m.fx && m.fx.speeds[c] || c,
        this.queue(g = g || "fx", function(y, A) {
            var T = $.setTimeout(y, c);
            A.stop = function() {
                $.clearTimeout(T)
            }
        })
    }
    ,
    S = D.createElement("input"),
    E = D.createElement("select").appendChild(D.createElement("option")),
    S.type = "checkbox",
    J.checkOn = "" !== S.value,
    J.optSelected = E.selected,
    (S = D.createElement("input")).value = "t",
    S.type = "radio",
    J.radioValue = "t" === S.value;
    var B, j = m.expr.attrHandle;
    m.fn.extend({
        attr: function(c, g) {
            return ni(this, m.attr, c, g, 1 < arguments.length)
        },
        removeAttr: function(c) {
            return this.each(function() {
                m.removeAttr(this, c)
            })
        }
    }),
    m.extend({
        attr: function(c, g, y) {
            var A, T, L = c.nodeType;
            if (3 !== L && 8 !== L && 2 !== L)
                return typeof c.getAttribute > "u" ? m.prop(c, g, y) : (1 === L && m.isXMLDoc(c) || (T = m.attrHooks[g.toLowerCase()] || (m.expr.match.bool.test(g) ? B : void 0)),
                void 0 !== y ? null === y ? void m.removeAttr(c, g) : T && "set"in T && void 0 !== (A = T.set(c, y, g)) ? A : (c.setAttribute(g, y + ""),
                y) : T && "get"in T && null !== (A = T.get(c, g)) ? A : null == (A = m.find.attr(c, g)) ? void 0 : A)
        },
        attrHooks: {
            type: {
                set: function(c, g) {
                    if (!J.radioValue && "radio" === g && qe(c, "input")) {
                        var y = c.value;
                        return c.setAttribute("type", g),
                        y && (c.value = y),
                        g
                    }
                }
            }
        },
        removeAttr: function(c, g) {
            var y, A = 0, T = g && g.match(Ot);
            if (T && 1 === c.nodeType)
                for (; y = T[A++]; )
                    c.removeAttribute(y)
        }
    }),
    B = {
        set: function(c, g, y) {
            return !1 === g ? m.removeAttr(c, y) : c.setAttribute(y, y),
            y
        }
    },
    m.each(m.expr.match.bool.source.match(/\w+/g), function(c, g) {
        var y = j[g] || m.find.attr;
        j[g] = function(A, T, L) {
            var O, W, N = T.toLowerCase();
            return L || (W = j[N],
            j[N] = O,
            O = null != y(A, T, L) ? N : null,
            j[N] = W),
            O
        }
    });
    var ce = /^(?:input|select|textarea|button)$/i
      , me = /^(?:a|area)$/i;
    function ue(c) {
        return (c.match(Ot) || []).join(" ")
    }
    function Ee(c) {
        return c.getAttribute && c.getAttribute("class") || ""
    }
    function Ie(c) {
        return Array.isArray(c) ? c : "string" == typeof c && c.match(Ot) || []
    }
    m.fn.extend({
        prop: function(c, g) {
            return ni(this, m.prop, c, g, 1 < arguments.length)
        },
        removeProp: function(c) {
            return this.each(function() {
                delete this[m.propFix[c] || c]
            })
        }
    }),
    m.extend({
        prop: function(c, g, y) {
            var A, T, L = c.nodeType;
            if (3 !== L && 8 !== L && 2 !== L)
                return 1 === L && m.isXMLDoc(c) || (T = m.propHooks[g = m.propFix[g] || g]),
                void 0 !== y ? T && "set"in T && void 0 !== (A = T.set(c, y, g)) ? A : c[g] = y : T && "get"in T && null !== (A = T.get(c, g)) ? A : c[g]
        },
        propHooks: {
            tabIndex: {
                get: function(c) {
                    var g = m.find.attr(c, "tabindex");
                    return g ? parseInt(g, 10) : ce.test(c.nodeName) || me.test(c.nodeName) && c.href ? 0 : -1
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }),
    J.optSelected || (m.propHooks.selected = {
        get: function(c) {
            return null
        },
        set: function(c) {}
    }),
    m.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        m.propFix[this.toLowerCase()] = this
    }),
    m.fn.extend({
        addClass: function(c) {
            var g, y, A, T, L, O;
            return Y(c) ? this.each(function(W) {
                m(this).addClass(c.call(this, W, Ee(this)))
            }) : (g = Ie(c)).length ? this.each(function() {
                if (A = Ee(this),
                y = 1 === this.nodeType && " " + ue(A) + " ") {
                    for (L = 0; L < g.length; L++)
                        y.indexOf(" " + (T = g[L]) + " ") < 0 && (y += T + " ");
                    O = ue(y),
                    A !== O && this.setAttribute("class", O)
                }
            }) : this
        },
        removeClass: function(c) {
            var g, y, A, T, L, O;
            return Y(c) ? this.each(function(W) {
                m(this).removeClass(c.call(this, W, Ee(this)))
            }) : arguments.length ? (g = Ie(c)).length ? this.each(function() {
                if (A = Ee(this),
                y = 1 === this.nodeType && " " + ue(A) + " ") {
                    for (L = 0; L < g.length; L++)
                        for (T = g[L]; -1 < y.indexOf(" " + T + " "); )
                            y = y.replace(" " + T + " ", " ");
                    O = ue(y),
                    A !== O && this.setAttribute("class", O)
                }
            }) : this : this.attr("class", "")
        },
        toggleClass: function(c, g) {
            var y, A, T, L, O = typeof c, W = "string" === O || Array.isArray(c);
            return Y(c) ? this.each(function(N) {
                m(this).toggleClass(c.call(this, N, Ee(this), g), g)
            }) : "boolean" == typeof g && W ? g ? this.addClass(c) : this.removeClass(c) : (y = Ie(c),
            this.each(function() {
                if (W)
                    for (L = m(this),
                    T = 0; T < y.length; T++)
                        L.hasClass(A = y[T]) ? L.removeClass(A) : L.addClass(A);
                else
                    void 0 !== c && "boolean" !== O || ((A = Ee(this)) && Ge.set(this, "__className__", A),
                    this.setAttribute && this.setAttribute("class", A || !1 === c ? "" : Ge.get(this, "__className__") || ""))
            }))
        },
        hasClass: function(c) {
            var g, y, A = 0;
            for (g = " " + c + " "; y = this[A++]; )
                if (1 === y.nodeType && -1 < (" " + ue(Ee(y)) + " ").indexOf(g))
                    return !0;
            return !1
        }
    });
    var rt = /\r/g;
    m.fn.extend({
        val: function(c) {
            var g, y, A, T = this[0];
            return arguments.length ? (A = Y(c),
            this.each(function(L) {
                var O;
                1 === this.nodeType && (null == (O = A ? c.call(this, L, m(this).val()) : c) ? O = "" : "number" == typeof O ? O += "" : Array.isArray(O) && (O = m.map(O, function(W) {
                    return null == W ? "" : W + ""
                })),
                (g = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()]) && "set"in g && void 0 !== g.set(this, O, "value") || (this.value = O))
            })) : T ? (g = m.valHooks[T.type] || m.valHooks[T.nodeName.toLowerCase()]) && "get"in g && void 0 !== (y = g.get(T, "value")) ? y : "string" == typeof (y = T.value) ? y.replace(rt, "") : y ?? "" : void 0
        }
    }),
    m.extend({
        valHooks: {
            option: {
                get: function(c) {
                    return m.find.attr(c, "value") ?? ue(m.text(c))
                }
            },
            select: {
                get: function(c) {
                    var g, y, A, T = c.options, L = c.selectedIndex, O = "select-one" === c.type, W = O ? null : [], N = O ? L + 1 : T.length;
                    for (A = L < 0 ? N : O ? L : 0; A < N; A++)
                        if (((y = T[A]).selected || A === L) && !y.disabled && (!y.parentNode.disabled || !qe(y.parentNode, "optgroup"))) {
                            if (g = m(y).val(),
                            O)
                                return g;
                            W.push(g)
                        }
                    return W
                },
                set: function(c, g) {
                    for (var y, A, T = c.options, L = m.makeArray(g), O = T.length; O--; )
                        ((A = T[O]).selected = -1 < m.inArray(m.valHooks.option.get(A), L)) && (y = !0);
                    return y || (c.selectedIndex = -1),
                    L
                }
            }
        }
    }),
    m.each(["radio", "checkbox"], function() {
        m.valHooks[this] = {
            set: function(c, g) {
                if (Array.isArray(g))
                    return c.checked = -1 < m.inArray(m(c).val(), g)
            }
        },
        J.checkOn || (m.valHooks[this].get = function(c) {
            return null === c.getAttribute("value") ? "on" : c.value
        }
        )
    });
    var nt = $.location
      , ht = {
        guid: Date.now()
    }
      , vt = /\?/;
    m.parseXML = function(c) {
        var g, y;
        if (!c || "string" != typeof c)
            return null;
        try {
            g = (new $.DOMParser).parseFromString(c, "text/xml")
        } catch {}
        return y = g && g.getElementsByTagName("parsererror")[0],
        g && !y || m.error("Invalid XML: " + (y ? m.map(y.childNodes, function(A) {
            return A.textContent
        }).join("\n") : c)),
        g
    }
    ;
    var mt = /^(?:focusinfocus|focusoutblur)$/
      , _t = function(c) {
        c.stopPropagation()
    };
    m.extend(m.event, {
        trigger: function(c, g, y, A) {
            var T, L, O, W, N, ee, le, ge, se = [y || D], ke = De.call(c, "type") ? c.type : c, Ze = De.call(c, "namespace") ? c.namespace.split(".") : [];
            if (L = ge = O = y = y || D,
            3 !== y.nodeType && 8 !== y.nodeType && !mt.test(ke + m.event.triggered) && (-1 < ke.indexOf(".") && (ke = (Ze = ke.split(".")).shift(),
            Ze.sort()),
            N = ke.indexOf(":") < 0 && "on" + ke,
            (c = c[m.expando] ? c : new m.Event(ke,"object" == typeof c && c)).isTrigger = A ? 2 : 3,
            c.namespace = Ze.join("."),
            c.rnamespace = c.namespace ? new RegExp("(^|\\.)" + Ze.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
            c.result = void 0,
            c.target || (c.target = y),
            g = null == g ? [c] : m.makeArray(g, [c]),
            le = m.event.special[ke] || {},
            A || !le.trigger || !1 !== le.trigger.apply(y, g))) {
                if (!A && !le.noBubble && !ne(y)) {
                    for (mt.test((W = le.delegateType || ke) + ke) || (L = L.parentNode); L; L = L.parentNode)
                        se.push(L),
                        O = L;
                    O === (y.ownerDocument || D) && se.push(O.defaultView || O.parentWindow || $)
                }
                for (T = 0; (L = se[T++]) && !c.isPropagationStopped(); )
                    ge = L,
                    c.type = 1 < T ? W : le.bindType || ke,
                    (ee = (Ge.get(L, "events") || Object.create(null))[c.type] && Ge.get(L, "handle")) && ee.apply(L, g),
                    (ee = N && L[N]) && ee.apply && Bi(L) && (c.result = ee.apply(L, g),
                    !1 === c.result && c.preventDefault());
                return c.type = ke,
                A || c.isDefaultPrevented() || le._default && !1 !== le._default.apply(se.pop(), g) || !Bi(y) || N && Y(y[ke]) && !ne(y) && ((O = y[N]) && (y[N] = null),
                m.event.triggered = ke,
                c.isPropagationStopped() && ge.addEventListener(ke, _t),
                y[ke](),
                c.isPropagationStopped() && ge.removeEventListener(ke, _t),
                m.event.triggered = void 0,
                O && (y[N] = O)),
                c.result
            }
        },
        simulate: function(c, g, y) {
            var A = m.extend(new m.Event, y, {
                type: c,
                isSimulated: !0
            });
            m.event.trigger(A, null, g)
        }
    }),
    m.fn.extend({
        trigger: function(c, g) {
            return this.each(function() {
                m.event.trigger(c, g, this)
            })
        },
        triggerHandler: function(c, g) {
            var y = this[0];
            if (y)
                return m.event.trigger(c, g, y, !0)
        }
    });
    var ii = /\[\]$/
      , Li = /\r?\n/g
      , ra = /^(?:submit|button|image|reset|file)$/i
      , ai = /^(?:input|select|textarea|keygen)/i;
    function qt(c, g, y, A) {
        var T;
        if (Array.isArray(g))
            m.each(g, function(L, O) {
                y || ii.test(c) ? A(c, O) : qt(c + "[" + ("object" == typeof O && null != O ? L : "") + "]", O, y, A)
            });
        else if (y || "object" !== U(g))
            A(c, g);
        else
            for (T in g)
                qt(c + "[" + T + "]", g[T], y, A)
    }
    m.param = function(c, g) {
        var y, A = [], T = function(L, O) {
            var W = Y(O) ? O() : O;
            A[A.length] = encodeURIComponent(L) + "=" + encodeURIComponent(W ?? "")
        };
        if (null == c)
            return "";
        if (Array.isArray(c) || c.jquery && !m.isPlainObject(c))
            m.each(c, function() {
                T(this.name, this.value)
            });
        else
            for (y in c)
                qt(y, c[y], g, T);
        return A.join("&")
    }
    ,
    m.fn.extend({
        serialize: function() {
            return m.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var c = m.prop(this, "elements");
                return c ? m.makeArray(c) : this
            }).filter(function() {
                var c = this.type;
                return this.name && !m(this).is(":disabled") && ai.test(this.nodeName) && !ra.test(c) && (this.checked || !ve.test(c))
            }).map(function(c, g) {
                var y = m(this).val();
                return null == y ? null : Array.isArray(y) ? m.map(y, function(A) {
                    return {
                        name: g.name,
                        value: A.replace(Li, "\r\n")
                    }
                }) : {
                    name: g.name,
                    value: y.replace(Li, "\r\n")
                }
            }).get()
        }
    });
    var Ut = /%20/g
      , ga = /#.*$/
      , Na = /([?&])_=[^&]*/
      , qa = /^(.*?):[ \t]*([^\r\n]*)$/gm
      , Ua = /^(?:GET|HEAD)$/
      , Za = /^\/\//
      , Xa = {}
      , Pa = {}
      , Ya = "*/".concat("*")
      , wa = D.createElement("a");
    function Ia(c) {
        return function(g, y) {
            "string" != typeof g && (y = g,
            g = "*");
            var A, T = 0, L = g.toLowerCase().match(Ot) || [];
            if (Y(y))
                for (; A = L[T++]; )
                    "+" === A[0] ? (A = A.slice(1) || "*",
                    (c[A] = c[A] || []).unshift(y)) : (c[A] = c[A] || []).push(y)
        }
    }
    function ka(c, g, y, A) {
        var T = {}
          , L = c === Pa;
        function O(W) {
            var N;
            return T[W] = !0,
            m.each(c[W] || [], function(ee, le) {
                var ge = le(g, y, A);
                return "string" != typeof ge || L || T[ge] ? L ? !(N = ge) : void 0 : (g.dataTypes.unshift(ge),
                O(ge),
                !1)
            }),
            N
        }
        return O(g.dataTypes[0]) || !T["*"] && O("*")
    }
    function Ma(c, g) {
        var y, A, T = m.ajaxSettings.flatOptions || {};
        for (y in g)
            void 0 !== g[y] && ((T[y] ? c : A || (A = {}))[y] = g[y]);
        return A && m.extend(!0, c, A),
        c
    }
    wa.href = nt.href,
    m.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: nt.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(nt.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Ya,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": m.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(c, g) {
            return g ? Ma(Ma(c, m.ajaxSettings), g) : Ma(m.ajaxSettings, c)
        },
        ajaxPrefilter: Ia(Xa),
        ajaxTransport: Ia(Pa),
        ajax: function(c, g) {
            "object" == typeof c && (g = c,
            c = void 0);
            var y, A, T, L, O, W, N, ee, le, ge, se = m.ajaxSetup({}, g = g || {}), ke = se.context || se, Ze = se.context && (ke.nodeType || ke.jquery) ? m(ke) : m.event, it = m.Deferred(), at = m.Callbacks("once memory"), Nt = se.statusCode || {}, Zt = {}, zi = {}, Fi = "canceled", lt = {
                readyState: 0,
                getResponseHeader: function(dt) {
                    var Dt;
                    if (N) {
                        if (!L)
                            for (L = {}; Dt = qa.exec(T); )
                                L[Dt[1].toLowerCase() + " "] = (L[Dt[1].toLowerCase() + " "] || []).concat(Dt[2]);
                        Dt = L[dt.toLowerCase() + " "]
                    }
                    return null == Dt ? null : Dt.join(", ")
                },
                getAllResponseHeaders: function() {
                    return N ? T : null
                },
                setRequestHeader: function(dt, Dt) {
                    return null == N && (dt = zi[dt.toLowerCase()] = zi[dt.toLowerCase()] || dt,
                    Zt[dt] = Dt),
                    this
                },
                overrideMimeType: function(dt) {
                    return null == N && (se.mimeType = dt),
                    this
                },
                statusCode: function(dt) {
                    var Dt;
                    if (dt)
                        if (N)
                            lt.always(dt[lt.status]);
                        else
                            for (Dt in dt)
                                Nt[Dt] = [Nt[Dt], dt[Dt]];
                    return this
                },
                abort: function(dt) {
                    var Dt = dt || Fi;
                    return y && y.abort(Dt),
                    Ni(0, Dt),
                    this
                }
            };
            if (it.promise(lt),
            se.url = ((c || se.url || nt.href) + "").replace(Za, nt.protocol + "//"),
            se.type = g.method || g.type || se.method || se.type,
            se.dataTypes = (se.dataType || "*").toLowerCase().match(Ot) || [""],
            null == se.crossDomain) {
                W = D.createElement("a");
                try {
                    W.href = se.url,
                    W.href = W.href,
                    se.crossDomain = wa.protocol + "//" + wa.host != W.protocol + "//" + W.host
                } catch {
                    se.crossDomain = !0
                }
            }
            if (se.data && se.processData && "string" != typeof se.data && (se.data = m.param(se.data, se.traditional)),
            ka(Xa, se, g, lt),
            N)
                return lt;
            for (le in (ee = m.event && se.global) && 0 == m.active++ && m.event.trigger("ajaxStart"),
            se.type = se.type.toUpperCase(),
            se.hasContent = !Ua.test(se.type),
            A = se.url.replace(ga, ""),
            se.hasContent ? se.data && se.processData && 0 === (se.contentType || "").indexOf("application/x-www-form-urlencoded") && (se.data = se.data.replace(Ut, "+")) : (ge = se.url.slice(A.length),
            se.data && (se.processData || "string" == typeof se.data) && (A += (vt.test(A) ? "&" : "?") + se.data,
            delete se.data),
            !1 === se.cache && (A = A.replace(Na, "$1"),
            ge = (vt.test(A) ? "&" : "?") + "_=" + ht.guid++ + ge),
            se.url = A + ge),
            se.ifModified && (m.lastModified[A] && lt.setRequestHeader("If-Modified-Since", m.lastModified[A]),
            m.etag[A] && lt.setRequestHeader("If-None-Match", m.etag[A])),
            (se.data && se.hasContent && !1 !== se.contentType || g.contentType) && lt.setRequestHeader("Content-Type", se.contentType),
            lt.setRequestHeader("Accept", se.dataTypes[0] && se.accepts[se.dataTypes[0]] ? se.accepts[se.dataTypes[0]] + ("*" !== se.dataTypes[0] ? ", " + Ya + "; q=0.01" : "") : se.accepts["*"]),
            se.headers)
                lt.setRequestHeader(le, se.headers[le]);
            if (se.beforeSend && (!1 === se.beforeSend.call(ke, lt, se) || N))
                return lt.abort();
            if (Fi = "abort",
            at.add(se.complete),
            lt.done(se.success),
            lt.fail(se.error),
            y = ka(Pa, se, g, lt)) {
                if (lt.readyState = 1,
                ee && Ze.trigger("ajaxSend", [lt, se]),
                N)
                    return lt;
                se.async && 0 < se.timeout && (O = $.setTimeout(function() {
                    lt.abort("timeout")
                }, se.timeout));
                try {
                    N = !1,
                    y.send(Zt, Ni)
                } catch (dt) {
                    if (N)
                        throw dt;
                    Ni(-1, dt)
                }
            } else
                Ni(-1, "No Transport");
            function Ni(dt, Dt, qi, fa) {
                var Xi, pa, Ui, di, ha, Si = Dt;
                N || (N = !0,
                O && $.clearTimeout(O),
                y = void 0,
                T = fa || "",
                lt.readyState = 0 < dt ? 4 : 0,
                Xi = 200 <= dt && dt < 300 || 304 === dt,
                qi && (di = function(Xt, Ht, oi) {
                    for (var Zi, li, $e, Rt, zt = Xt.contents, Et = Xt.dataTypes; "*" === Et[0]; )
                        Et.shift(),
                        void 0 === Zi && (Zi = Xt.mimeType || Ht.getResponseHeader("Content-Type"));
                    if (Zi)
                        for (li in zt)
                            if (zt[li] && zt[li].test(Zi)) {
                                Et.unshift(li);
                                break
                            }
                    if (Et[0]in oi)
                        $e = Et[0];
                    else {
                        for (li in oi) {
                            if (!Et[0] || Xt.converters[li + " " + Et[0]]) {
                                $e = li;
                                break
                            }
                            Rt || (Rt = li)
                        }
                        $e = $e || Rt
                    }
                    if ($e)
                        return $e !== Et[0] && Et.unshift($e),
                        oi[$e]
                }(se, lt, qi)),
                !Xi && -1 < m.inArray("script", se.dataTypes) && m.inArray("json", se.dataTypes) < 0 && (se.converters["text script"] = function() {}
                ),
                di = function(Xt, Ht, oi, Zi) {
                    var li, $e, Rt, zt, Et, Yi = {}, da = Xt.dataTypes.slice();
                    if (da[1])
                        for (Rt in Xt.converters)
                            Yi[Rt.toLowerCase()] = Xt.converters[Rt];
                    for ($e = da.shift(); $e; )
                        if (Xt.responseFields[$e] && (oi[Xt.responseFields[$e]] = Ht),
                        !Et && Zi && Xt.dataFilter && (Ht = Xt.dataFilter(Ht, Xt.dataType)),
                        Et = $e,
                        $e = da.shift())
                            if ("*" === $e)
                                $e = Et;
                            else if ("*" !== Et && Et !== $e) {
                                if (!(Rt = Yi[Et + " " + $e] || Yi["* " + $e]))
                                    for (li in Yi)
                                        if ((zt = li.split(" "))[1] === $e && (Rt = Yi[Et + " " + zt[0]] || Yi["* " + zt[0]])) {
                                            !0 === Rt ? Rt = Yi[li] : !0 !== Yi[li] && ($e = zt[0],
                                            da.unshift(zt[1]));
                                            break
                                        }
                                if (!0 !== Rt)
                                    if (Rt && Xt.throws)
                                        Ht = Rt(Ht);
                                    else
                                        try {
                                            Ht = Rt(Ht)
                                        } catch (ea) {
                                            return {
                                                state: "parsererror",
                                                error: Rt ? ea : "No conversion from " + Et + " to " + $e
                                            }
                                        }
                            }
                    return {
                        state: "success",
                        data: Ht
                    }
                }(se, di, lt, Xi),
                Xi ? (se.ifModified && ((ha = lt.getResponseHeader("Last-Modified")) && (m.lastModified[A] = ha),
                (ha = lt.getResponseHeader("etag")) && (m.etag[A] = ha)),
                204 === dt || "HEAD" === se.type ? Si = "nocontent" : 304 === dt ? Si = "notmodified" : (Si = di.state,
                pa = di.data,
                Xi = !(Ui = di.error))) : (Ui = Si,
                !dt && Si || (Si = "error",
                dt < 0 && (dt = 0))),
                lt.status = dt,
                lt.statusText = (Dt || Si) + "",
                Xi ? it.resolveWith(ke, [pa, Si, lt]) : it.rejectWith(ke, [lt, Si, Ui]),
                lt.statusCode(Nt),
                Nt = void 0,
                ee && Ze.trigger(Xi ? "ajaxSuccess" : "ajaxError", [lt, se, Xi ? pa : Ui]),
                at.fireWith(ke, [lt, Si]),
                ee && (Ze.trigger("ajaxComplete", [lt, se]),
                --m.active || m.event.trigger("ajaxStop")))
            }
            return lt
        },
        getJSON: function(c, g, y) {
            return m.get(c, g, y, "json")
        },
        getScript: function(c, g) {
            return m.get(c, void 0, g, "script")
        }
    }),
    m.each(["get", "post"], function(c, g) {
        m[g] = function(y, A, T, L) {
            return Y(A) && (L = L || T,
            T = A,
            A = void 0),
            m.ajax(m.extend({
                url: y,
                type: g,
                dataType: L,
                data: A,
                success: T
            }, m.isPlainObject(y) && y))
        }
    }),
    m.ajaxPrefilter(function(c) {
        var g;
        for (g in c.headers)
            "content-type" === g.toLowerCase() && (c.contentType = c.headers[g] || "")
    }),
    m._evalUrl = function(c, g, y) {
        return m.ajax({
            url: c,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            converters: {
                "text script": function() {}
            },
            dataFilter: function(A) {
                m.globalEval(A, g, y)
            }
        })
    }
    ,
    m.fn.extend({
        wrapAll: function(c) {
            var g;
            return this[0] && (Y(c) && (c = c.call(this[0])),
            g = m(c, this[0].ownerDocument).eq(0).clone(!0),
            this[0].parentNode && g.insertBefore(this[0]),
            g.map(function() {
                for (var y = this; y.firstElementChild; )
                    y = y.firstElementChild;
                return y
            }).append(this)),
            this
        },
        wrapInner: function(c) {
            return Y(c) ? this.each(function(g) {
                m(this).wrapInner(c.call(this, g))
            }) : this.each(function() {
                var g = m(this)
                  , y = g.contents();
                y.length ? y.wrapAll(c) : g.append(c)
            })
        },
        wrap: function(c) {
            var g = Y(c);
            return this.each(function(y) {
                m(this).wrapAll(g ? c.call(this, y) : c)
            })
        },
        unwrap: function(c) {
            return this.parent(c).not("body").each(function() {
                m(this).replaceWith(this.childNodes)
            }),
            this
        }
    }),
    m.expr.pseudos.hidden = function(c) {
        return !m.expr.pseudos.visible(c)
    }
    ,
    m.expr.pseudos.visible = function(c) {
        return !!(c.offsetWidth || c.offsetHeight || c.getClientRects().length)
    }
    ,
    m.ajaxSettings.xhr = function() {
        try {
            return new $.XMLHttpRequest
        } catch {}
    }
    ;
    var $a = {
        0: 200,
        1223: 204
    }
      , Pi = m.ajaxSettings.xhr();
    J.cors = !!Pi && "withCredentials"in Pi,
    J.ajax = Pi = !!Pi,
    m.ajaxTransport(function(c) {
        var g, y;
        if (J.cors || Pi && !c.crossDomain)
            return {
                send: function(A, T) {
                    var L, O = c.xhr();
                    if (O.open(c.type, c.url, c.async, c.username, c.password),
                    c.xhrFields)
                        for (L in c.xhrFields)
                            O[L] = c.xhrFields[L];
                    for (L in c.mimeType && O.overrideMimeType && O.overrideMimeType(c.mimeType),
                    c.crossDomain || A["X-Requested-With"] || (A["X-Requested-With"] = "XMLHttpRequest"),
                    A)
                        O.setRequestHeader(L, A[L]);
                    g = function(W) {
                        return function() {
                            g && (g = y = O.onload = O.onerror = O.onabort = O.ontimeout = O.onreadystatechange = null,
                            "abort" === W ? O.abort() : "error" === W ? "number" != typeof O.status ? T(0, "error") : T(O.status, O.statusText) : T($a[O.status] || O.status, O.statusText, "text" !== (O.responseType || "text") || "string" != typeof O.responseText ? {
                                binary: O.response
                            } : {
                                text: O.responseText
                            }, O.getAllResponseHeaders()))
                        }
                    }
                    ,
                    O.onload = g(),
                    y = O.onerror = O.ontimeout = g("error"),
                    void 0 !== O.onabort ? O.onabort = y : O.onreadystatechange = function() {
                        4 === O.readyState && $.setTimeout(function() {
                            g && y()
                        })
                    }
                    ,
                    g = g("abort");
                    try {
                        O.send(c.hasContent && c.data || null)
                    } catch (W) {
                        if (g)
                            throw W
                    }
                },
                abort: function() {
                    g && g()
                }
            }
    }),
    m.ajaxPrefilter(function(c) {
        c.crossDomain && (c.contents.script = !1)
    }),
    m.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(c) {
                return m.globalEval(c),
                c
            }
        }
    }),
    m.ajaxPrefilter("script", function(c) {
        void 0 === c.cache && (c.cache = !1),
        c.crossDomain && (c.type = "GET")
    }),
    m.ajaxTransport("script", function(c) {
        var g, y;
        if (c.crossDomain || c.scriptAttrs)
            return {
                send: function(A, T) {
                    g = m("<script>").attr(c.scriptAttrs || {}).prop({
                        charset: c.scriptCharset,
                        src: c.url
                    }).on("load error", y = function(L) {
                        g.remove(),
                        y = null,
                        L && T("error" === L.type ? 404 : 200, L.type)
                    }
                    ),
                    D.head.appendChild(g[0])
                },
                abort: function() {
                    y && y()
                }
            }
    });
    var Hi, Da = [], Ra = /(=)\?(?=&|$)|\?\?/;
    m.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var c = Da.pop() || m.expando + "_" + ht.guid++;
            return this[c] = !0,
            c
        }
    }),
    m.ajaxPrefilter("json jsonp", function(c, g, y) {
        var A, T, L, O = !1 !== c.jsonp && (Ra.test(c.url) ? "url" : "string" == typeof c.data && 0 === (c.contentType || "").indexOf("application/x-www-form-urlencoded") && Ra.test(c.data) && "data");
        if (O || "jsonp" === c.dataTypes[0])
            return A = c.jsonpCallback = Y(c.jsonpCallback) ? c.jsonpCallback() : c.jsonpCallback,
            O ? c[O] = c[O].replace(Ra, "$1" + A) : !1 !== c.jsonp && (c.url += (vt.test(c.url) ? "&" : "?") + c.jsonp + "=" + A),
            c.converters["script json"] = function() {
                return L || m.error(A + " was not called"),
                L[0]
            }
            ,
            c.dataTypes[0] = "json",
            T = $[A],
            $[A] = function() {
                L = arguments
            }
            ,
            y.always(function() {
                void 0 === T ? m($).removeProp(A) : $[A] = T,
                c[A] && (c.jsonpCallback = g.jsonpCallback,
                Da.push(A)),
                L && Y(T) && T(L[0]),
                L = T = void 0
            }),
            "script"
    }),
    J.createHTMLDocument = ((Hi = D.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>",
    2 === Hi.childNodes.length),
    m.parseHTML = function(c, g, y) {
        return "string" != typeof c ? [] : ("boolean" == typeof g && (y = g,
        g = !1),
        g || (J.createHTMLDocument ? ((A = (g = D.implementation.createHTMLDocument("")).createElement("base")).href = D.location.href,
        g.head.appendChild(A)) : g = D),
        L = !y && [],
        (T = ye.exec(c)) ? [g.createElement(T[1])] : (T = Ue([c], g, L),
        L && L.length && m(L).remove(),
        m.merge([], T.childNodes)));
        var A, T, L
    }
    ,
    m.fn.load = function(c, g, y) {
        var A, T, L, O = this, W = c.indexOf(" ");
        return -1 < W && (A = ue(c.slice(W)),
        c = c.slice(0, W)),
        Y(g) ? (y = g,
        g = void 0) : g && "object" == typeof g && (T = "POST"),
        0 < O.length && m.ajax({
            url: c,
            type: T || "GET",
            dataType: "html",
            data: g
        }).done(function(N) {
            L = arguments,
            O.html(A ? m("<div>").append(m.parseHTML(N)).find(A) : N)
        }).always(y && function(N, ee) {
            O.each(function() {
                y.apply(this, L || [N.responseText, ee, N])
            })
        }
        ),
        this
    }
    ,
    m.expr.pseudos.animated = function(c) {
        return m.grep(m.timers, function(g) {
            return c === g.elem
        }).length
    }
    ,
    m.offset = {
        setOffset: function(c, g, y) {
            var A, T, L, O, W, N, ee = m.css(c, "position"), le = m(c), ge = {};
            "static" === ee && (c.style.position = "relative"),
            W = le.offset(),
            L = m.css(c, "top"),
            N = m.css(c, "left"),
            ("absolute" === ee || "fixed" === ee) && -1 < (L + N).indexOf("auto") ? (O = (A = le.position()).top,
            T = A.left) : (O = parseFloat(L) || 0,
            T = parseFloat(N) || 0),
            Y(g) && (g = g.call(c, y, m.extend({}, W))),
            null != g.top && (ge.top = g.top - W.top + O),
            null != g.left && (ge.left = g.left - W.left + T),
            "using"in g ? g.using.call(c, ge) : le.css(ge)
        }
    },
    m.fn.extend({
        offset: function(c) {
            if (arguments.length)
                return void 0 === c ? this : this.each(function(T) {
                    m.offset.setOffset(this, c, T)
                });
            var g, y, A = this[0];
            return A ? A.getClientRects().length ? {
                top: (g = A.getBoundingClientRect()).top + (y = A.ownerDocument.defaultView).pageYOffset,
                left: g.left + y.pageXOffset
            } : {
                top: 0,
                left: 0
            } : void 0
        },
        position: function() {
            if (this[0]) {
                var c, g, y, A = this[0], T = {
                    top: 0,
                    left: 0
                };
                if ("fixed" === m.css(A, "position"))
                    g = A.getBoundingClientRect();
                else {
                    for (g = this.offset(),
                    y = A.ownerDocument,
                    c = A.offsetParent || y.documentElement; c && (c === y.body || c === y.documentElement) && "static" === m.css(c, "position"); )
                        c = c.parentNode;
                    c && c !== A && 1 === c.nodeType && ((T = m(c).offset()).top += m.css(c, "borderTopWidth", !0),
                    T.left += m.css(c, "borderLeftWidth", !0))
                }
                return {
                    top: g.top - T.top - m.css(A, "marginTop", !0),
                    left: g.left - T.left - m.css(A, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var c = this.offsetParent; c && "static" === m.css(c, "position"); )
                    c = c.offsetParent;
                return c || Qt
            })
        }
    }),
    m.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(c, g) {
        var y = "pageYOffset" === g;
        m.fn[c] = function(A) {
            return ni(this, function(T, L, O) {
                var W;
                if (ne(T) ? W = T : 9 === T.nodeType && (W = T.defaultView),
                void 0 === O)
                    return W ? W[g] : T[L];
                W ? W.scrollTo(y ? W.pageXOffset : O, y ? O : W.pageYOffset) : T[L] = O
            }, c, A, arguments.length)
        }
    }),
    m.each(["top", "left"], function(c, g) {
        m.cssHooks[g] = t(J.pixelPosition, function(y, A) {
            if (A)
                return A = e(y, g),
                ca.test(A) ? m(y).position()[g] + "px" : A
        })
    }),
    m.each({
        Height: "height",
        Width: "width"
    }, function(c, g) {
        m.each({
            padding: "inner" + c,
            content: g,
            "": "outer" + c
        }, function(y, A) {
            m.fn[A] = function(T, L) {
                var O = arguments.length && (y || "boolean" != typeof T)
                  , W = y || (!0 === T || !0 === L ? "margin" : "border");
                return ni(this, function(N, ee, le) {
                    var ge;
                    return ne(N) ? 0 === A.indexOf("outer") ? N["inner" + c] : N.document.documentElement["client" + c] : 9 === N.nodeType ? (ge = N.documentElement,
                    Math.max(N.body["scroll" + c], ge["scroll" + c], N.body["offset" + c], ge["offset" + c], ge["client" + c])) : void 0 === le ? m.css(N, ee, W) : m.style(N, ee, le, W)
                }, g, O ? T : void 0, O)
            }
        })
    }),
    m.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(c, g) {
        m.fn[g] = function(y) {
            return this.on(g, y)
        }
    }),
    m.fn.extend({
        bind: function(c, g, y) {
            return this.on(c, null, g, y)
        },
        unbind: function(c, g) {
            return this.off(c, null, g)
        },
        delegate: function(c, g, y, A) {
            return this.on(g, c, y, A)
        },
        undelegate: function(c, g, y) {
            return 1 === arguments.length ? this.off(c, "**") : this.off(g, c || "**", y)
        },
        hover: function(c, g) {
            return this.on("mouseenter", c).on("mouseleave", g || c)
        }
    }),
    m.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(c, g) {
        m.fn[g] = function(y, A) {
            return 0 < arguments.length ? this.on(g, null, y, A) : this.trigger(g)
        }
    });
    var Wa = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    m.proxy = function(c, g) {
        var y, A, T;
        if ("string" == typeof g && (y = c[g],
        g = c,
        c = y),
        Y(c))
            return A = we.call(arguments, 2),
            (T = function() {
                return c.apply(g || this, A.concat(we.call(arguments)))
            }
            ).guid = c.guid = c.guid || m.guid++,
            T
    }
    ,
    m.holdReady = function(c) {
        c ? m.readyWait++ : m.ready(!0)
    }
    ,
    m.isArray = Array.isArray,
    m.parseJSON = JSON.parse,
    m.nodeName = qe,
    m.isFunction = Y,
    m.isWindow = ne,
    m.camelCase = Gt,
    m.type = U,
    m.now = Date.now,
    m.isNumeric = function(c) {
        var g = m.type(c);
        return ("number" === g || "string" === g) && !isNaN(c - parseFloat(c))
    }
    ,
    m.trim = function(c) {
        return null == c ? "" : (c + "").replace(Wa, "$1")
    }
    ,
    "function" == typeof define && define.amd && define("jquery", [], function() {
        return m
    });
    var Ba = $.jQuery
      , ja = $.$;
    return m.noConflict = function(c) {
        return $.$ === m && ($.$ = ja),
        c && $.jQuery === m && ($.jQuery = Ba),
        m
    }
    ,
    typeof K > "u" && ($.jQuery = $.$ = m),
    m
}),
function($, K) {
    "object" == typeof exports && typeof module < "u" ? module.exports = K() : "function" == typeof define && define.amd ? define(K) : $.Popper = K()
}(this, function() {
    "use strict";
    function $(I) {
        return I && "[object Function]" === {}.toString.call(I)
    }
    function K(I, X) {
        if (1 !== I.nodeType)
            return [];
        var te = I.ownerDocument.defaultView.getComputedStyle(I, null);
        return X ? te[X] : te
    }
    function Ke(I) {
        return "HTML" === I.nodeName ? I : I.parentNode || I.host
    }
    function Q(I) {
        if (!I)
            return document.body;
        switch (I.nodeName) {
        case "HTML":
        case "BODY":
            return I.ownerDocument.body;
        case "#document":
            return I.body
        }
        var X = K(I);
        return /(auto|scroll|overlay)/.test(X.overflow + X.overflowY + X.overflowX) ? I : Q(Ke(I))
    }
    function we(I) {
        return I && I.referenceNode ? I.referenceNode : I
    }
    function Te(I) {
        return 11 === I ? Wt : 10 === I ? Gi : Wt || Gi
    }
    function Re(I) {
        if (!I)
            return document.documentElement;
        for (var X = Te(10) ? document.body : null, q = I.offsetParent || null; q === X && I.nextElementSibling; )
            q = (I = I.nextElementSibling).offsetParent;
        var te = q && q.nodeName;
        return te && "BODY" !== te && "HTML" !== te ? -1 !== ["TH", "TD", "TABLE"].indexOf(q.nodeName) && "static" === K(q, "position") ? Re(q) : q : I ? I.ownerDocument.documentElement : document.documentElement
    }
    function ie(I) {
        return null === I.parentNode ? I : ie(I.parentNode)
    }
    function re(I, X) {
        if (!(I && I.nodeType && X && X.nodeType))
            return document.documentElement;
        var q = I.compareDocumentPosition(X) & Node.DOCUMENT_POSITION_FOLLOWING
          , te = q ? I : X
          , xe = q ? X : I
          , ve = document.createRange();
        ve.setStart(te, 0),
        ve.setEnd(xe, 0);
        var fe = ve.commonAncestorContainer;
        if (I !== fe && X !== fe || te.contains(xe))
            return function pe(I) {
                var X = I.nodeName;
                return "BODY" !== X && ("HTML" === X || Re(I.firstElementChild) === I)
            }(fe) ? fe : Re(fe);
        var Le = ie(I);
        return Le.host ? re(Le.host, X) : re(I, ie(X).host)
    }
    function De(I) {
        var X = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "top"
          , q = "top" === X ? "scrollTop" : "scrollLeft"
          , te = I.nodeName;
        if ("BODY" === te || "HTML" === te) {
            var xe = I.ownerDocument.documentElement
              , ve = I.ownerDocument.scrollingElement || xe;
            return ve[q]
        }
        return I[q]
    }
    function He(I, X) {
        var q = 2 < arguments.length && void 0 !== arguments[2] && arguments[2]
          , te = De(X, "top")
          , xe = De(X, "left")
          , ve = q ? -1 : 1;
        return I.top += te * ve,
        I.bottom += te * ve,
        I.left += xe * ve,
        I.right += xe * ve,
        I
    }
    function F(I, X) {
        var q = "x" === X ? "Left" : "Top"
          , te = "Left" == q ? "Right" : "Bottom";
        return parseFloat(I["border" + q + "Width"]) + parseFloat(I["border" + te + "Width"])
    }
    function J(I, X, q, te) {
        return pi(X["offset" + I], X["scroll" + I], q["client" + I], q["offset" + I], q["scroll" + I], Te(10) ? parseInt(q["offset" + I]) + parseInt(te["margin" + ("Height" === I ? "Top" : "Left")]) + parseInt(te["margin" + ("Height" === I ? "Bottom" : "Right")]) : 0)
    }
    function Y(I) {
        var X = I.body
          , q = I.documentElement
          , te = Te(10) && getComputedStyle(q);
        return {
            height: J("Height", X, q, te),
            width: J("Width", X, q, te)
        }
    }
    function ne(I) {
        return Pt({}, I, {
            right: I.left + I.width,
            bottom: I.top + I.height
        })
    }
    function D(I) {
        var X = {};
        try {
            if (Te(10)) {
                X = I.getBoundingClientRect();
                var q = De(I, "top")
                  , te = De(I, "left");
                X.top += q,
                X.left += te,
                X.bottom += q,
                X.right += te
            } else
                X = I.getBoundingClientRect()
        } catch {}
        var xe = {
            left: X.left,
            top: X.top,
            width: X.right - X.left,
            height: X.bottom - X.top
        }
          , ve = "HTML" === I.nodeName ? Y(I.ownerDocument) : {}
          , Pe = I.offsetWidth - (ve.width || I.clientWidth || xe.width)
          , Fe = I.offsetHeight - (ve.height || I.clientHeight || xe.height);
        if (Pe || Fe) {
            var Qe = K(I);
            Pe -= F(Qe, "x"),
            Fe -= F(Qe, "y"),
            xe.width -= Pe,
            xe.height -= Fe
        }
        return ne(xe)
    }
    function Se(I, X) {
        var q = 2 < arguments.length && void 0 !== arguments[2] && arguments[2]
          , te = Te(10)
          , xe = "HTML" === X.nodeName
          , ve = D(I)
          , fe = D(X)
          , Le = Q(I)
          , Pe = K(X)
          , Fe = parseFloat(Pe.borderTopWidth)
          , Qe = parseFloat(Pe.borderLeftWidth);
        q && xe && (fe.top = pi(fe.top, 0),
        fe.left = pi(fe.left, 0));
        var Ye = ne({
            top: ve.top - fe.top - Fe,
            left: ve.left - fe.left - Qe,
            width: ve.width,
            height: ve.height
        });
        if (Ye.marginTop = 0,
        Ye.marginLeft = 0,
        !te && xe) {
            var Ue = parseFloat(Pe.marginTop)
              , st = parseFloat(Pe.marginLeft);
            Ye.top -= Fe - Ue,
            Ye.bottom -= Fe - Ue,
            Ye.left -= Qe - st,
            Ye.right -= Qe - st,
            Ye.marginTop = Ue,
            Ye.marginLeft = st
        }
        return (te && !q ? X.contains(Le) : X === Le && "BODY" !== Le.nodeName) && (Ye = He(Ye, X)),
        Ye
    }
    function _e(I) {
        var X = 1 < arguments.length && void 0 !== arguments[1] && arguments[1]
          , q = I.ownerDocument.documentElement
          , te = Se(I, q)
          , xe = pi(q.clientWidth, window.innerWidth || 0)
          , ve = pi(q.clientHeight, window.innerHeight || 0)
          , fe = X ? 0 : De(q)
          , Le = X ? 0 : De(q, "left")
          , Pe = {
            top: fe - te.top + te.marginTop,
            left: Le - te.left + te.marginLeft,
            width: xe,
            height: ve
        };
        return ne(Pe)
    }
    function U(I) {
        var X = I.nodeName;
        if ("BODY" === X || "HTML" === X)
            return !1;
        if ("fixed" === K(I, "position"))
            return !0;
        var q = Ke(I);
        return !!q && U(q)
    }
    function ae(I) {
        if (!I || !I.parentElement || Te())
            return document.documentElement;
        for (var X = I.parentElement; X && "none" === K(X, "transform"); )
            X = X.parentElement;
        return X || document.documentElement
    }
    function he(I, X, q, te) {
        var xe = 4 < arguments.length && void 0 !== arguments[4] && arguments[4]
          , ve = {
            top: 0,
            left: 0
        }
          , fe = xe ? ae(I) : re(I, we(X));
        if ("viewport" === te)
            ve = _e(fe, xe);
        else {
            var Le;
            "scrollParent" === te ? "BODY" === (Le = Q(Ke(X))).nodeName && (Le = I.ownerDocument.documentElement) : Le = "window" === te ? I.ownerDocument.documentElement : te;
            var Pe = Se(Le, fe, xe);
            if ("HTML" !== Le.nodeName || U(fe))
                ve = Pe;
            else {
                var Fe = Y(I.ownerDocument)
                  , Qe = Fe.height
                  , Ye = Fe.width;
                ve.top += Pe.top - Pe.marginTop,
                ve.bottom = Qe + Pe.top,
                ve.left += Pe.left - Pe.marginLeft,
                ve.right = Ye + Pe.left
            }
        }
        var Ue = "number" == typeof (q = q || 0);
        return ve.left += Ue ? q : q.left || 0,
        ve.top += Ue ? q : q.top || 0,
        ve.right -= Ue ? q : q.right || 0,
        ve.bottom -= Ue ? q : q.bottom || 0,
        ve
    }
    function m(I) {
        return I.width * I.height
    }
    function Ce(I, X, q, te, xe) {
        var ve = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
        if (-1 === I.indexOf("auto"))
            return I;
        var fe = he(q, te, ve, xe)
          , Le = {
            top: {
                width: fe.width,
                height: X.top - fe.top
            },
            right: {
                width: fe.right - X.right,
                height: fe.height
            },
            bottom: {
                width: fe.width,
                height: fe.bottom - X.bottom
            },
            left: {
                width: X.left - fe.left,
                height: fe.height
            }
        }
          , Pe = Object.keys(Le).map(function(Ue) {
            return Pt({
                key: Ue
            }, Le[Ue], {
                area: m(Le[Ue])
            })
        }).sort(function(Ue, st) {
            return st.area - Ue.area
        })
          , Fe = Pe.filter(function(Ue) {
            return Ue.width >= q.clientWidth && Ue.height >= q.clientHeight
        })
          , Qe = 0 < Fe.length ? Fe[0].key : Pe[0].key
          , Ye = I.split("-")[1];
        return Qe + (Ye ? "-" + Ye : "")
    }
    function qe(I, X, q) {
        var te = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null
          , xe = te ? ae(X) : re(X, we(q));
        return Se(q, xe, te)
    }
    function gt(I) {
        var q = I.ownerDocument.defaultView.getComputedStyle(I)
          , te = parseFloat(q.marginTop || 0) + parseFloat(q.marginBottom || 0)
          , xe = parseFloat(q.marginLeft || 0) + parseFloat(q.marginRight || 0);
        return {
            width: I.offsetWidth + xe,
            height: I.offsetHeight + te
        }
    }
    function kt(I) {
        var X = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        return I.replace(/left|right|bottom|top/g, function(q) {
            return X[q]
        })
    }
    function Kt(I, X, q) {
        q = q.split("-")[0];
        var te = gt(I)
          , xe = {
            width: te.width,
            height: te.height
        }
          , ve = -1 !== ["right", "left"].indexOf(q)
          , fe = ve ? "top" : "left"
          , Le = ve ? "left" : "top"
          , Pe = ve ? "height" : "width"
          , Fe = ve ? "width" : "height";
        return xe[fe] = X[fe] + X[Pe] / 2 - te[Pe] / 2,
        xe[Le] = q === Le ? X[Le] - te[Fe] : X[kt(Le)],
        xe
    }
    function We(I, X) {
        return Array.prototype.find ? I.find(X) : I.filter(X)[0]
    }
    function Oe(I, X, q) {
        var te = void 0 === q ? I : I.slice(0, function At(I, X, q) {
            if (Array.prototype.findIndex)
                return I.findIndex(function(xe) {
                    return xe[X] === q
                });
            var te = We(I, function(xe) {
                return xe[X] === q
            });
            return I.indexOf(te)
        }(I, "name", q));
        return te.forEach(function(xe) {
            xe.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
            var ve = xe.function || xe.fn;
            xe.enabled && $(ve) && (X.offsets.popper = ne(X.offsets.popper),
            X.offsets.reference = ne(X.offsets.reference),
            X = ve(X, xe))
        }),
        X
    }
    function pt() {
        if (!this.state.isDestroyed) {
            var I = {
                instance: this,
                styles: {},
                arrowStyles: {},
                attributes: {},
                flipped: !1,
                offsets: {}
            };
            I.offsets.reference = qe(this.state, this.popper, this.reference, this.options.positionFixed),
            I.placement = Ce(this.options.placement, I.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding),
            I.originalPlacement = I.placement,
            I.positionFixed = this.options.positionFixed,
            I.offsets.popper = Kt(this.popper, I.offsets.reference, I.placement),
            I.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute",
            I = Oe(this.modifiers, I),
            this.state.isCreated ? this.options.onUpdate(I) : (this.state.isCreated = !0,
            this.options.onCreate(I))
        }
    }
    function xt(I, X) {
        return I.some(function(q) {
            return q.enabled && q.name === X
        })
    }
    function St(I) {
        for (var X = [!1, "ms", "Webkit", "Moz", "O"], q = I.charAt(0).toUpperCase() + I.slice(1), te = 0; te < X.length; te++) {
            var xe = X[te]
              , ve = xe ? "" + xe + q : I;
            if (typeof document.body.style[ve] < "u")
                return ve
        }
        return null
    }
    function yt() {
        return this.state.isDestroyed = !0,
        xt(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"),
        this.popper.style.position = "",
        this.popper.style.top = "",
        this.popper.style.left = "",
        this.popper.style.right = "",
        this.popper.style.bottom = "",
        this.popper.style.willChange = "",
        this.popper.style[St("transform")] = ""),
        this.disableEventListeners(),
        this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper),
        this
    }
    function ri(I) {
        var X = I.ownerDocument;
        return X ? X.defaultView : window
    }
    function wt(I, X, q, te) {
        var xe = "BODY" === I.nodeName
          , ve = xe ? I.ownerDocument.defaultView : I;
        ve.addEventListener(X, q, {
            passive: !0
        }),
        xe || wt(Q(ve.parentNode), X, q, te),
        te.push(ve)
    }
    function ye(I, X, q, te) {
        q.updateBound = te,
        ri(I).addEventListener("resize", q.updateBound, {
            passive: !0
        });
        var xe = Q(I);
        return wt(xe, "scroll", q.updateBound, q.scrollParents),
        q.scrollElement = xe,
        q.eventsEnabled = !0,
        q
    }
    function gi() {
        this.state.eventsEnabled || (this.state = ye(this.reference, 0, this.state, this.scheduleUpdate))
    }
    function Lt() {
        this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate),
        this.state = function It(I, X) {
            return ri(I).removeEventListener("resize", X.updateBound),
            X.scrollParents.forEach(function(q) {
                q.removeEventListener("scroll", X.updateBound)
            }),
            X.updateBound = null,
            X.scrollParents = [],
            X.scrollElement = null,
            X.eventsEnabled = !1,
            X
        }(this.reference, this.state))
    }
    function Ct(I) {
        return "" !== I && !isNaN(parseFloat(I)) && isFinite(I)
    }
    function Mt(I, X) {
        Object.keys(X).forEach(function(q) {
            var te = "";
            -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(q) && Ct(X[q]) && (te = "px"),
            I.style[q] = X[q] + te
        })
    }
    function Be(I, X, q) {
        var te = We(I, function(fe) {
            return fe.name === X
        })
          , xe = !!te && I.some(function(fe) {
            return fe.name === q && fe.enabled && fe.order < te.order
        });
        if (!xe) {
            var ve = "`" + X + "`";
            console.warn("`" + q + "` modifier is required by " + ve + " modifier in order to work, be sure to include it before " + ve + "!")
        }
        return xe
    }
    function Di(I) {
        var X = 1 < arguments.length && void 0 !== arguments[1] && arguments[1]
          , q = ei.indexOf(I)
          , te = ei.slice(q + 1).concat(ei.slice(0, q));
        return X ? te.reverse() : te
    }
    var ni = Math.min
      , fi = Math.floor
      , _i = Math.round
      , pi = Math.max
      , Gt = typeof window < "u" && typeof document < "u" && typeof navigator < "u"
      , Bi = function() {
        for (var I = ["Edge", "Trident", "Firefox"], X = 0; X < I.length; X += 1)
            if (Gt && 0 <= navigator.userAgent.indexOf(I[X]))
                return 1;
        return 0
    }()
      , Ge = Gt && window.Promise ? function(I) {
        var X = !1;
        return function() {
            X || (X = !0,
            window.Promise.resolve().then(function() {
                X = !1,
                I()
            }))
        }
    }
    : function(I) {
        var X = !1;
        return function() {
            X || (X = !0,
            setTimeout(function() {
                X = !1,
                I()
            }, Bi))
        }
    }
      , Wt = Gt && !(!window.MSInputMethodContext || !document.documentMode)
      , Gi = Gt && /MSIE 10/.test(navigator.userAgent)
      , Ki = function(I, X) {
        if (!(I instanceof X))
            throw new TypeError("Cannot call a class as a function")
    }
      , ci = function() {
        function I(X, q) {
            for (var te, xe = 0; xe < q.length; xe++)
                (te = q[xe]).enumerable = te.enumerable || !1,
                te.configurable = !0,
                "value"in te && (te.writable = !0),
                Object.defineProperty(X, te.key, te)
        }
        return function(X, q, te) {
            return q && I(X.prototype, q),
            te && I(X, te),
            X
        }
    }()
      , mi = function(I, X, q) {
        return X in I ? Object.defineProperty(I, X, {
            value: q,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : I[X] = q,
        I
    }
      , Pt = Object.assign || function(I) {
        for (var X, q = 1; q < arguments.length; q++)
            for (var te in X = arguments[q])
                Object.prototype.hasOwnProperty.call(X, te) && (I[te] = X[te]);
        return I
    }
      , Bt = Gt && /Firefox/i.test(navigator.userAgent)
      , Qt = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"]
      , ei = Qt.slice(3)
      , xi = function() {
        function I(X, q) {
            var te = this
              , xe = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
            Ki(this, I),
            this.scheduleUpdate = function() {
                return requestAnimationFrame(te.update)
            }
            ,
            this.update = Ge(this.update.bind(this)),
            this.options = Pt({}, I.Defaults, xe),
            this.state = {
                isDestroyed: !1,
                isCreated: !1,
                scrollParents: []
            },
            this.reference = X && X.jquery ? X[0] : X,
            this.popper = q && q.jquery ? q[0] : q,
            this.options.modifiers = {},
            Object.keys(Pt({}, I.Defaults.modifiers, xe.modifiers)).forEach(function(fe) {
                te.options.modifiers[fe] = Pt({}, I.Defaults.modifiers[fe] || {}, xe.modifiers ? xe.modifiers[fe] : {})
            }),
            this.modifiers = Object.keys(this.options.modifiers).map(function(fe) {
                return Pt({
                    name: fe
                }, te.options.modifiers[fe])
            }).sort(function(fe, Le) {
                return fe.order - Le.order
            }),
            this.modifiers.forEach(function(fe) {
                fe.enabled && $(fe.onLoad) && fe.onLoad(te.reference, te.popper, te.options, fe, te.state)
            }),
            this.update();
            var ve = this.options.eventsEnabled;
            ve && this.enableEventListeners(),
            this.state.eventsEnabled = ve
        }
        return ci(I, [{
            key: "update",
            value: function() {
                return pt.call(this)
            }
        }, {
            key: "destroy",
            value: function() {
                return yt.call(this)
            }
        }, {
            key: "enableEventListeners",
            value: function() {
                return gi.call(this)
            }
        }, {
            key: "disableEventListeners",
            value: function() {
                return Lt.call(this)
            }
        }]),
        I
    }();
    return xi.Utils = (typeof window > "u" ? global : window).PopperUtils,
    xi.placements = Qt,
    xi.Defaults = {
        placement: "bottom",
        positionFixed: !1,
        eventsEnabled: !0,
        removeOnDestroy: !1,
        onCreate: function() {},
        onUpdate: function() {},
        modifiers: {
            shift: {
                order: 100,
                enabled: !0,
                fn: function(I) {
                    var X = I.placement
                      , q = X.split("-")[0]
                      , te = X.split("-")[1];
                    if (te) {
                        var xe = I.offsets
                          , ve = xe.reference
                          , fe = xe.popper
                          , Le = -1 !== ["bottom", "top"].indexOf(q)
                          , Pe = Le ? "left" : "top"
                          , Fe = Le ? "width" : "height"
                          , Qe = {
                            start: mi({}, Pe, ve[Pe]),
                            end: mi({}, Pe, ve[Pe] + ve[Fe] - fe[Fe])
                        };
                        I.offsets.popper = Pt({}, fe, Qe[te])
                    }
                    return I
                }
            },
            offset: {
                order: 200,
                enabled: !0,
                fn: function Ai(I, X) {
                    var q, te = X.offset, ve = I.offsets, fe = ve.popper, Le = ve.reference, Pe = I.placement.split("-")[0];
                    return q = Ct(+te) ? [+te, 0] : function aa(I, X, q, te) {
                        var xe = [0, 0]
                          , ve = -1 !== ["right", "left"].indexOf(te)
                          , fe = I.split(/(\+|\-)/).map(function(Qe) {
                            return Qe.trim()
                        })
                          , Le = fe.indexOf(We(fe, function(Qe) {
                            return -1 !== Qe.search(/,|\s/)
                        }));
                        fe[Le] && -1 === fe[Le].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
                        var Pe = /\s*,\s*|\s+/
                          , Fe = -1 === Le ? [fe] : [fe.slice(0, Le).concat([fe[Le].split(Pe)[0]]), [fe[Le].split(Pe)[1]].concat(fe.slice(Le + 1))];
                        return Fe = Fe.map(function(Qe, Ye) {
                            var Ue = (1 === Ye ? !ve : ve) ? "height" : "width"
                              , st = !1;
                            return Qe.reduce(function(tt, Tt) {
                                return "" === tt[tt.length - 1] && -1 !== ["+", "-"].indexOf(Tt) ? (tt[tt.length - 1] = Tt,
                                st = !0,
                                tt) : st ? (tt[tt.length - 1] += Tt,
                                st = !1,
                                tt) : tt.concat(Tt)
                            }, []).map(function(tt) {
                                return function ia(I, X, q, te) {
                                    var xe = I.match(/((?:\-|\+)?\d*\.?\d*)(.*)/)
                                      , ve = +xe[1]
                                      , fe = xe[2];
                                    return ve ? 0 === fe.indexOf("%") ? ne("%p" === fe ? q : te)[X] / 100 * ve : "vh" === fe || "vw" === fe ? ("vh" === fe ? pi(document.documentElement.clientHeight, window.innerHeight || 0) : pi(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * ve : ve : I
                                }(tt, Ue, X, q)
                            })
                        }),
                        Fe.forEach(function(Qe, Ye) {
                            Qe.forEach(function(Ue, st) {
                                Ct(Ue) && (xe[Ye] += Ue * ("-" === Qe[st - 1] ? -1 : 1))
                            })
                        }),
                        xe
                    }(te, fe, Le, Pe),
                    "left" === Pe ? (fe.top += q[0],
                    fe.left -= q[1]) : "right" === Pe ? (fe.top += q[0],
                    fe.left += q[1]) : "top" === Pe ? (fe.left += q[0],
                    fe.top -= q[1]) : "bottom" === Pe && (fe.left += q[0],
                    fe.top += q[1]),
                    I.popper = fe,
                    I
                },
                offset: 0
            },
            preventOverflow: {
                order: 300,
                enabled: !0,
                fn: function(I, X) {
                    var q = X.boundariesElement || Re(I.instance.popper);
                    I.instance.reference === q && (q = Re(q));
                    var te = St("transform")
                      , xe = I.instance.popper.style
                      , ve = xe.top
                      , fe = xe.left
                      , Le = xe[te];
                    xe.top = "",
                    xe.left = "",
                    xe[te] = "";
                    var Pe = he(I.instance.popper, I.instance.reference, X.padding, q, I.positionFixed);
                    xe.top = ve,
                    xe.left = fe,
                    xe[te] = Le,
                    X.boundaries = Pe;
                    var Qe = I.offsets.popper
                      , Ye = {
                        primary: function(Ue) {
                            var st = Qe[Ue];
                            return Qe[Ue] < Pe[Ue] && !X.escapeWithReference && (st = pi(Qe[Ue], Pe[Ue])),
                            mi({}, Ue, st)
                        },
                        secondary: function(Ue) {
                            var st = "right" === Ue ? "left" : "top"
                              , tt = Qe[st];
                            return Qe[Ue] > Pe[Ue] && !X.escapeWithReference && (tt = ni(Qe[st], Pe[Ue] - ("right" === Ue ? Qe.width : Qe.height))),
                            mi({}, st, tt)
                        }
                    };
                    return X.priority.forEach(function(Ue) {
                        var st = -1 === ["left", "top"].indexOf(Ue) ? "secondary" : "primary";
                        Qe = Pt({}, Qe, Ye[st](Ue))
                    }),
                    I.offsets.popper = Qe,
                    I
                },
                priority: ["left", "right", "top", "bottom"],
                padding: 5,
                boundariesElement: "scrollParent"
            },
            keepTogether: {
                order: 400,
                enabled: !0,
                fn: function(I) {
                    var X = I.offsets
                      , q = X.popper
                      , te = X.reference
                      , xe = I.placement.split("-")[0]
                      , ve = fi
                      , fe = -1 !== ["top", "bottom"].indexOf(xe)
                      , Le = fe ? "right" : "bottom"
                      , Pe = fe ? "left" : "top"
                      , Fe = fe ? "width" : "height";
                    return q[Le] < ve(te[Pe]) && (I.offsets.popper[Pe] = ve(te[Pe]) - q[Fe]),
                    q[Pe] > ve(te[Le]) && (I.offsets.popper[Pe] = ve(te[Le])),
                    I
                }
            },
            arrow: {
                order: 500,
                enabled: !0,
                fn: function(I, X) {
                    var q;
                    if (!Be(I.instance.modifiers, "arrow", "keepTogether"))
                        return I;
                    var te = X.element;
                    if ("string" == typeof te) {
                        if (!(te = I.instance.popper.querySelector(te)))
                            return I
                    } else if (!I.instance.popper.contains(te))
                        return console.warn("WARNING: `arrow.element` must be child of its popper element!"),
                        I;
                    var xe = I.placement.split("-")[0]
                      , ve = I.offsets
                      , fe = ve.popper
                      , Le = ve.reference
                      , Pe = -1 !== ["left", "right"].indexOf(xe)
                      , Fe = Pe ? "height" : "width"
                      , Qe = Pe ? "Top" : "Left"
                      , Ye = Qe.toLowerCase()
                      , Ue = Pe ? "left" : "top"
                      , st = Pe ? "bottom" : "right"
                      , tt = gt(te)[Fe];
                    Le[st] - tt < fe[Ye] && (I.offsets.popper[Ye] -= fe[Ye] - (Le[st] - tt)),
                    Le[Ye] + tt > fe[st] && (I.offsets.popper[Ye] += Le[Ye] + tt - fe[st]),
                    I.offsets.popper = ne(I.offsets.popper);
                    var Tt = Le[Ye] + Le[Fe] / 2 - tt / 2
                      , ti = K(I.instance.popper)
                      , hi = parseFloat(ti["margin" + Qe])
                      , Vt = parseFloat(ti["border" + Qe + "Width"])
                      , vi = Tt - I.offsets.popper[Ye] - hi - Vt;
                    return vi = pi(ni(fe[Fe] - tt, vi), 0),
                    I.arrowElement = te,
                    I.offsets.arrow = (mi(q = {}, Ye, _i(vi)),
                    mi(q, Ue, ""),
                    q),
                    I
                },
                element: "[x-arrow]"
            },
            flip: {
                order: 600,
                enabled: !0,
                fn: function(I, X) {
                    if (xt(I.instance.modifiers, "inner") || I.flipped && I.placement === I.originalPlacement)
                        return I;
                    var q = he(I.instance.popper, I.instance.reference, X.padding, X.boundariesElement, I.positionFixed)
                      , te = I.placement.split("-")[0]
                      , xe = kt(te)
                      , ve = I.placement.split("-")[1] || ""
                      , fe = [];
                    switch (X.behavior) {
                    case "flip":
                        fe = [te, xe];
                        break;
                    case "clockwise":
                        fe = Di(te);
                        break;
                    case "counterclockwise":
                        fe = Di(te, !0);
                        break;
                    default:
                        fe = X.behavior
                    }
                    return fe.forEach(function(Le, Pe) {
                        if (te !== Le || fe.length === Pe + 1)
                            return I;
                        te = I.placement.split("-")[0],
                        xe = kt(te);
                        var Fe = I.offsets.popper
                          , Qe = I.offsets.reference
                          , Ye = fi
                          , Ue = "left" === te && Ye(Fe.right) > Ye(Qe.left) || "right" === te && Ye(Fe.left) < Ye(Qe.right) || "top" === te && Ye(Fe.bottom) > Ye(Qe.top) || "bottom" === te && Ye(Fe.top) < Ye(Qe.bottom)
                          , st = Ye(Fe.left) < Ye(q.left)
                          , tt = Ye(Fe.right) > Ye(q.right)
                          , Tt = Ye(Fe.top) < Ye(q.top)
                          , ti = Ye(Fe.bottom) > Ye(q.bottom)
                          , hi = "left" === te && st || "right" === te && tt || "top" === te && Tt || "bottom" === te && ti
                          , Vt = -1 !== ["top", "bottom"].indexOf(te)
                          , yi = !!X.flipVariations && (Vt && "start" === ve && st || Vt && "end" === ve && tt || !Vt && "start" === ve && Tt || !Vt && "end" === ve && ti) || !!X.flipVariationsByContent && (Vt && "start" === ve && tt || Vt && "end" === ve && st || !Vt && "start" === ve && ti || !Vt && "end" === ve && Tt);
                        (Ue || hi || yi) && (I.flipped = !0,
                        (Ue || hi) && (te = fe[Pe + 1]),
                        yi && (ve = function Jt(I) {
                            return "end" === I ? "start" : "start" === I ? "end" : I
                        }(ve)),
                        I.placement = te + (ve ? "-" + ve : ""),
                        I.offsets.popper = Pt({}, I.offsets.popper, Kt(I.instance.popper, I.offsets.reference, I.placement)),
                        I = Oe(I.instance.modifiers, I, "flip"))
                    }),
                    I
                },
                behavior: "flip",
                padding: 5,
                boundariesElement: "viewport",
                flipVariations: !1,
                flipVariationsByContent: !1
            },
            inner: {
                order: 700,
                enabled: !1,
                fn: function(I) {
                    var X = I.placement
                      , q = X.split("-")[0]
                      , te = I.offsets
                      , xe = te.popper
                      , ve = te.reference
                      , fe = -1 !== ["left", "right"].indexOf(q)
                      , Le = -1 === ["top", "left"].indexOf(q);
                    return xe[fe ? "left" : "top"] = ve[q] - (Le ? xe[fe ? "width" : "height"] : 0),
                    I.placement = kt(X),
                    I.offsets.popper = ne(xe),
                    I
                }
            },
            hide: {
                order: 800,
                enabled: !0,
                fn: function(I) {
                    if (!Be(I.instance.modifiers, "hide", "preventOverflow"))
                        return I;
                    var X = I.offsets.reference
                      , q = We(I.instance.modifiers, function(te) {
                        return "preventOverflow" === te.name
                    }).boundaries;
                    if (X.bottom < q.top || X.left > q.right || X.top > q.bottom || X.right < q.left) {
                        if (!0 === I.hide)
                            return I;
                        I.hide = !0,
                        I.attributes["x-out-of-boundaries"] = ""
                    } else {
                        if (!1 === I.hide)
                            return I;
                        I.hide = !1,
                        I.attributes["x-out-of-boundaries"] = !1
                    }
                    return I
                }
            },
            computeStyle: {
                order: 850,
                enabled: !0,
                fn: function(I, X) {
                    var q = X.x
                      , te = X.y
                      , xe = I.offsets.popper
                      , ve = We(I.instance.modifiers, function(vi) {
                        return "applyStyle" === vi.name
                    }).gpuAcceleration;
                    void 0 !== ve && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                    var fe, Le, Pe = void 0 === ve ? X.gpuAcceleration : ve, Fe = Re(I.instance.popper), Qe = D(Fe), Ye = {
                        position: xe.position
                    }, Ue = function Ot(I, X) {
                        var q = I.offsets
                          , te = q.popper
                          , ve = _i
                          , fe = function(st) {
                            return st
                        }
                          , Le = ve(q.reference.width)
                          , Pe = ve(te.width)
                          , Fe = -1 !== ["left", "right"].indexOf(I.placement)
                          , Qe = -1 !== I.placement.indexOf("-")
                          , Ye = X ? Fe || Qe || Le % 2 == Pe % 2 ? ve : fi : fe
                          , Ue = X ? ve : fe;
                        return {
                            left: Ye(Le % 2 == 1 && Pe % 2 == 1 && !Qe && X ? te.left - 1 : te.left),
                            top: Ue(te.top),
                            bottom: Ue(te.bottom),
                            right: Ye(te.right)
                        }
                    }(I, 2 > window.devicePixelRatio || !Bt), st = "bottom" === q ? "top" : "bottom", tt = "right" === te ? "left" : "right", Tt = St("transform");
                    if (Le = "bottom" == st ? "HTML" === Fe.nodeName ? -Fe.clientHeight + Ue.bottom : -Qe.height + Ue.bottom : Ue.top,
                    fe = "right" == tt ? "HTML" === Fe.nodeName ? -Fe.clientWidth + Ue.right : -Qe.width + Ue.right : Ue.left,
                    Pe && Tt)
                        Ye[Tt] = "translate3d(" + fe + "px, " + Le + "px, 0)",
                        Ye[st] = 0,
                        Ye[tt] = 0,
                        Ye.willChange = "transform";
                    else {
                        var hi = "right" == tt ? -1 : 1;
                        Ye[st] = Le * ("bottom" == st ? -1 : 1),
                        Ye[tt] = fe * hi,
                        Ye.willChange = st + ", " + tt
                    }
                    return I.attributes = Pt({}, {
                        "x-placement": I.placement
                    }, I.attributes),
                    I.styles = Pt({}, Ye, I.styles),
                    I.arrowStyles = Pt({}, I.offsets.arrow, I.arrowStyles),
                    I
                },
                gpuAcceleration: !0,
                x: "bottom",
                y: "right"
            },
            applyStyle: {
                order: 900,
                enabled: !0,
                fn: function(I) {
                    return Mt(I.instance.popper, I.styles),
                    function Ft(I, X) {
                        Object.keys(X).forEach(function(q) {
                            !1 === X[q] ? I.removeAttribute(q) : I.setAttribute(q, X[q])
                        })
                    }(I.instance.popper, I.attributes),
                    I.arrowElement && Object.keys(I.arrowStyles).length && Mt(I.arrowElement, I.arrowStyles),
                    I
                },
                onLoad: function(I, X, q, te, xe) {
                    var ve = qe(xe, X, I, q.positionFixed)
                      , fe = Ce(q.placement, ve, X, I, q.modifiers.flip.boundariesElement, q.modifiers.flip.padding);
                    return X.setAttribute("x-placement", fe),
                    Mt(X, {
                        position: q.positionFixed ? "fixed" : "absolute"
                    }),
                    q
                },
                gpuAcceleration: void 0
            }
        }
    },
    xi
}),
function($, K) {
    "object" == typeof exports && typeof module < "u" ? module.exports = K(require("@popperjs/core")) : "function" == typeof define && define.amd ? define(["@popperjs/core"], K) : ($ = typeof globalThis < "u" ? globalThis : $ || self).bootstrap = K($.Popper)
}(this, function($) {
    "use strict";
    const Ke = function K(G) {
        const v = Object.create(null, {
            [Symbol.toStringTag]: {
                value: "Module"
            }
        });
        if (G)
            for (const P in G)
                if ("default" !== P) {
                    const V = Object.getOwnPropertyDescriptor(G, P);
                    Object.defineProperty(v, P, V.get ? V : {
                        enumerable: !0,
                        get: () => G[P]
                    })
                }
        return v.default = G,
        Object.freeze(v)
    }($)
      , Q = new Map
      , we = {
        set(G, v, P) {
            Q.has(G) || Q.set(G, new Map);
            const V = Q.get(G);
            V.has(v) || 0 === V.size ? V.set(v, P) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(V.keys())[0]}.`)
        },
        get: (G, v) => Q.has(G) && Q.get(G).get(v) || null,
        remove(G, v) {
            if (!Q.has(G))
                return;
            const P = Q.get(G);
            P.delete(v),
            0 === P.size && Q.delete(G)
        }
    }
      , Te = "transitionend"
      , Re = G => (G && window.CSS && window.CSS.escape && (G = G.replace(/#([^\s"#']+)/g, (v, P) => `#${CSS.escape(P)}`)),
    G)
      , pe = G => {
        G.dispatchEvent(new Event(Te))
    }
      , ie = G => !(!G || "object" != typeof G) && (void 0 !== G.jquery && (G = G[0]),
    void 0 !== G.nodeType)
      , re = G => ie(G) ? G.jquery ? G[0] : G : "string" == typeof G && G.length > 0 ? document.querySelector(Re(G)) : null
      , De = G => {
        if (!ie(G) || 0 === G.getClientRects().length)
            return !1;
        const v = "visible" === getComputedStyle(G).getPropertyValue("visibility")
          , P = G.closest("details:not([open])");
        if (!P)
            return v;
        if (P !== G) {
            const V = G.closest("summary");
            if (V && V.parentNode !== P || null === V)
                return !1
        }
        return v
    }
      , He = G => !G || G.nodeType !== Node.ELEMENT_NODE || !!G.classList.contains("disabled") || (void 0 !== G.disabled ? G.disabled : G.hasAttribute("disabled") && "false" !== G.getAttribute("disabled"))
      , F = G => {
        if (!document.documentElement.attachShadow)
            return null;
        if ("function" == typeof G.getRootNode) {
            const v = G.getRootNode();
            return v instanceof ShadowRoot ? v : null
        }
        return G instanceof ShadowRoot ? G : G.parentNode ? F(G.parentNode) : null
    }
      , J = () => {}
      , ne = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null
      , D = []
      , Se = () => "rtl" === document.documentElement.dir
      , _e = G => {
        var v;
        v = () => {
            const P = ne();
            if (P) {
                const V = G.NAME
                  , Ae = P.fn[V];
                P.fn[V] = G.jQueryInterface,
                P.fn[V].Constructor = G,
                P.fn[V].noConflict = () => (P.fn[V] = Ae,
                G.jQueryInterface)
            }
        }
        ,
        "loading" === document.readyState ? (D.length || document.addEventListener("DOMContentLoaded", () => {
            for (const P of D)
                P()
        }
        ),
        D.push(v)) : v()
    }
      , U = (G, v=[], P=G) => "function" == typeof G ? G(...v) : P
      , ae = (G, v, P=!0) => {
        if (!P)
            return void U(G);
        const V = (Ve => {
            if (!Ve)
                return 0;
            let {transitionDuration: ft, transitionDelay: Yt} = window.getComputedStyle(Ve);
            const Ti = Number.parseFloat(ft)
              , Mi = Number.parseFloat(Yt);
            return Ti || Mi ? (ft = ft.split(",")[0],
            Yt = Yt.split(",")[0],
            1e3 * (Number.parseFloat(ft) + Number.parseFloat(Yt))) : 0
        }
        )(v) + 5;
        let Ae = !1;
        const Me = ({target: Ve}) => {
            Ve === v && (Ae = !0,
            v.removeEventListener(Te, Me),
            U(G))
        }
        ;
        v.addEventListener(Te, Me),
        setTimeout( () => {
            Ae || pe(v)
        }
        , V)
    }
      , he = (G, v, P, V) => {
        const Ae = G.length;
        let Me = G.indexOf(v);
        return -1 === Me ? !P && V ? G[Ae - 1] : G[0] : (Me += P ? 1 : -1,
        V && (Me = (Me + Ae) % Ae),
        G[Math.max(0, Math.min(Me, Ae - 1))])
    }
      , m = /[^.]*(?=\..*)\.|.*/
      , Ce = /\..*/
      , qe = /::\d+$/
      , gt = {};
    let kt = 1;
    const Kt = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }
      , We = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
    function At(G, v) {
        return v && `${v}::${kt++}` || G.uidEvent || kt++
    }
    function Oe(G) {
        const v = At(G);
        return G.uidEvent = v,
        gt[v] = gt[v] || {},
        gt[v]
    }
    function pt(G, v, P=null) {
        return Object.values(G).find(V => V.callable === v && V.delegationSelector === P)
    }
    function xt(G, v, P) {
        const V = "string" == typeof v
          , Ae = V ? P : v || P;
        let Me = wt(G);
        return We.has(Me) || (Me = G),
        [V, Ae, Me]
    }
    function St(G, v, P, V, Ae) {
        if ("string" != typeof v || !G)
            return;
        let[Me,Ve,ft] = xt(v, P, V);
        var xa;
        v in Kt && (xa = Ve,
        Ve = function(Qi) {
            if (!Qi.relatedTarget || Qi.relatedTarget !== Qi.delegateTarget && !Qi.delegateTarget.contains(Qi.relatedTarget))
                return xa.call(this, Qi)
        }
        );
        const Yt = Oe(G)
          , Ti = Yt[ft] || (Yt[ft] = {})
          , Mi = pt(Ti, Ve, Me ? P : null);
        if (Mi)
            return void (Mi.oneOff = Mi.oneOff && Ae);
        const $i = At(Ve, v.replace(m, ""))
          , na = Me ? function(oa, xa, Qi) {
            return function Fa(Va) {
                const Qa = oa.querySelectorAll(xa);
                for (let {target: va} = Va; va && va !== this; va = va.parentNode)
                    for (const Ka of Qa)
                        if (Ka === va)
                            return gi(Va, {
                                delegateTarget: va
                            }),
                            Fa.oneOff && ye.off(oa, Va.type, xa, Qi),
                            Qi.apply(va, [Va])
            }
        }(G, P, Ve) : function(oa, xa) {
            return function Qi(Fa) {
                return gi(Fa, {
                    delegateTarget: oa
                }),
                Qi.oneOff && ye.off(oa, Fa.type, xa),
                xa.apply(oa, [Fa])
            }
        }(G, Ve);
        na.delegationSelector = Me ? P : null,
        na.callable = Ve,
        na.oneOff = Ae,
        na.uidEvent = $i,
        Ti[$i] = na,
        G.addEventListener(ft, na, Me)
    }
    function yt(G, v, P, V, Ae) {
        const Me = pt(v[P], V, Ae);
        Me && (G.removeEventListener(P, Me, Boolean(Ae)),
        delete v[P][Me.uidEvent])
    }
    function ri(G, v, P, V) {
        const Ae = v[P] || {};
        for (const [Me,Ve] of Object.entries(Ae))
            Me.includes(V) && yt(G, v, P, Ve.callable, Ve.delegationSelector)
    }
    function wt(G) {
        return G = G.replace(Ce, ""),
        Kt[G] || G
    }
    const ye = {
        on(G, v, P, V) {
            St(G, v, P, V, !1)
        },
        one(G, v, P, V) {
            St(G, v, P, V, !0)
        },
        off(G, v, P, V) {
            if ("string" != typeof v || !G)
                return;
            const [Ae,Me,Ve] = xt(v, P, V)
              , ft = Ve !== v
              , Yt = Oe(G)
              , Ti = Yt[Ve] || {}
              , Mi = v.startsWith(".");
            if (void 0 === Me) {
                if (Mi)
                    for (const $i of Object.keys(Yt))
                        ri(G, Yt, $i, v.slice(1));
                for (const [$i,na] of Object.entries(Ti)) {
                    const oa = $i.replace(qe, "");
                    ft && !v.includes(oa) || yt(G, Yt, Ve, na.callable, na.delegationSelector)
                }
            } else {
                if (!Object.keys(Ti).length)
                    return;
                yt(G, Yt, Ve, Me, Ae ? P : null)
            }
        },
        trigger(G, v, P) {
            if ("string" != typeof v || !G)
                return null;
            const V = ne();
            let Ae = null
              , Me = !0
              , Ve = !0
              , ft = !1;
            v !== wt(v) && V && (Ae = V.Event(v, P),
            V(G).trigger(Ae),
            Me = !Ae.isPropagationStopped(),
            Ve = !Ae.isImmediatePropagationStopped(),
            ft = Ae.isDefaultPrevented());
            const Yt = gi(new Event(v,{
                bubbles: Me,
                cancelable: !0
            }), P);
            return ft && Yt.preventDefault(),
            Ve && G.dispatchEvent(Yt),
            Yt.defaultPrevented && Ae && Ae.preventDefault(),
            Yt
        }
    };
    function gi(G, v={}) {
        for (const [P,V] of Object.entries(v))
            try {
                G[P] = V
            } catch {
                Object.defineProperty(G, P, {
                    configurable: !0,
                    get: () => V
                })
            }
        return G
    }
    function It(G) {
        if ("true" === G)
            return !0;
        if ("false" === G)
            return !1;
        if (G === Number(G).toString())
            return Number(G);
        if ("" === G || "null" === G)
            return null;
        if ("string" != typeof G)
            return G;
        try {
            return JSON.parse(decodeURIComponent(G))
        } catch {
            return G
        }
    }
    function Lt(G) {
        return G.replace(/[A-Z]/g, v => `-${v.toLowerCase()}`)
    }
    const Ct = {
        setDataAttribute(G, v, P) {
            G.setAttribute(`data-bs-${Lt(v)}`, P)
        },
        removeDataAttribute(G, v) {
            G.removeAttribute(`data-bs-${Lt(v)}`)
        },
        getDataAttributes(G) {
            if (!G)
                return {};
            const v = {}
              , P = Object.keys(G.dataset).filter(V => V.startsWith("bs") && !V.startsWith("bsConfig"));
            for (const V of P) {
                let Ae = V.replace(/^bs/, "");
                Ae = Ae.charAt(0).toLowerCase() + Ae.slice(1, Ae.length),
                v[Ae] = It(G.dataset[V])
            }
            return v
        },
        getDataAttribute: (G, v) => It(G.getAttribute(`data-bs-${Lt(v)}`))
    };
    class Mt {
        static get Default() {
            return {}
        }
        static get DefaultType() {
            return {}
        }
        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!')
        }
        _getConfig(v) {
            return v = this._mergeConfigObj(v),
            v = this._configAfterMerge(v),
            this._typeCheckConfig(v),
            v
        }
        _configAfterMerge(v) {
            return v
        }
        _mergeConfigObj(v, P) {
            const V = ie(P) ? Ct.getDataAttribute(P, "config") : {};
            return {
                ...this.constructor.Default,
                ..."object" == typeof V ? V : {},
                ...ie(P) ? Ct.getDataAttributes(P) : {},
                ..."object" == typeof v ? v : {}
            }
        }
        _typeCheckConfig(v, P=this.constructor.DefaultType) {
            for (const [Ae,Me] of Object.entries(P)) {
                const Ve = v[Ae]
                  , ft = ie(Ve) ? "element" : null == (V = Ve) ? `${V}` : Object.prototype.toString.call(V).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp(Me).test(ft))
                    throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${Ae}" provided type "${ft}" but expected type "${Me}".`)
            }
            var V
        }
    }
    class Ft extends Mt {
        constructor(v, P) {
            super(),
            (v = re(v)) && (this._element = v,
            this._config = this._getConfig(P),
            we.set(this._element, this.constructor.DATA_KEY, this))
        }
        dispose() {
            we.remove(this._element, this.constructor.DATA_KEY),
            ye.off(this._element, this.constructor.EVENT_KEY);
            for (const v of Object.getOwnPropertyNames(this))
                this[v] = null
        }
        _queueCallback(v, P, V=!0) {
            ae(v, P, V)
        }
        _getConfig(v) {
            return v = this._mergeConfigObj(v, this._element),
            v = this._configAfterMerge(v),
            this._typeCheckConfig(v),
            v
        }
        static getInstance(v) {
            return we.get(re(v), this.DATA_KEY)
        }
        static getOrCreateInstance(v, P={}) {
            return this.getInstance(v) || new this(v,"object" == typeof P ? P : null)
        }
        static get VERSION() {
            return "5.3.2"
        }
        static get DATA_KEY() {
            return `bs.${this.NAME}`
        }
        static get EVENT_KEY() {
            return `.${this.DATA_KEY}`
        }
        static eventName(v) {
            return `${v}${this.EVENT_KEY}`
        }
    }
    const Ot = G => {
        let v = G.getAttribute("data-bs-target");
        if (!v || "#" === v) {
            let P = G.getAttribute("href");
            if (!P || !P.includes("#") && !P.startsWith("."))
                return null;
            P.includes("#") && !P.startsWith("#") && (P = `#${P.split("#")[1]}`),
            v = P && "#" !== P ? Re(P.trim()) : null
        }
        return v
    }
      , Be = {
        find: (G, v=document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(v, G)),
        findOne: (G, v=document.documentElement) => Element.prototype.querySelector.call(v, G),
        children: (G, v) => [].concat(...G.children).filter(P => P.matches(v)),
        parents(G, v) {
            const P = [];
            let V = G.parentNode.closest(v);
            for (; V; )
                P.push(V),
                V = V.parentNode.closest(v);
            return P
        },
        prev(G, v) {
            let P = G.previousElementSibling;
            for (; P; ) {
                if (P.matches(v))
                    return [P];
                P = P.previousElementSibling
            }
            return []
        },
        next(G, v) {
            let P = G.nextElementSibling;
            for (; P; ) {
                if (P.matches(v))
                    return [P];
                P = P.nextElementSibling
            }
            return []
        },
        focusableChildren(G) {
            const v = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(P => `${P}:not([tabindex^="-"])`).join(",");
            return this.find(v, G).filter(P => !He(P) && De(P))
        },
        getSelectorFromElement(G) {
            const v = Ot(G);
            return v && Be.findOne(v) ? v : null
        },
        getElementFromSelector(G) {
            const v = Ot(G);
            return v ? Be.findOne(v) : null
        },
        getMultipleElementsFromSelector(G) {
            const v = Ot(G);
            return v ? Be.find(v) : []
        }
    }
      , Jt = (G, v="hide") => {
        const V = G.NAME;
        ye.on(document, `click.dismiss${G.EVENT_KEY}`, `[data-bs-dismiss="${V}"]`, function(Ae) {
            if (["A", "AREA"].includes(this.tagName) && Ae.preventDefault(),
            He(this))
                return;
            const Me = Be.getElementFromSelector(this) || this.closest(`.${V}`);
            G.getOrCreateInstance(Me)[v]()
        })
    }
      , Di = ".bs.alert"
      , ia = `close${Di}`
      , aa = `closed${Di}`;
    class Ai extends Ft {
        static get NAME() {
            return "alert"
        }
        close() {
            if (ye.trigger(this._element, ia).defaultPrevented)
                return;
            this._element.classList.remove("show");
            const v = this._element.classList.contains("fade");
            this._queueCallback( () => this._destroyElement(), this._element, v)
        }
        _destroyElement() {
            this._element.remove(),
            ye.trigger(this._element, aa),
            this.dispose()
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = Ai.getOrCreateInstance(this);
                if ("string" == typeof v) {
                    if (void 0 === P[v] || v.startsWith("_") || "constructor" === v)
                        throw new TypeError(`No method named "${v}"`);
                    P[v](this)
                }
            })
        }
    }
    Jt(Ai, "close"),
    _e(Ai);
    const ni = '[data-bs-toggle="button"]';
    class fi extends Ft {
        static get NAME() {
            return "button"
        }
        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = fi.getOrCreateInstance(this);
                "toggle" === v && P[v]()
            })
        }
    }
    ye.on(document, "click.bs.button.data-api", ni, G => {
        G.preventDefault();
        const v = G.target.closest(ni);
        fi.getOrCreateInstance(v).toggle()
    }
    ),
    _e(fi);
    const _i = ".bs.swipe"
      , pi = `touchstart${_i}`
      , Gt = `touchmove${_i}`
      , Bi = `touchend${_i}`
      , ji = `pointerdown${_i}`
      , Ge = `pointerup${_i}`
      , Wt = {
        endCallback: null,
        leftCallback: null,
        rightCallback: null
    }
      , Gi = {
        endCallback: "(function|null)",
        leftCallback: "(function|null)",
        rightCallback: "(function|null)"
    };
    class Ki extends Mt {
        constructor(v, P) {
            super(),
            this._element = v,
            v && Ki.isSupported() && (this._config = this._getConfig(P),
            this._deltaX = 0,
            this._supportPointerEvents = Boolean(window.PointerEvent),
            this._initEvents())
        }
        static get Default() {
            return Wt
        }
        static get DefaultType() {
            return Gi
        }
        static get NAME() {
            return "swipe"
        }
        dispose() {
            ye.off(this._element, _i)
        }
        _start(v) {
            this._supportPointerEvents ? this._eventIsPointerPenTouch(v) && (this._deltaX = v.clientX) : this._deltaX = v.touches[0].clientX
        }
        _end(v) {
            this._eventIsPointerPenTouch(v) && (this._deltaX = v.clientX - this._deltaX),
            this._handleSwipe(),
            U(this._config.endCallback)
        }
        _move(v) {
            this._deltaX = v.touches && v.touches.length > 1 ? 0 : v.touches[0].clientX - this._deltaX
        }
        _handleSwipe() {
            const v = Math.abs(this._deltaX);
            if (v <= 40)
                return;
            const P = v / this._deltaX;
            this._deltaX = 0,
            P && U(P > 0 ? this._config.rightCallback : this._config.leftCallback)
        }
        _initEvents() {
            this._supportPointerEvents ? (ye.on(this._element, ji, v => this._start(v)),
            ye.on(this._element, Ge, v => this._end(v)),
            this._element.classList.add("pointer-event")) : (ye.on(this._element, pi, v => this._start(v)),
            ye.on(this._element, Gt, v => this._move(v)),
            ye.on(this._element, Bi, v => this._end(v)))
        }
        _eventIsPointerPenTouch(v) {
            return this._supportPointerEvents && ("pen" === v.pointerType || "touch" === v.pointerType)
        }
        static isSupported() {
            return "ontouchstart"in document.documentElement || navigator.maxTouchPoints > 0
        }
    }
    const ci = ".bs.carousel"
      , mi = ".data-api"
      , Pt = "next"
      , Bt = "prev"
      , Qt = "left"
      , ei = "right"
      , sa = `slide${ci}`
      , xi = `slid${ci}`
      , I = `keydown${ci}`
      , X = `mouseenter${ci}`
      , q = `mouseleave${ci}`
      , te = `dragstart${ci}`
      , xe = `load${ci}${mi}`
      , ve = `click${ci}${mi}`
      , fe = "carousel"
      , Le = "active"
      , Ye = {
        ArrowLeft: ei,
        ArrowRight: Qt
    }
      , Ue = {
        interval: 5e3,
        keyboard: !0,
        pause: "hover",
        ride: !1,
        touch: !0,
        wrap: !0
    }
      , st = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean"
    };
    class tt extends Ft {
        constructor(v, P) {
            super(v, P),
            this._interval = null,
            this._activeElement = null,
            this._isSliding = !1,
            this.touchTimeout = null,
            this._swipeHelper = null,
            this._indicatorsElement = Be.findOne(".carousel-indicators", this._element),
            this._addEventListeners(),
            this._config.ride === fe && this.cycle()
        }
        static get Default() {
            return Ue
        }
        static get DefaultType() {
            return st
        }
        static get NAME() {
            return "carousel"
        }
        next() {
            this._slide(Pt)
        }
        nextWhenVisible() {
            !document.hidden && De(this._element) && this.next()
        }
        prev() {
            this._slide(Bt)
        }
        pause() {
            this._isSliding && pe(this._element),
            this._clearInterval()
        }
        cycle() {
            this._clearInterval(),
            this._updateInterval(),
            this._interval = setInterval( () => this.nextWhenVisible(), this._config.interval)
        }
        _maybeEnableCycle() {
            this._config.ride && (this._isSliding ? ye.one(this._element, xi, () => this.cycle()) : this.cycle())
        }
        to(v) {
            const P = this._getItems();
            if (v > P.length - 1 || v < 0)
                return;
            if (this._isSliding)
                return void ye.one(this._element, xi, () => this.to(v));
            const V = this._getItemIndex(this._getActive());
            V !== v && this._slide(v > V ? Pt : Bt, P[v])
        }
        dispose() {
            this._swipeHelper && this._swipeHelper.dispose(),
            super.dispose()
        }
        _configAfterMerge(v) {
            return v.defaultInterval = v.interval,
            v
        }
        _addEventListeners() {
            this._config.keyboard && ye.on(this._element, I, v => this._keydown(v)),
            "hover" === this._config.pause && (ye.on(this._element, X, () => this.pause()),
            ye.on(this._element, q, () => this._maybeEnableCycle())),
            this._config.touch && Ki.isSupported() && this._addTouchEventListeners()
        }
        _addTouchEventListeners() {
            for (const P of Be.find(".carousel-item img", this._element))
                ye.on(P, te, V => V.preventDefault());
            this._swipeHelper = new Ki(this._element,{
                leftCallback: () => this._slide(this._directionToOrder(Qt)),
                rightCallback: () => this._slide(this._directionToOrder(ei)),
                endCallback: () => {
                    "hover" === this._config.pause && (this.pause(),
                    this.touchTimeout && clearTimeout(this.touchTimeout),
                    this.touchTimeout = setTimeout( () => this._maybeEnableCycle(), 500 + this._config.interval))
                }
            })
        }
        _keydown(v) {
            if (/input|textarea/i.test(v.target.tagName))
                return;
            const P = Ye[v.key];
            P && (v.preventDefault(),
            this._slide(this._directionToOrder(P)))
        }
        _getItemIndex(v) {
            return this._getItems().indexOf(v)
        }
        _setActiveIndicatorElement(v) {
            if (!this._indicatorsElement)
                return;
            const P = Be.findOne(".active", this._indicatorsElement);
            P.classList.remove(Le),
            P.removeAttribute("aria-current");
            const V = Be.findOne(`[data-bs-slide-to="${v}"]`, this._indicatorsElement);
            V && (V.classList.add(Le),
            V.setAttribute("aria-current", "true"))
        }
        _updateInterval() {
            const v = this._activeElement || this._getActive();
            if (!v)
                return;
            const P = Number.parseInt(v.getAttribute("data-bs-interval"), 10);
            this._config.interval = P || this._config.defaultInterval
        }
        _slide(v, P=null) {
            if (this._isSliding)
                return;
            const V = this._getActive()
              , Ae = v === Pt
              , Me = P || he(this._getItems(), V, Ae, this._config.wrap);
            if (Me === V)
                return;
            const Ve = this._getItemIndex(Me)
              , ft = $i => ye.trigger(this._element, $i, {
                relatedTarget: Me,
                direction: this._orderToDirection(v),
                from: this._getItemIndex(V),
                to: Ve
            });
            if (ft(sa).defaultPrevented || !V || !Me)
                return;
            const Yt = Boolean(this._interval);
            this.pause(),
            this._isSliding = !0,
            this._setActiveIndicatorElement(Ve),
            this._activeElement = Me;
            const Ti = Ae ? "carousel-item-start" : "carousel-item-end"
              , Mi = Ae ? "carousel-item-next" : "carousel-item-prev";
            Me.classList.add(Mi),
            V.classList.add(Ti),
            Me.classList.add(Ti),
            this._queueCallback( () => {
                Me.classList.remove(Ti, Mi),
                Me.classList.add(Le),
                V.classList.remove(Le, Mi, Ti),
                this._isSliding = !1,
                ft(xi)
            }
            , V, this._isAnimated()),
            Yt && this.cycle()
        }
        _isAnimated() {
            return this._element.classList.contains("slide")
        }
        _getActive() {
            return Be.findOne(".active.carousel-item", this._element)
        }
        _getItems() {
            return Be.find(".carousel-item", this._element)
        }
        _clearInterval() {
            this._interval && (clearInterval(this._interval),
            this._interval = null)
        }
        _directionToOrder(v) {
            return Se() ? v === Qt ? Bt : Pt : v === Qt ? Pt : Bt
        }
        _orderToDirection(v) {
            return Se() ? v === Bt ? Qt : ei : v === Bt ? ei : Qt
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = tt.getOrCreateInstance(this, v);
                if ("number" != typeof v) {
                    if ("string" == typeof v) {
                        if (void 0 === P[v] || v.startsWith("_") || "constructor" === v)
                            throw new TypeError(`No method named "${v}"`);
                        P[v]()
                    }
                } else
                    P.to(v)
            })
        }
    }
    ye.on(document, ve, "[data-bs-slide], [data-bs-slide-to]", function(G) {
        const v = Be.getElementFromSelector(this);
        if (!v || !v.classList.contains(fe))
            return;
        G.preventDefault();
        const P = tt.getOrCreateInstance(v)
          , V = this.getAttribute("data-bs-slide-to");
        return V ? (P.to(V),
        void P._maybeEnableCycle()) : "next" === Ct.getDataAttribute(this, "slide") ? (P.next(),
        void P._maybeEnableCycle()) : (P.prev(),
        void P._maybeEnableCycle())
    }),
    ye.on(window, xe, () => {
        const G = Be.find('[data-bs-ride="carousel"]');
        for (const v of G)
            tt.getOrCreateInstance(v)
    }
    ),
    _e(tt);
    const Tt = ".bs.collapse"
      , ti = `show${Tt}`
      , hi = `shown${Tt}`
      , Vt = `hide${Tt}`
      , vi = `hidden${Tt}`
      , bi = `click${Tt}.data-api`
      , yi = "show"
      , Ji = "collapse"
      , la = "collapsing"
      , ba = `:scope .${Ji} .${Ji}`
      , Ri = '[data-bs-toggle="collapse"]'
      , ya = {
        parent: null,
        toggle: !0
    }
      , ca = {
        parent: "(null|element)",
        toggle: "boolean"
    };
    class Ei extends Ft {
        constructor(v, P) {
            super(v, P),
            this._isTransitioning = !1,
            this._triggerArray = [];
            const V = Be.find(Ri);
            for (const Ae of V) {
                const Me = Be.getSelectorFromElement(Ae)
                  , Ve = Be.find(Me).filter(ft => ft === this._element);
                null !== Me && Ve.length && this._triggerArray.push(Ae)
            }
            this._initializeChildren(),
            this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
            this._config.toggle && this.toggle()
        }
        static get Default() {
            return ya
        }
        static get DefaultType() {
            return ca
        }
        static get NAME() {
            return "collapse"
        }
        toggle() {
            this._isShown() ? this.hide() : this.show()
        }
        show() {
            if (this._isTransitioning || this._isShown())
                return;
            let v = [];
            if (this._config.parent && (v = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(Ae => Ae !== this._element).map(Ae => Ei.getOrCreateInstance(Ae, {
                toggle: !1
            }))),
            v.length && v[0]._isTransitioning || ye.trigger(this._element, ti).defaultPrevented)
                return;
            for (const Ae of v)
                Ae.hide();
            const P = this._getDimension();
            this._element.classList.remove(Ji),
            this._element.classList.add(la),
            this._element.style[P] = 0,
            this._addAriaAndCollapsedClass(this._triggerArray, !0),
            this._isTransitioning = !0;
            const V = `scroll${P[0].toUpperCase() + P.slice(1)}`;
            this._queueCallback( () => {
                this._isTransitioning = !1,
                this._element.classList.remove(la),
                this._element.classList.add(Ji, yi),
                this._element.style[P] = "",
                ye.trigger(this._element, hi)
            }
            , this._element, !0),
            this._element.style[P] = `${this._element[V]}px`
        }
        hide() {
            if (this._isTransitioning || !this._isShown() || ye.trigger(this._element, Vt).defaultPrevented)
                return;
            const v = this._getDimension();
            this._element.style[v] = `${this._element.getBoundingClientRect()[v]}px`,
            this._element.classList.add(la),
            this._element.classList.remove(Ji, yi);
            for (const P of this._triggerArray) {
                const V = Be.getElementFromSelector(P);
                V && !this._isShown(V) && this._addAriaAndCollapsedClass([P], !1)
            }
            this._isTransitioning = !0,
            this._element.style[v] = "",
            this._queueCallback( () => {
                this._isTransitioning = !1,
                this._element.classList.remove(la),
                this._element.classList.add(Ji),
                ye.trigger(this._element, vi)
            }
            , this._element, !0)
        }
        _isShown(v=this._element) {
            return v.classList.contains(yi)
        }
        _configAfterMerge(v) {
            return v.toggle = Boolean(v.toggle),
            v.parent = re(v.parent),
            v
        }
        _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
        }
        _initializeChildren() {
            if (!this._config.parent)
                return;
            const v = this._getFirstLevelChildren(Ri);
            for (const P of v) {
                const V = Be.getElementFromSelector(P);
                V && this._addAriaAndCollapsedClass([P], this._isShown(V))
            }
        }
        _getFirstLevelChildren(v) {
            const P = Be.find(ba, this._config.parent);
            return Be.find(v, this._config.parent).filter(V => !P.includes(V))
        }
        _addAriaAndCollapsedClass(v, P) {
            if (v.length)
                for (const V of v)
                    V.classList.toggle("collapsed", !P),
                    V.setAttribute("aria-expanded", P)
        }
        static jQueryInterface(v) {
            const P = {};
            return "string" == typeof v && /show|hide/.test(v) && (P.toggle = !1),
            this.each(function() {
                const V = Ei.getOrCreateInstance(this, P);
                if ("string" == typeof v) {
                    if (void 0 === V[v])
                        throw new TypeError(`No method named "${v}"`);
                    V[v]()
                }
            })
        }
    }
    ye.on(document, bi, Ri, function(G) {
        ("A" === G.target.tagName || G.delegateTarget && "A" === G.delegateTarget.tagName) && G.preventDefault();
        for (const v of Be.getMultipleElementsFromSelector(this))
            Ei.getOrCreateInstance(v, {
                toggle: !1
            }).toggle()
    }),
    _e(Ei);
    const Vi = "dropdown"
      , Oi = ".bs.dropdown"
      , C = ".data-api"
      , e = "ArrowUp"
      , t = "ArrowDown"
      , i = `hide${Oi}`
      , a = `hidden${Oi}`
      , s = `show${Oi}`
      , r = `shown${Oi}`
      , n = `click${Oi}${C}`
      , o = `keydown${Oi}${C}`
      , h = `keyup${Oi}${C}`
      , d = "show"
      , u = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)'
      , p = `${u}.show`
      , x = ".dropdown-menu"
      , b = Se() ? "top-end" : "top-start"
      , k = Se() ? "top-start" : "top-end"
      , S = Se() ? "bottom-end" : "bottom-start"
      , E = Se() ? "bottom-start" : "bottom-end"
      , M = Se() ? "left-start" : "right-start"
      , l = Se() ? "right-start" : "left-start"
      , f = {
        autoClose: !0,
        boundary: "clippingParents",
        display: "dynamic",
        offset: [0, 2],
        popperConfig: null,
        reference: "toggle"
    }
      , w = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)"
    };
    class _ extends Ft {
        constructor(v, P) {
            super(v, P),
            this._popper = null,
            this._parent = this._element.parentNode,
            this._menu = Be.next(this._element, x)[0] || Be.prev(this._element, x)[0] || Be.findOne(x, this._parent),
            this._inNavbar = this._detectNavbar()
        }
        static get Default() {
            return f
        }
        static get DefaultType() {
            return w
        }
        static get NAME() {
            return Vi
        }
        toggle() {
            return this._isShown() ? this.hide() : this.show()
        }
        show() {
            if (He(this._element) || this._isShown())
                return;
            const v = {
                relatedTarget: this._element
            };
            if (!ye.trigger(this._element, s, v).defaultPrevented) {
                if (this._createPopper(),
                "ontouchstart"in document.documentElement && !this._parent.closest(".navbar-nav"))
                    for (const P of [].concat(...document.body.children))
                        ye.on(P, "mouseover", J);
                this._element.focus(),
                this._element.setAttribute("aria-expanded", !0),
                this._menu.classList.add(d),
                this._element.classList.add(d),
                ye.trigger(this._element, r, v)
            }
        }
        hide() {
            !He(this._element) && this._isShown() && this._completeHide({
                relatedTarget: this._element
            })
        }
        dispose() {
            this._popper && this._popper.destroy(),
            super.dispose()
        }
        update() {
            this._inNavbar = this._detectNavbar(),
            this._popper && this._popper.update()
        }
        _completeHide(v) {
            if (!ye.trigger(this._element, i, v).defaultPrevented) {
                if ("ontouchstart"in document.documentElement)
                    for (const P of [].concat(...document.body.children))
                        ye.off(P, "mouseover", J);
                this._popper && this._popper.destroy(),
                this._menu.classList.remove(d),
                this._element.classList.remove(d),
                this._element.setAttribute("aria-expanded", "false"),
                Ct.removeDataAttribute(this._menu, "popper"),
                ye.trigger(this._element, a, v)
            }
        }
        _getConfig(v) {
            if ("object" == typeof (v = super._getConfig(v)).reference && !ie(v.reference) && "function" != typeof v.reference.getBoundingClientRect)
                throw new TypeError(`${Vi.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            return v
        }
        _createPopper() {
            if (void 0 === Ke)
                throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            let v = this._element;
            "parent" === this._config.reference ? v = this._parent : ie(this._config.reference) ? v = re(this._config.reference) : "object" == typeof this._config.reference && (v = this._config.reference);
            const P = this._getPopperConfig();
            this._popper = Ke.createPopper(v, this._menu, P)
        }
        _isShown() {
            return this._menu.classList.contains(d)
        }
        _getPlacement() {
            const v = this._parent;
            if (v.classList.contains("dropend"))
                return M;
            if (v.classList.contains("dropstart"))
                return l;
            if (v.classList.contains("dropup-center"))
                return "top";
            if (v.classList.contains("dropdown-center"))
                return "bottom";
            const P = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
            return v.classList.contains("dropup") ? P ? k : b : P ? E : S
        }
        _detectNavbar() {
            return null !== this._element.closest(".navbar")
        }
        _getOffset() {
            const {offset: v} = this._config;
            return "string" == typeof v ? v.split(",").map(P => Number.parseInt(P, 10)) : "function" == typeof v ? P => v(P, this._element) : v
        }
        _getPopperConfig() {
            const v = {
                placement: this._getPlacement(),
                modifiers: [{
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }]
            };
            return (this._inNavbar || "static" === this._config.display) && (Ct.setDataAttribute(this._menu, "popper", "static"),
            v.modifiers = [{
                name: "applyStyles",
                enabled: !1
            }]),
            {
                ...v,
                ...U(this._config.popperConfig, [v])
            }
        }
        _selectMenuItem({key: v, target: P}) {
            const V = Be.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(Ae => De(Ae));
            V.length && he(V, P, v === t, !V.includes(P)).focus()
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = _.getOrCreateInstance(this, v);
                if ("string" == typeof v) {
                    if (void 0 === P[v])
                        throw new TypeError(`No method named "${v}"`);
                    P[v]()
                }
            })
        }
        static clearMenus(v) {
            if (2 === v.button || "keyup" === v.type && "Tab" !== v.key)
                return;
            const P = Be.find(p);
            for (const V of P) {
                const Ae = _.getInstance(V);
                if (!Ae || !1 === Ae._config.autoClose)
                    continue;
                const Me = v.composedPath()
                  , Ve = Me.includes(Ae._menu);
                if (Me.includes(Ae._element) || "inside" === Ae._config.autoClose && !Ve || "outside" === Ae._config.autoClose && Ve || Ae._menu.contains(v.target) && ("keyup" === v.type && "Tab" === v.key || /input|select|option|textarea|form/i.test(v.target.tagName)))
                    continue;
                const ft = {
                    relatedTarget: Ae._element
                };
                "click" === v.type && (ft.clickEvent = v),
                Ae._completeHide(ft)
            }
        }
        static dataApiKeydownHandler(v) {
            const P = /input|textarea/i.test(v.target.tagName)
              , V = "Escape" === v.key
              , Ae = [e, t].includes(v.key);
            if (!Ae && !V || P && !V)
                return;
            v.preventDefault();
            const Me = this.matches(u) ? this : Be.prev(this, u)[0] || Be.next(this, u)[0] || Be.findOne(u, v.delegateTarget.parentNode)
              , Ve = _.getOrCreateInstance(Me);
            if (Ae)
                return v.stopPropagation(),
                Ve.show(),
                void Ve._selectMenuItem(v);
            Ve._isShown() && (v.stopPropagation(),
            Ve.hide(),
            Me.focus())
        }
    }
    ye.on(document, o, u, _.dataApiKeydownHandler),
    ye.on(document, o, x, _.dataApiKeydownHandler),
    ye.on(document, n, _.clearMenus),
    ye.on(document, h, _.clearMenus),
    ye.on(document, n, u, function(G) {
        G.preventDefault(),
        _.getOrCreateInstance(this).toggle()
    }),
    _e(_);
    const R = "backdrop"
      , H = "show"
      , B = `mousedown.bs.${R}`
      , j = {
        className: "modal-backdrop",
        clickCallback: null,
        isAnimated: !1,
        isVisible: !0,
        rootElement: "body"
    }
      , ce = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)"
    };
    class me extends Mt {
        constructor(v) {
            super(),
            this._config = this._getConfig(v),
            this._isAppended = !1,
            this._element = null
        }
        static get Default() {
            return j
        }
        static get DefaultType() {
            return ce
        }
        static get NAME() {
            return R
        }
        show(v) {
            if (!this._config.isVisible)
                return void U(v);
            this._append();
            this._getElement().classList.add(H),
            this._emulateAnimation( () => {
                U(v)
            }
            )
        }
        hide(v) {
            this._config.isVisible ? (this._getElement().classList.remove(H),
            this._emulateAnimation( () => {
                this.dispose(),
                U(v)
            }
            )) : U(v)
        }
        dispose() {
            this._isAppended && (ye.off(this._element, B),
            this._element.remove(),
            this._isAppended = !1)
        }
        _getElement() {
            if (!this._element) {
                const v = document.createElement("div");
                v.className = this._config.className,
                this._config.isAnimated && v.classList.add("fade"),
                this._element = v
            }
            return this._element
        }
        _configAfterMerge(v) {
            return v.rootElement = re(v.rootElement),
            v
        }
        _append() {
            if (this._isAppended)
                return;
            const v = this._getElement();
            this._config.rootElement.append(v),
            ye.on(v, B, () => {
                U(this._config.clickCallback)
            }
            ),
            this._isAppended = !0
        }
        _emulateAnimation(v) {
            ae(v, this._getElement(), this._config.isAnimated)
        }
    }
    const ue = ".bs.focustrap"
      , Ee = `focusin${ue}`
      , Ie = `keydown.tab${ue}`
      , rt = "backward"
      , nt = {
        autofocus: !0,
        trapElement: null
    }
      , ht = {
        autofocus: "boolean",
        trapElement: "element"
    };
    class vt extends Mt {
        constructor(v) {
            super(),
            this._config = this._getConfig(v),
            this._isActive = !1,
            this._lastTabNavDirection = null
        }
        static get Default() {
            return nt
        }
        static get DefaultType() {
            return ht
        }
        static get NAME() {
            return "focustrap"
        }
        activate() {
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(),
            ye.off(document, ue),
            ye.on(document, Ee, v => this._handleFocusin(v)),
            ye.on(document, Ie, v => this._handleKeydown(v)),
            this._isActive = !0)
        }
        deactivate() {
            this._isActive && (this._isActive = !1,
            ye.off(document, ue))
        }
        _handleFocusin(v) {
            const {trapElement: P} = this._config;
            if (v.target === document || v.target === P || P.contains(v.target))
                return;
            const V = Be.focusableChildren(P);
            0 === V.length ? P.focus() : this._lastTabNavDirection === rt ? V[V.length - 1].focus() : V[0].focus()
        }
        _handleKeydown(v) {
            "Tab" === v.key && (this._lastTabNavDirection = v.shiftKey ? rt : "forward")
        }
    }
    const mt = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
      , _t = ".sticky-top"
      , ii = "padding-right"
      , Li = "margin-right";
    class ra {
        constructor() {
            this._element = document.body
        }
        getWidth() {
            const v = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - v)
        }
        hide() {
            const v = this.getWidth();
            this._disableOverFlow(),
            this._setElementAttributes(this._element, ii, P => P + v),
            this._setElementAttributes(mt, ii, P => P + v),
            this._setElementAttributes(_t, Li, P => P - v)
        }
        reset() {
            this._resetElementAttributes(this._element, "overflow"),
            this._resetElementAttributes(this._element, ii),
            this._resetElementAttributes(mt, ii),
            this._resetElementAttributes(_t, Li)
        }
        isOverflowing() {
            return this.getWidth() > 0
        }
        _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"),
            this._element.style.overflow = "hidden"
        }
        _setElementAttributes(v, P, V) {
            const Ae = this.getWidth();
            this._applyManipulationCallback(v, Me => {
                if (Me !== this._element && window.innerWidth > Me.clientWidth + Ae)
                    return;
                this._saveInitialAttribute(Me, P);
                const Ve = window.getComputedStyle(Me).getPropertyValue(P);
                Me.style.setProperty(P, `${V(Number.parseFloat(Ve))}px`)
            }
            )
        }
        _saveInitialAttribute(v, P) {
            const V = v.style.getPropertyValue(P);
            V && Ct.setDataAttribute(v, P, V)
        }
        _resetElementAttributes(v, P) {
            this._applyManipulationCallback(v, V => {
                const Ae = Ct.getDataAttribute(V, P);
                null !== Ae ? (Ct.removeDataAttribute(V, P),
                V.style.setProperty(P, Ae)) : V.style.removeProperty(P)
            }
            )
        }
        _applyManipulationCallback(v, P) {
            if (ie(v))
                P(v);
            else
                for (const V of Be.find(v, this._element))
                    P(V)
        }
    }
    const ai = ".bs.modal"
      , qt = `hide${ai}`
      , Ut = `hidePrevented${ai}`
      , ga = `hidden${ai}`
      , Na = `show${ai}`
      , qa = `shown${ai}`
      , Ua = `resize${ai}`
      , Za = `click.dismiss${ai}`
      , Xa = `mousedown.dismiss${ai}`
      , Pa = `keydown.dismiss${ai}`
      , Ya = `click${ai}.data-api`
      , wa = "modal-open"
      , ka = "modal-static"
      , Ma = {
        backdrop: !0,
        focus: !0,
        keyboard: !0
    }
      , $a = {
        backdrop: "(boolean|string)",
        focus: "boolean",
        keyboard: "boolean"
    };
    class Pi extends Ft {
        constructor(v, P) {
            super(v, P),
            this._dialog = Be.findOne(".modal-dialog", this._element),
            this._backdrop = this._initializeBackDrop(),
            this._focustrap = this._initializeFocusTrap(),
            this._isShown = !1,
            this._isTransitioning = !1,
            this._scrollBar = new ra,
            this._addEventListeners()
        }
        static get Default() {
            return Ma
        }
        static get DefaultType() {
            return $a
        }
        static get NAME() {
            return "modal"
        }
        toggle(v) {
            return this._isShown ? this.hide() : this.show(v)
        }
        show(v) {
            this._isShown || this._isTransitioning || ye.trigger(this._element, Na, {
                relatedTarget: v
            }).defaultPrevented || (this._isShown = !0,
            this._isTransitioning = !0,
            this._scrollBar.hide(),
            document.body.classList.add(wa),
            this._adjustDialog(),
            this._backdrop.show( () => this._showElement(v)))
        }
        hide() {
            this._isShown && !this._isTransitioning && (ye.trigger(this._element, qt).defaultPrevented || (this._isShown = !1,
            this._isTransitioning = !0,
            this._focustrap.deactivate(),
            this._element.classList.remove("show"),
            this._queueCallback( () => this._hideModal(), this._element, this._isAnimated())))
        }
        dispose() {
            ye.off(window, ai),
            ye.off(this._dialog, ai),
            this._backdrop.dispose(),
            this._focustrap.deactivate(),
            super.dispose()
        }
        handleUpdate() {
            this._adjustDialog()
        }
        _initializeBackDrop() {
            return new me({
                isVisible: Boolean(this._config.backdrop),
                isAnimated: this._isAnimated()
            })
        }
        _initializeFocusTrap() {
            return new vt({
                trapElement: this._element
            })
        }
        _showElement(v) {
            document.body.contains(this._element) || document.body.append(this._element),
            this._element.style.display = "block",
            this._element.removeAttribute("aria-hidden"),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.scrollTop = 0;
            const P = Be.findOne(".modal-body", this._dialog);
            P && (P.scrollTop = 0),
            this._element.classList.add("show"),
            this._queueCallback( () => {
                this._config.focus && this._focustrap.activate(),
                this._isTransitioning = !1,
                ye.trigger(this._element, qa, {
                    relatedTarget: v
                })
            }
            , this._dialog, this._isAnimated())
        }
        _addEventListeners() {
            ye.on(this._element, Pa, v => {
                "Escape" === v.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition())
            }
            ),
            ye.on(window, Ua, () => {
                this._isShown && !this._isTransitioning && this._adjustDialog()
            }
            ),
            ye.on(this._element, Xa, v => {
                ye.one(this._element, Za, P => {
                    this._element === v.target && this._element === P.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
                }
                )
            }
            )
        }
        _hideModal() {
            this._element.style.display = "none",
            this._element.setAttribute("aria-hidden", !0),
            this._element.removeAttribute("aria-modal"),
            this._element.removeAttribute("role"),
            this._isTransitioning = !1,
            this._backdrop.hide( () => {
                document.body.classList.remove(wa),
                this._resetAdjustments(),
                this._scrollBar.reset(),
                ye.trigger(this._element, ga)
            }
            )
        }
        _isAnimated() {
            return this._element.classList.contains("fade")
        }
        _triggerBackdropTransition() {
            if (ye.trigger(this._element, Ut).defaultPrevented)
                return;
            const v = this._element.scrollHeight > document.documentElement.clientHeight
              , P = this._element.style.overflowY;
            "hidden" === P || this._element.classList.contains(ka) || (v || (this._element.style.overflowY = "hidden"),
            this._element.classList.add(ka),
            this._queueCallback( () => {
                this._element.classList.remove(ka),
                this._queueCallback( () => {
                    this._element.style.overflowY = P
                }
                , this._dialog)
            }
            , this._dialog),
            this._element.focus())
        }
        _adjustDialog() {
            const v = this._element.scrollHeight > document.documentElement.clientHeight
              , P = this._scrollBar.getWidth()
              , V = P > 0;
            if (V && !v) {
                const Ae = Se() ? "paddingLeft" : "paddingRight";
                this._element.style[Ae] = `${P}px`
            }
            if (!V && v) {
                const Ae = Se() ? "paddingRight" : "paddingLeft";
                this._element.style[Ae] = `${P}px`
            }
        }
        _resetAdjustments() {
            this._element.style.paddingLeft = "",
            this._element.style.paddingRight = ""
        }
        static jQueryInterface(v, P) {
            return this.each(function() {
                const V = Pi.getOrCreateInstance(this, v);
                if ("string" == typeof v) {
                    if (void 0 === V[v])
                        throw new TypeError(`No method named "${v}"`);
                    V[v](P)
                }
            })
        }
    }
    ye.on(document, Ya, '[data-bs-toggle="modal"]', function(G) {
        const v = Be.getElementFromSelector(this);
        ["A", "AREA"].includes(this.tagName) && G.preventDefault(),
        ye.one(v, Na, V => {
            V.defaultPrevented || ye.one(v, ga, () => {
                De(this) && this.focus()
            }
            )
        }
        );
        const P = Be.findOne(".modal.show");
        P && Pi.getInstance(P).hide(),
        Pi.getOrCreateInstance(v).toggle(this)
    }),
    Jt(Pi),
    _e(Pi);
    const Hi = ".bs.offcanvas"
      , Da = ".data-api"
      , Ra = `load${Hi}${Da}`
      , Ba = "showing"
      , c = ".offcanvas.show"
      , g = `show${Hi}`
      , y = `shown${Hi}`
      , A = `hide${Hi}`
      , T = `hidePrevented${Hi}`
      , L = `hidden${Hi}`
      , O = `resize${Hi}`
      , W = `click${Hi}${Da}`
      , N = `keydown.dismiss${Hi}`
      , ee = {
        backdrop: !0,
        keyboard: !0,
        scroll: !1
    }
      , le = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        scroll: "boolean"
    };
    class ge extends Ft {
        constructor(v, P) {
            super(v, P),
            this._isShown = !1,
            this._backdrop = this._initializeBackDrop(),
            this._focustrap = this._initializeFocusTrap(),
            this._addEventListeners()
        }
        static get Default() {
            return ee
        }
        static get DefaultType() {
            return le
        }
        static get NAME() {
            return "offcanvas"
        }
        toggle(v) {
            return this._isShown ? this.hide() : this.show(v)
        }
        show(v) {
            this._isShown || ye.trigger(this._element, g, {
                relatedTarget: v
            }).defaultPrevented || (this._isShown = !0,
            this._backdrop.show(),
            this._config.scroll || (new ra).hide(),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.classList.add(Ba),
            this._queueCallback( () => {
                this._config.scroll && !this._config.backdrop || this._focustrap.activate(),
                this._element.classList.add("show"),
                this._element.classList.remove(Ba),
                ye.trigger(this._element, y, {
                    relatedTarget: v
                })
            }
            , this._element, !0))
        }
        hide() {
            this._isShown && (ye.trigger(this._element, A).defaultPrevented || (this._focustrap.deactivate(),
            this._element.blur(),
            this._isShown = !1,
            this._element.classList.add("hiding"),
            this._backdrop.hide(),
            this._queueCallback( () => {
                this._element.classList.remove("show", "hiding"),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._config.scroll || (new ra).reset(),
                ye.trigger(this._element, L)
            }
            , this._element, !0)))
        }
        dispose() {
            this._backdrop.dispose(),
            this._focustrap.deactivate(),
            super.dispose()
        }
        _initializeBackDrop() {
            const v = Boolean(this._config.backdrop);
            return new me({
                className: "offcanvas-backdrop",
                isVisible: v,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: v ? () => {
                    "static" !== this._config.backdrop ? this.hide() : ye.trigger(this._element, T)
                }
                : null
            })
        }
        _initializeFocusTrap() {
            return new vt({
                trapElement: this._element
            })
        }
        _addEventListeners() {
            ye.on(this._element, N, v => {
                "Escape" === v.key && (this._config.keyboard ? this.hide() : ye.trigger(this._element, T))
            }
            )
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = ge.getOrCreateInstance(this, v);
                if ("string" == typeof v) {
                    if (void 0 === P[v] || v.startsWith("_") || "constructor" === v)
                        throw new TypeError(`No method named "${v}"`);
                    P[v](this)
                }
            })
        }
    }
    ye.on(document, W, '[data-bs-toggle="offcanvas"]', function(G) {
        const v = Be.getElementFromSelector(this);
        if (["A", "AREA"].includes(this.tagName) && G.preventDefault(),
        He(this))
            return;
        ye.one(v, L, () => {
            De(this) && this.focus()
        }
        );
        const P = Be.findOne(c);
        P && P !== v && ge.getInstance(P).hide(),
        ge.getOrCreateInstance(v).toggle(this)
    }),
    ye.on(window, Ra, () => {
        for (const G of Be.find(c))
            ge.getOrCreateInstance(G).show()
    }
    ),
    ye.on(window, O, () => {
        for (const G of Be.find("[aria-modal][class*=show][class*=offcanvas-]"))
            "fixed" !== getComputedStyle(G).position && ge.getOrCreateInstance(G).hide()
    }
    ),
    Jt(ge),
    _e(ge);
    const se = {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    }
      , ke = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"])
      , Ze = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i
      , it = (G, v) => {
        const P = G.nodeName.toLowerCase();
        return v.includes(P) ? !ke.has(P) || Boolean(Ze.test(G.nodeValue)) : v.filter(V => V instanceof RegExp).some(V => V.test(P))
    }
      , at = {
        allowList: se,
        content: {},
        extraClass: "",
        html: !1,
        sanitize: !0,
        sanitizeFn: null,
        template: "<div></div>"
    }
      , Nt = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string"
    }
      , Zt = {
        entry: "(string|element|function|null)",
        selector: "(string|element)"
    };
    class zi extends Mt {
        constructor(v) {
            super(),
            this._config = this._getConfig(v)
        }
        static get Default() {
            return at
        }
        static get DefaultType() {
            return Nt
        }
        static get NAME() {
            return "TemplateFactory"
        }
        getContent() {
            return Object.values(this._config.content).map(v => this._resolvePossibleFunction(v)).filter(Boolean)
        }
        hasContent() {
            return this.getContent().length > 0
        }
        changeContent(v) {
            return this._checkContent(v),
            this._config.content = {
                ...this._config.content,
                ...v
            },
            this
        }
        toHtml() {
            const v = document.createElement("div");
            v.innerHTML = this._maybeSanitize(this._config.template);
            for (const [Ae,Me] of Object.entries(this._config.content))
                this._setContent(v, Me, Ae);
            const P = v.children[0]
              , V = this._resolvePossibleFunction(this._config.extraClass);
            return V && P.classList.add(...V.split(" ")),
            P
        }
        _typeCheckConfig(v) {
            super._typeCheckConfig(v),
            this._checkContent(v.content)
        }
        _checkContent(v) {
            for (const [P,V] of Object.entries(v))
                super._typeCheckConfig({
                    selector: P,
                    entry: V
                }, Zt)
        }
        _setContent(v, P, V) {
            const Ae = Be.findOne(V, v);
            Ae && ((P = this._resolvePossibleFunction(P)) ? ie(P) ? this._putElementInTemplate(re(P), Ae) : this._config.html ? Ae.innerHTML = this._maybeSanitize(P) : Ae.textContent = P : Ae.remove())
        }
        _maybeSanitize(v) {
            return this._config.sanitize ? function(P, V, Ae) {
                if (!P.length)
                    return P;
                if (Ae && "function" == typeof Ae)
                    return Ae(P);
                const Me = (new window.DOMParser).parseFromString(P, "text/html")
                  , Ve = [].concat(...Me.body.querySelectorAll("*"));
                for (const ft of Ve) {
                    const Yt = ft.nodeName.toLowerCase();
                    if (!Object.keys(V).includes(Yt)) {
                        ft.remove();
                        continue
                    }
                    const Ti = [].concat(...ft.attributes)
                      , Mi = [].concat(V["*"] || [], V[Yt] || []);
                    for (const $i of Ti)
                        it($i, Mi) || ft.removeAttribute($i.nodeName)
                }
                return Me.body.innerHTML
            }(v, this._config.allowList, this._config.sanitizeFn) : v
        }
        _resolvePossibleFunction(v) {
            return U(v, [this])
        }
        _putElementInTemplate(v, P) {
            if (this._config.html)
                return P.innerHTML = "",
                void P.append(v);
            P.textContent = v.textContent
        }
    }
    const Fi = new Set(["sanitize", "allowList", "sanitizeFn"])
      , lt = "fade"
      , Ni = "show"
      , Dt = "hide.bs.modal"
      , qi = "hover"
      , fa = "focus"
      , Xi = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: Se() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: Se() ? "right" : "left"
    }
      , pa = {
        allowList: se,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        html: !1,
        offset: [0, 6],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus"
    }
      , Ui = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string"
    };
    class di extends Ft {
        constructor(v, P) {
            if (void 0 === Ke)
                throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            super(v, P),
            this._isEnabled = !0,
            this._timeout = 0,
            this._isHovered = null,
            this._activeTrigger = {},
            this._popper = null,
            this._templateFactory = null,
            this._newContent = null,
            this.tip = null,
            this._setListeners(),
            this._config.selector || this._fixTitle()
        }
        static get Default() {
            return pa
        }
        static get DefaultType() {
            return Ui
        }
        static get NAME() {
            return "tooltip"
        }
        enable() {
            this._isEnabled = !0
        }
        disable() {
            this._isEnabled = !1
        }
        toggleEnabled() {
            this._isEnabled = !this._isEnabled
        }
        toggle() {
            this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click,
            this._isShown() ? this._leave() : this._enter())
        }
        dispose() {
            clearTimeout(this._timeout),
            ye.off(this._element.closest(".modal"), Dt, this._hideModalHandler),
            this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")),
            this._disposePopper(),
            super.dispose()
        }
        show() {
            if ("none" === this._element.style.display)
                throw new Error("Please use show on visible elements");
            if (!this._isWithContent() || !this._isEnabled)
                return;
            const v = ye.trigger(this._element, this.constructor.eventName("show"))
              , P = (F(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
            if (v.defaultPrevented || !P)
                return;
            this._disposePopper();
            const V = this._getTipElement();
            this._element.setAttribute("aria-describedby", V.getAttribute("id"));
            const {container: Ae} = this._config;
            if (this._element.ownerDocument.documentElement.contains(this.tip) || (Ae.append(V),
            ye.trigger(this._element, this.constructor.eventName("inserted"))),
            this._popper = this._createPopper(V),
            V.classList.add(Ni),
            "ontouchstart"in document.documentElement)
                for (const Me of [].concat(...document.body.children))
                    ye.on(Me, "mouseover", J);
            this._queueCallback( () => {
                ye.trigger(this._element, this.constructor.eventName("shown")),
                !1 === this._isHovered && this._leave(),
                this._isHovered = !1
            }
            , this.tip, this._isAnimated())
        }
        hide() {
            if (this._isShown() && !ye.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
                if (this._getTipElement().classList.remove(Ni),
                "ontouchstart"in document.documentElement)
                    for (const v of [].concat(...document.body.children))
                        ye.off(v, "mouseover", J);
                this._activeTrigger.click = !1,
                this._activeTrigger[fa] = !1,
                this._activeTrigger[qi] = !1,
                this._isHovered = null,
                this._queueCallback( () => {
                    this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(),
                    this._element.removeAttribute("aria-describedby"),
                    ye.trigger(this._element, this.constructor.eventName("hidden")))
                }
                , this.tip, this._isAnimated())
            }
        }
        update() {
            this._popper && this._popper.update()
        }
        _isWithContent() {
            return Boolean(this._getTitle())
        }
        _getTipElement() {
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())),
            this.tip
        }
        _createTipElement(v) {
            const P = this._getTemplateFactory(v).toHtml();
            if (!P)
                return null;
            P.classList.remove(lt, Ni),
            P.classList.add(`bs-${this.constructor.NAME}-auto`);
            const V = (Ae => {
                do {
                    Ae += Math.floor(1e6 * Math.random())
                } while (document.getElementById(Ae));
                return Ae
            }
            )(this.constructor.NAME).toString();
            return P.setAttribute("id", V),
            this._isAnimated() && P.classList.add(lt),
            P
        }
        setContent(v) {
            this._newContent = v,
            this._isShown() && (this._disposePopper(),
            this.show())
        }
        _getTemplateFactory(v) {
            return this._templateFactory ? this._templateFactory.changeContent(v) : this._templateFactory = new zi({
                ...this._config,
                content: v,
                extraClass: this._resolvePossibleFunction(this._config.customClass)
            }),
            this._templateFactory
        }
        _getContentForTemplate() {
            return {
                ".tooltip-inner": this._getTitle()
            }
        }
        _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title")
        }
        _initializeOnDelegatedTarget(v) {
            return this.constructor.getOrCreateInstance(v.delegateTarget, this._getDelegateConfig())
        }
        _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(lt)
        }
        _isShown() {
            return this.tip && this.tip.classList.contains(Ni)
        }
        _createPopper(v) {
            const P = U(this._config.placement, [this, v, this._element])
              , V = Xi[P.toUpperCase()];
            return Ke.createPopper(this._element, v, this._getPopperConfig(V))
        }
        _getOffset() {
            const {offset: v} = this._config;
            return "string" == typeof v ? v.split(",").map(P => Number.parseInt(P, 10)) : "function" == typeof v ? P => v(P, this._element) : v
        }
        _resolvePossibleFunction(v) {
            return U(v, [this._element])
        }
        _getPopperConfig(v) {
            const P = {
                placement: v,
                modifiers: [{
                    name: "flip",
                    options: {
                        fallbackPlacements: this._config.fallbackPlacements
                    }
                }, {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                }, {
                    name: "arrow",
                    options: {
                        element: `.${this.constructor.NAME}-arrow`
                    }
                }, {
                    name: "preSetPlacement",
                    enabled: !0,
                    phase: "beforeMain",
                    fn: V => {
                        this._getTipElement().setAttribute("data-popper-placement", V.state.placement)
                    }
                }]
            };
            return {
                ...P,
                ...U(this._config.popperConfig, [P])
            }
        }
        _setListeners() {
            const v = this._config.trigger.split(" ");
            for (const P of v)
                if ("click" === P)
                    ye.on(this._element, this.constructor.eventName("click"), this._config.selector, V => {
                        this._initializeOnDelegatedTarget(V).toggle()
                    }
                    );
                else if ("manual" !== P) {
                    const V = this.constructor.eventName(P === qi ? "mouseenter" : "focusin")
                      , Ae = this.constructor.eventName(P === qi ? "mouseleave" : "focusout");
                    ye.on(this._element, V, this._config.selector, Me => {
                        const Ve = this._initializeOnDelegatedTarget(Me);
                        Ve._activeTrigger["focusin" === Me.type ? fa : qi] = !0,
                        Ve._enter()
                    }
                    ),
                    ye.on(this._element, Ae, this._config.selector, Me => {
                        const Ve = this._initializeOnDelegatedTarget(Me);
                        Ve._activeTrigger["focusout" === Me.type ? fa : qi] = Ve._element.contains(Me.relatedTarget),
                        Ve._leave()
                    }
                    )
                }
            this._hideModalHandler = () => {
                this._element && this.hide()
            }
            ,
            ye.on(this._element.closest(".modal"), Dt, this._hideModalHandler)
        }
        _fixTitle() {
            const v = this._element.getAttribute("title");
            v && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", v),
            this._element.setAttribute("data-bs-original-title", v),
            this._element.removeAttribute("title"))
        }
        _enter() {
            this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0,
            this._setTimeout( () => {
                this._isHovered && this.show()
            }
            , this._config.delay.show))
        }
        _leave() {
            this._isWithActiveTrigger() || (this._isHovered = !1,
            this._setTimeout( () => {
                this._isHovered || this.hide()
            }
            , this._config.delay.hide))
        }
        _setTimeout(v, P) {
            clearTimeout(this._timeout),
            this._timeout = setTimeout(v, P)
        }
        _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(!0)
        }
        _getConfig(v) {
            const P = Ct.getDataAttributes(this._element);
            for (const V of Object.keys(P))
                Fi.has(V) && delete P[V];
            return v = {
                ...P,
                ..."object" == typeof v && v ? v : {}
            },
            v = this._mergeConfigObj(v),
            v = this._configAfterMerge(v),
            this._typeCheckConfig(v),
            v
        }
        _configAfterMerge(v) {
            return v.container = !1 === v.container ? document.body : re(v.container),
            "number" == typeof v.delay && (v.delay = {
                show: v.delay,
                hide: v.delay
            }),
            "number" == typeof v.title && (v.title = v.title.toString()),
            "number" == typeof v.content && (v.content = v.content.toString()),
            v
        }
        _getDelegateConfig() {
            const v = {};
            for (const [P,V] of Object.entries(this._config))
                this.constructor.Default[P] !== V && (v[P] = V);
            return v.selector = !1,
            v.trigger = "manual",
            v
        }
        _disposePopper() {
            this._popper && (this._popper.destroy(),
            this._popper = null),
            this.tip && (this.tip.remove(),
            this.tip = null)
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = di.getOrCreateInstance(this, v);
                if ("string" == typeof v) {
                    if (void 0 === P[v])
                        throw new TypeError(`No method named "${v}"`);
                    P[v]()
                }
            })
        }
    }
    _e(di);
    const ha = {
        ...di.Default,
        content: "",
        offset: [0, 8],
        placement: "right",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click"
    }
      , Si = {
        ...di.DefaultType,
        content: "(null|string|element|function)"
    };
    class Xt extends di {
        static get Default() {
            return ha
        }
        static get DefaultType() {
            return Si
        }
        static get NAME() {
            return "popover"
        }
        _isWithContent() {
            return this._getTitle() || this._getContent()
        }
        _getContentForTemplate() {
            return {
                ".popover-header": this._getTitle(),
                ".popover-body": this._getContent()
            }
        }
        _getContent() {
            return this._resolvePossibleFunction(this._config.content)
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = Xt.getOrCreateInstance(this, v);
                if ("string" == typeof v) {
                    if (void 0 === P[v])
                        throw new TypeError(`No method named "${v}"`);
                    P[v]()
                }
            })
        }
    }
    _e(Xt);
    const Ht = ".bs.scrollspy"
      , oi = `activate${Ht}`
      , Zi = `click${Ht}`
      , li = `load${Ht}.data-api`
      , $e = "active"
      , Rt = "[href]"
      , zt = ".nav-link"
      , Et = `${zt}, .nav-item > ${zt}, .list-group-item`
      , Yi = {
        offset: null,
        rootMargin: "0px 0px -25%",
        smoothScroll: !1,
        target: null,
        threshold: [.1, .5, 1]
    }
      , da = {
        offset: "(number|null)",
        rootMargin: "string",
        smoothScroll: "boolean",
        target: "element",
        threshold: "array"
    };
    class ea extends Ft {
        constructor(v, P) {
            super(v, P),
            this._targetLinks = new Map,
            this._observableSections = new Map,
            this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element,
            this._activeTarget = null,
            this._observer = null,
            this._previousScrollData = {
                visibleEntryTop: 0,
                parentScrollTop: 0
            },
            this.refresh()
        }
        static get Default() {
            return Yi
        }
        static get DefaultType() {
            return da
        }
        static get NAME() {
            return "scrollspy"
        }
        refresh() {
            this._initializeTargetsAndObservables(),
            this._maybeEnableSmoothScroll(),
            this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
            for (const v of this._observableSections.values())
                this._observer.observe(v)
        }
        dispose() {
            this._observer.disconnect(),
            super.dispose()
        }
        _configAfterMerge(v) {
            return v.target = re(v.target) || document.body,
            v.rootMargin = v.offset ? `${v.offset}px 0px -30%` : v.rootMargin,
            "string" == typeof v.threshold && (v.threshold = v.threshold.split(",").map(P => Number.parseFloat(P))),
            v
        }
        _maybeEnableSmoothScroll() {
            this._config.smoothScroll && (ye.off(this._config.target, Zi),
            ye.on(this._config.target, Zi, Rt, v => {
                const P = this._observableSections.get(v.target.hash);
                if (P) {
                    v.preventDefault();
                    const V = this._rootElement || window
                      , Ae = P.offsetTop - this._element.offsetTop;
                    if (V.scrollTo)
                        return void V.scrollTo({
                            top: Ae,
                            behavior: "smooth"
                        });
                    V.scrollTop = Ae
                }
            }
            ))
        }
        _getNewObserver() {
            return new IntersectionObserver(P => this._observerCallback(P),{
                root: this._rootElement,
                threshold: this._config.threshold,
                rootMargin: this._config.rootMargin
            })
        }
        _observerCallback(v) {
            const P = Ve => this._targetLinks.get(`#${Ve.target.id}`)
              , V = Ve => {
                this._previousScrollData.visibleEntryTop = Ve.target.offsetTop,
                this._process(P(Ve))
            }
              , Ae = (this._rootElement || document.documentElement).scrollTop
              , Me = Ae >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = Ae;
            for (const Ve of v) {
                if (!Ve.isIntersecting) {
                    this._activeTarget = null,
                    this._clearActiveClass(P(Ve));
                    continue
                }
                const ft = Ve.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                if (Me && ft) {
                    if (V(Ve),
                    !Ae)
                        return
                } else
                    Me || ft || V(Ve)
            }
        }
        _initializeTargetsAndObservables() {
            this._targetLinks = new Map,
            this._observableSections = new Map;
            const v = Be.find(Rt, this._config.target);
            for (const P of v) {
                if (!P.hash || He(P))
                    continue;
                const V = Be.findOne(decodeURI(P.hash), this._element);
                De(V) && (this._targetLinks.set(decodeURI(P.hash), P),
                this._observableSections.set(P.hash, V))
            }
        }
        _process(v) {
            this._activeTarget !== v && (this._clearActiveClass(this._config.target),
            this._activeTarget = v,
            v.classList.add($e),
            this._activateParents(v),
            ye.trigger(this._element, oi, {
                relatedTarget: v
            }))
        }
        _activateParents(v) {
            if (v.classList.contains("dropdown-item"))
                Be.findOne(".dropdown-toggle", v.closest(".dropdown")).classList.add($e);
            else
                for (const P of Be.parents(v, ".nav, .list-group"))
                    for (const V of Be.prev(P, Et))
                        V.classList.add($e)
        }
        _clearActiveClass(v) {
            v.classList.remove($e);
            const P = Be.find(`${Rt}.${$e}`, v);
            for (const V of P)
                V.classList.remove($e)
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = ea.getOrCreateInstance(this, v);
                if ("string" == typeof v) {
                    if (void 0 === P[v] || v.startsWith("_") || "constructor" === v)
                        throw new TypeError(`No method named "${v}"`);
                    P[v]()
                }
            })
        }
    }
    ye.on(window, li, () => {
        for (const G of Be.find('[data-bs-spy="scroll"]'))
            ea.getOrCreateInstance(G)
    }
    ),
    _e(ea);
    const wi = ".bs.tab"
      , Oa = `hide${wi}`
      , ta = `hidden${wi}`
      , Ga = `show${wi}`
      , ma = `shown${wi}`
      , Aa = `click${wi}`
      , Sa = `keydown${wi}`
      , Ha = `load${wi}`
      , Ca = "ArrowLeft"
      , Ta = "ArrowRight"
      , za = "ArrowUp"
      , _a = "ArrowDown"
      , Ea = "Home"
      , z = "End"
      , Z = "active"
      , de = "show"
      , be = ".dropdown-toggle"
      , ze = `:not(${be})`
      , Ne = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'
      , je = `.nav-link${ze}, .list-group-item${ze}, [role="tab"]${ze}, ${Ne}`
      , Xe = `.${Z}[data-bs-toggle="tab"], .${Z}[data-bs-toggle="pill"], .${Z}[data-bs-toggle="list"]`;
    class ct extends Ft {
        constructor(v) {
            super(v),
            this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'),
            this._parent && (this._setInitialAttributes(this._parent, this._getChildren()),
            ye.on(this._element, Sa, P => this._keydown(P)))
        }
        static get NAME() {
            return "tab"
        }
        show() {
            const v = this._element;
            if (this._elemIsActive(v))
                return;
            const P = this._getActiveElem()
              , V = P ? ye.trigger(P, Oa, {
                relatedTarget: v
            }) : null;
            ye.trigger(v, Ga, {
                relatedTarget: P
            }).defaultPrevented || V && V.defaultPrevented || (this._deactivate(P, v),
            this._activate(v, P))
        }
        _activate(v, P) {
            v && (v.classList.add(Z),
            this._activate(Be.getElementFromSelector(v)),
            this._queueCallback( () => {
                "tab" === v.getAttribute("role") ? (v.removeAttribute("tabindex"),
                v.setAttribute("aria-selected", !0),
                this._toggleDropDown(v, !0),
                ye.trigger(v, ma, {
                    relatedTarget: P
                })) : v.classList.add(de)
            }
            , v, v.classList.contains("fade")))
        }
        _deactivate(v, P) {
            v && (v.classList.remove(Z),
            v.blur(),
            this._deactivate(Be.getElementFromSelector(v)),
            this._queueCallback( () => {
                "tab" === v.getAttribute("role") ? (v.setAttribute("aria-selected", !1),
                v.setAttribute("tabindex", "-1"),
                this._toggleDropDown(v, !1),
                ye.trigger(v, ta, {
                    relatedTarget: P
                })) : v.classList.remove(de)
            }
            , v, v.classList.contains("fade")))
        }
        _keydown(v) {
            if (![Ca, Ta, za, _a, Ea, z].includes(v.key))
                return;
            v.stopPropagation(),
            v.preventDefault();
            const P = this._getChildren().filter(Ae => !He(Ae));
            let V;
            if ([Ea, z].includes(v.key))
                V = P[v.key === Ea ? 0 : P.length - 1];
            else {
                const Ae = [Ta, _a].includes(v.key);
                V = he(P, v.target, Ae, !0)
            }
            V && (V.focus({
                preventScroll: !0
            }),
            ct.getOrCreateInstance(V).show())
        }
        _getChildren() {
            return Be.find(je, this._parent)
        }
        _getActiveElem() {
            return this._getChildren().find(v => this._elemIsActive(v)) || null
        }
        _setInitialAttributes(v, P) {
            this._setAttributeIfNotExists(v, "role", "tablist");
            for (const V of P)
                this._setInitialAttributesOnChild(V)
        }
        _setInitialAttributesOnChild(v) {
            v = this._getInnerElement(v);
            const P = this._elemIsActive(v)
              , V = this._getOuterElement(v);
            v.setAttribute("aria-selected", P),
            V !== v && this._setAttributeIfNotExists(V, "role", "presentation"),
            P || v.setAttribute("tabindex", "-1"),
            this._setAttributeIfNotExists(v, "role", "tab"),
            this._setInitialAttributesOnTargetPanel(v)
        }
        _setInitialAttributesOnTargetPanel(v) {
            const P = Be.getElementFromSelector(v);
            P && (this._setAttributeIfNotExists(P, "role", "tabpanel"),
            v.id && this._setAttributeIfNotExists(P, "aria-labelledby", `${v.id}`))
        }
        _toggleDropDown(v, P) {
            const V = this._getOuterElement(v);
            if (!V.classList.contains("dropdown"))
                return;
            const Ae = (Me, Ve) => {
                const ft = Be.findOne(Me, V);
                ft && ft.classList.toggle(Ve, P)
            }
            ;
            Ae(be, Z),
            Ae(".dropdown-menu", de),
            V.setAttribute("aria-expanded", P)
        }
        _setAttributeIfNotExists(v, P, V) {
            v.hasAttribute(P) || v.setAttribute(P, V)
        }
        _elemIsActive(v) {
            return v.classList.contains(Z)
        }
        _getInnerElement(v) {
            return v.matches(je) ? v : Be.findOne(je, v)
        }
        _getOuterElement(v) {
            return v.closest(".nav-item, .list-group-item") || v
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = ct.getOrCreateInstance(this);
                if ("string" == typeof v) {
                    if (void 0 === P[v] || v.startsWith("_") || "constructor" === v)
                        throw new TypeError(`No method named "${v}"`);
                    P[v]()
                }
            })
        }
    }
    ye.on(document, Aa, Ne, function(G) {
        ["A", "AREA"].includes(this.tagName) && G.preventDefault(),
        He(this) || ct.getOrCreateInstance(this).show()
    }),
    ye.on(window, Ha, () => {
        for (const G of Be.find(Xe))
            ct.getOrCreateInstance(G)
    }
    ),
    _e(ct);
    const Je = ".bs.toast"
      , ot = `mouseover${Je}`
      , ut = `mouseout${Je}`
      , et = `focusin${Je}`
      , jt = `focusout${Je}`
      , si = `hide${Je}`
      , $t = `hidden${Je}`
      , ui = `show${Je}`
      , ki = `shown${Je}`
      , bt = "show"
      , Wi = "showing"
      , Ii = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    }
      , La = {
        animation: !0,
        autohide: !0,
        delay: 5e3
    };
    class ua extends Ft {
        constructor(v, P) {
            super(v, P),
            this._timeout = null,
            this._hasMouseInteraction = !1,
            this._hasKeyboardInteraction = !1,
            this._setListeners()
        }
        static get Default() {
            return La
        }
        static get DefaultType() {
            return Ii
        }
        static get NAME() {
            return "toast"
        }
        show() {
            ye.trigger(this._element, ui).defaultPrevented || (this._clearTimeout(),
            this._config.animation && this._element.classList.add("fade"),
            this._element.classList.remove("hide"),
            this._element.classList.add(bt, Wi),
            this._queueCallback( () => {
                this._element.classList.remove(Wi),
                ye.trigger(this._element, ki),
                this._maybeScheduleHide()
            }
            , this._element, this._config.animation))
        }
        hide() {
            this.isShown() && (ye.trigger(this._element, si).defaultPrevented || (this._element.classList.add(Wi),
            this._queueCallback( () => {
                this._element.classList.add("hide"),
                this._element.classList.remove(Wi, bt),
                ye.trigger(this._element, $t)
            }
            , this._element, this._config.animation)))
        }
        dispose() {
            this._clearTimeout(),
            this.isShown() && this._element.classList.remove(bt),
            super.dispose()
        }
        isShown() {
            return this._element.classList.contains(bt)
        }
        _maybeScheduleHide() {
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout( () => {
                this.hide()
            }
            , this._config.delay)))
        }
        _onInteraction(v, P) {
            switch (v.type) {
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = P;
                break;
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = P
            }
            if (P)
                return void this._clearTimeout();
            const V = v.relatedTarget;
            this._element === V || this._element.contains(V) || this._maybeScheduleHide()
        }
        _setListeners() {
            ye.on(this._element, ot, v => this._onInteraction(v, !0)),
            ye.on(this._element, ut, v => this._onInteraction(v, !1)),
            ye.on(this._element, et, v => this._onInteraction(v, !0)),
            ye.on(this._element, jt, v => this._onInteraction(v, !1))
        }
        _clearTimeout() {
            clearTimeout(this._timeout),
            this._timeout = null
        }
        static jQueryInterface(v) {
            return this.each(function() {
                const P = ua.getOrCreateInstance(this, v);
                if ("string" == typeof v) {
                    if (void 0 === P[v])
                        throw new TypeError(`No method named "${v}"`);
                    P[v](this)
                }
            })
        }
    }
    return Jt(ua),
    _e(ua),
    {
        Alert: Ai,
        Button: fi,
        Carousel: tt,
        Collapse: Ei,
        Dropdown: _,
        Modal: Pi,
        Offcanvas: ge,
        Popover: Xt,
        ScrollSpy: ea,
        Tab: ct,
        Toast: ua,
        Tooltip: di
    }
}),
function($, K, Ke) {
    var Q = {
        nojQuery: "jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.",
        noTransportOnInit: "No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.",
        errorOnNegotiate: "Error during negotiation request.",
        stoppedWhileLoading: "The connection was stopped during page load.",
        stoppedWhileNegotiating: "The connection was stopped during the negotiate request.",
        errorParsingNegotiateResponse: "Error parsing negotiate response.",
        errorRedirectionExceedsLimit: "Negotiate redirection limit exceeded.",
        errorDuringStartRequest: "Error during start request. Stopping the connection.",
        errorFromServer: "Error message received from the server: '{0}'.",
        stoppedDuringStartRequest: "The connection was stopped during the start request.",
        errorParsingStartResponse: "Error parsing start response: '{0}'. Stopping the connection.",
        invalidStartResponse: "Invalid start response: '{0}'. Stopping the connection.",
        protocolIncompatible: "You are using a version of the client that isn't compatible with the server. Client version {0}, server version {1}.",
        aspnetCoreSignalrServer: "Detected a connection attempt to an ASP.NET Core SignalR Server. This client only supports connecting to an ASP.NET SignalR Server. See https://aka.ms/signalr-core-differences for details.",
        sendFailed: "Send failed.",
        parseFailed: "Failed at parsing response: {0}",
        longPollFailed: "Long polling request failed.",
        eventSourceFailedToConnect: "EventSource failed to connect.",
        eventSourceError: "Error raised by EventSource",
        webSocketClosed: "WebSocket closed.",
        pingServerFailedInvalidResponse: "Invalid ping response when pinging server: '{0}'.",
        pingServerFailed: "Failed to ping server.",
        pingServerFailedStatusCode: "Failed to ping server.  Server responded with status code {0}, stopping the connection.",
        pingServerFailedParse: "Failed to parse ping server response, stopping the connection.",
        noConnectionTransport: "Connection is in an invalid state, there is no transport active.",
        webSocketsInvalidState: "The Web Socket transport is in an invalid state, transitioning into reconnecting.",
        reconnectTimeout: "Couldn't reconnect within the configured timeout of {0} ms, disconnecting.",
        reconnectWindowTimeout: "The client has been inactive since {0} and it has exceeded the inactivity timeout of {1} ms. Stopping the connection.",
        jsonpNotSupportedWithAccessToken: "The JSONP protocol does not support connections that require a Bearer token to connect, such as the Azure SignalR Service."
    };
    if ("function" != typeof $)
        throw new Error(Q.nojQuery);
    var we, Te, ae, he, Re = "complete" === K.document.readyState, pe = $(K), ie = "__Negotiate Aborted__", re = {
        onStart: "onStart",
        onStarting: "onStarting",
        onReceived: "onReceived",
        onError: "onError",
        onConnectionSlow: "onConnectionSlow",
        onReconnecting: "onReconnecting",
        onReconnect: "onReconnect",
        onStateChanged: "onStateChanged",
        onDisconnect: "onDisconnect"
    }, F = function(ae, he, m) {
        return he === ae.state && (ae.state = m,
        $(ae).triggerHandler(re.onStateChanged, [{
            oldState: he,
            newState: m
        }]),
        !0)
    }, Y = function(ae) {
        return ae._.keepAliveData.activated && ae.transport.supportsKeepAlive(ae)
    };
    function _e(ae, he) {
        return he.match(/:\d+$/) ? he : he + ":" + function Se(ae) {
            return "http:" === ae ? 80 : "https:" === ae ? 443 : void 0
        }(ae)
    }
    function U(ae, he) {
        var m = this
          , Ce = [];
        m.tryBuffer = function(qe) {
            return ae.state === $.signalR.connectionState.connecting && (Ce.push(qe),
            !0)
        }
        ,
        m.drain = function() {
            if (ae.state === $.signalR.connectionState.connected)
                for (; Ce.length > 0; )
                    he(Ce.shift())
        }
        ,
        m.clear = function() {
            Ce = []
        }
    }
    we = function(ae, he, m) {
        return new we.fn.init(ae,he,m)
    }
    ,
    we._ = {
        defaultContentType: "application/x-www-form-urlencoded; charset=UTF-8",
        ieVersion: ("Microsoft Internet Explorer" === K.navigator.appName && (he = /MSIE ([0-9]+\.[0-9]+)/.exec(K.navigator.userAgent)) && (ae = K.parseFloat(he[1])),
        ae),
        error: function(ae, he, m) {
            var Ce = new Error(ae);
            return Ce.source = he,
            typeof m < "u" && (Ce.context = m),
            Ce
        },
        transportError: function(ae, he, m, Ce) {
            var qe = this.error(ae, m, Ce);
            return qe.transport = he ? he.name : void 0,
            qe
        },
        format: function() {
            for (var ae = arguments[0], he = 0; he < arguments.length - 1; he++)
                ae = ae.replace("{" + he + "}", arguments[he + 1]);
            return ae
        },
        firefoxMajorVersion: function(ae) {
            var he = ae.match(/Firefox\/(\d+)/);
            return !he || !he.length || he.length < 2 ? 0 : parseInt(he[1], 10)
        },
        configurePingInterval: function(ae) {
            var he = ae._.config
              , m = function(Ce) {
                $(ae).triggerHandler(re.onError, [Ce])
            };
            he && !ae._.pingIntervalId && he.pingInterval && (ae._.pingIntervalId = K.setInterval(function() {
                we.transports._logic.pingServer(ae).fail(m)
            }, he.pingInterval))
        }
    },
    we.events = re,
    we.resources = Q,
    we.ajaxDefaults = {
        processData: !0,
        timeout: null,
        async: !0,
        global: !1,
        cache: !1
    },
    we.changeState = F,
    we.isDisconnecting = function(ae) {
        return ae.state === we.connectionState.disconnected
    }
    ,
    we.connectionState = {
        connecting: 0,
        connected: 1,
        reconnecting: 2,
        disconnected: 4
    },
    we.hub = {
        start: function() {
            throw new Error("SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/js'><\/script>.")
        }
    },
    "function" == typeof pe.on ? pe.on("load", function() {
        Re = !0
    }) : pe.load(function() {
        Re = !0
    }),
    we.fn = we.prototype = {
        init: function(ae, he, m) {
            var Ce = $(this);
            this.url = ae,
            this.qs = he,
            this.lastError = null,
            this._ = {
                keepAliveData: {},
                connectingMessageBuffer: new U(this,function(qe) {
                    Ce.triggerHandler(re.onReceived, [qe])
                }
                ),
                lastMessageAt: (new Date).getTime(),
                lastActiveAt: (new Date).getTime(),
                beatInterval: 5e3,
                beatHandle: null,
                totalTransportConnectTimeout: 0,
                redirectQs: null
            },
            "boolean" == typeof m && (this.logging = m)
        },
        _parseResponse: function(ae) {
            return ae && ("string" == typeof ae ? this.json.parse(ae) : ae)
        },
        _originalJson: K.JSON,
        json: K.JSON,
        isCrossDomain: function(ae, he) {
            var m;
            return ae = $.trim(ae),
            he = he || K.location,
            0 === ae.indexOf("http") && ((m = K.document.createElement("a")).href = ae,
            m.protocol + _e(m.protocol, m.host) !== he.protocol + _e(he.protocol, he.host))
        },
        ajaxDataType: "text",
        contentType: "application/json; charset=UTF-8",
        logging: !1,
        state: we.connectionState.disconnected,
        clientProtocol: "2.1",
        supportedProtocols: ["1.5", "2.0", "2.1"],
        negotiateRedirectSupportedProtocols: ["2.0", "2.1"],
        reconnectDelay: 2e3,
        transportConnectTimeout: 0,
        disconnectTimeout: 3e4,
        reconnectWindow: 3e4,
        keepAliveWarnAt: 2 / 3,
        start: function(ae, he) {
            var qe, m = this, Ce = {
                pingInterval: 3e5,
                waitForPageLoad: !0,
                transport: "auto",
                jsonp: !1
            }, gt = m._deferral || $.Deferred(), kt = K.document.createElement("a"), Kt = function(Oe, pt) {
                Oe.url === pt && Oe.baseUrl || (Oe.url = pt,
                kt.href = Oe.url,
                kt.protocol && ":" !== kt.protocol ? (Oe.protocol = kt.protocol,
                Oe.host = kt.host) : (Oe.protocol = K.document.location.protocol,
                Oe.host = kt.host || K.document.location.host),
                Oe.baseUrl = Oe.protocol + "//" + Oe.host,
                Oe.wsProtocol = "https:" === Oe.protocol ? "wss://" : "ws://",
                0 === Oe.url.indexOf("//") && (Oe.url = K.location.protocol + Oe.url,
                Oe.log("Protocol relative URL detected, normalizing it to '" + Oe.url + "'.")),
                Oe.isCrossDomain(Oe.url) && (Oe.log("Auto detected cross domain url."),
                "auto" === Ce.transport && (Ce.transport = ["webSockets", "serverSentEvents", "longPolling"]),
                typeof Oe.withCredentials > "u" && (Oe.withCredentials = !0),
                $.support.cors || (Oe.ajaxDataType = "jsonp",
                Oe.log("Using jsonp because this browser doesn't support CORS.")),
                Oe.contentType = we._.defaultContentType))
            };
            if (m.lastError = null,
            m._deferral = gt,
            !m.json)
                throw new Error("SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.");
            if ("function" === $.type(ae) ? he = ae : "object" === $.type(ae) && ($.extend(Ce, ae),
            "function" === $.type(Ce.callback) && (he = Ce.callback)),
            Ce.transport = function D(ae, he) {
                if ($.isArray(ae)) {
                    for (var m = ae.length - 1; m >= 0; m--) {
                        var Ce = ae[m];
                        ("string" !== $.type(Ce) || !we.transports[Ce]) && (he.log("Invalid transport: " + Ce + ", removing it from the transports list."),
                        ae.splice(m, 1))
                    }
                    0 === ae.length && (he.log("No transports remain within the specified transport array."),
                    ae = null)
                } else if (we.transports[ae] || "auto" === ae) {
                    if ("auto" === ae && we._.ieVersion <= 8)
                        return ["longPolling"]
                } else
                    he.log("Invalid transport: " + ae.toString() + "."),
                    ae = null;
                return ae
            }(Ce.transport, m),
            !Ce.transport)
                throw new Error("SignalR: Invalid transport(s) specified, aborting start.");
            if (m._.config = Ce,
            !Re && !0 === Ce.waitForPageLoad)
                return m._.deferredStartHandler = function() {
                    m.start(ae, he)
                }
                ,
                pe.bind("load", m._.deferredStartHandler),
                gt.promise();
            if (m.state === we.connectionState.connecting)
                return gt.promise();
            if (!1 === F(m, we.connectionState.disconnected, we.connectionState.connecting))
                return gt.resolve(m),
                gt.promise();
            (function(ae) {
                var he, m;
                ae._.configuredStopReconnectingTimeout || (m = function(Ce) {
                    var qe = we._.format(we.resources.reconnectTimeout, Ce.disconnectTimeout);
                    Ce.log(qe),
                    $(Ce).triggerHandler(re.onError, [we._.error(qe, "TimeoutException")]),
                    Ce.stop(!1, !1)
                }
                ,
                ae.reconnecting(function() {
                    var Ce = this;
                    Ce.state === we.connectionState.reconnecting && (he = K.setTimeout(function() {
                        m(Ce)
                    }, Ce.disconnectTimeout))
                }),
                ae.stateChanged(function(Ce) {
                    Ce.oldState === we.connectionState.reconnecting && K.clearTimeout(he)
                }),
                ae._.configuredStopReconnectingTimeout = !0)
            }
            )(m),
            "auto" === Ce.transport && !0 === Ce.jsonp && (Ce.transport = "longPolling"),
            m.withCredentials = Ce.withCredentials,
            m._originalUrl = m.url,
            m.ajaxDataType = Ce.jsonp ? "jsonp" : "text",
            Kt(m, m.url),
            $(m).bind(re.onStart, function(Oe, pt) {
                "function" === $.type(he) && he.call(m),
                gt.resolve(m)
            }),
            m._.initHandler = we.transports._logic.initHandler(m),
            qe = function(Oe, pt) {
                var xt = we._.error(Q.noTransportOnInit);
                if ((pt = pt || 0) >= Oe.length)
                    return m.log(0 === pt ? "No transports supported by the server were selected." : 1 === pt ? "No fallback transports were selected." : "Fallback transports exhausted."),
                    $(m).triggerHandler(re.onError, [xt]),
                    gt.reject(xt),
                    void m.stop();
                if (m.state !== we.connectionState.disconnected) {
                    var yt = we.transports[Oe[pt]]
                      , ri = function() {
                        qe(Oe, pt + 1)
                    };
                    m.transport = yt;
                    try {
                        m._.initHandler.start(yt, function() {
                            var wt = we._.firefoxMajorVersion(K.navigator.userAgent) >= 11;
                            m.log("The start request succeeded. Transitioning to the connected state."),
                            Y(m) && we.transports._logic.monitorKeepAlive(m),
                            m._.keepAliveData.activated && we.transports._logic.startHeartbeat(m),
                            we._.configurePingInterval(m),
                            F(m, we.connectionState.connecting, we.connectionState.connected) || m.log("WARNING! The connection was not in the connecting state."),
                            m._.connectingMessageBuffer.drain(),
                            $(m).triggerHandler(re.onStart),
                            pe.bind("unload", function() {
                                m.log("Window unloading, stopping the connection."),
                                m.stop(!0)
                            }),
                            wt && pe.bind("beforeunload", function() {
                                K.setTimeout(function() {
                                    m.stop(!0)
                                }, 0)
                            })
                        }, ri)
                    } catch (wt) {
                        m.log(yt.name + " transport threw '" + wt.message + "' when attempting to start."),
                        ri()
                    }
                }
            }
            ;
            var Oe, St, yt, pt, ri, wt, ye, gi, We = m.url + "/negotiate", At = function(Oe, pt) {
                var xt = we._.error(Q.errorOnNegotiate, Oe, pt._.negotiateRequest);
                $(pt).triggerHandler(re.onError, xt),
                gt.reject(xt),
                pt.stop()
            };
            return $(m).triggerHandler(re.onStarting),
            We = we.transports._logic.prepareQueryString(m, We),
            m.log("Negotiating with '" + We + "'."),
            m._.negotiateRequest = (pt = 0,
            ri = [],
            wt = [],
            gi = function(It) {
                try {
                    Oe = m._parseResponse(It)
                } catch (Ct) {
                    return void At(we._.error(Q.errorParsingNegotiateResponse, Ct), m)
                }
                if (Oe.availableTransports)
                    return yt = we._.error(Q.aspnetCoreSignalrServer),
                    $(m).triggerHandler(re.onError, [yt]),
                    void gt.reject(yt);
                if (!Oe.ProtocolVersion || -1 === m.supportedProtocols.indexOf(Oe.ProtocolVersion))
                    return yt = we._.error(we._.format(Q.protocolIncompatible, m.clientProtocol, Oe.ProtocolVersion)),
                    $(m).triggerHandler(re.onError, [yt]),
                    void gt.reject(yt);
                if (-1 !== m.negotiateRedirectSupportedProtocols.indexOf(Oe.ProtocolVersion)) {
                    if (Oe.Error)
                        return yt = we._.error(we._.format(Q.errorFromServer, Oe.Error)),
                        $(m).triggerHandler(re.onError, [yt]),
                        void gt.reject(yt);
                    if (Oe.RedirectUrl) {
                        if (100 === pt)
                            return void At(we._.error(Q.errorRedirectionExceedsLimit), m);
                        "auto" === Ce.transport && (Ce.transport = ["webSockets", "serverSentEvents", "longPolling"]),
                        m.log("Received redirect to: " + Oe.RedirectUrl),
                        m.accessToken = Oe.AccessToken;
                        var Lt = Oe.RedirectUrl.split("?", 2);
                        return Kt(m, Lt[0]),
                        m._.redirectQs = 2 === Lt.length ? Lt[1] : null,
                        "jsonp" === m.ajaxDataType && m.accessToken ? void At(we._.error(Q.jsonpNotSupportedWithAccessToken), m) : (pt++,
                        void ye(m, gi))
                    }
                }
                St = m._.keepAliveData,
                m.appRelativeUrl = Oe.Url,
                m.id = Oe.ConnectionId,
                m.token = Oe.ConnectionToken,
                m.webSocketServerUrl = Oe.WebSocketServerUrl,
                m._.pollTimeout = 1e3 * Oe.ConnectionTimeout + 1e4,
                m.disconnectTimeout = 1e3 * Oe.DisconnectTimeout,
                m._.totalTransportConnectTimeout = m.transportConnectTimeout + 1e3 * Oe.TransportConnectTimeout,
                Oe.KeepAliveTimeout ? (St.activated = !0,
                St.timeout = 1e3 * Oe.KeepAliveTimeout,
                St.timeoutWarning = St.timeout * m.keepAliveWarnAt,
                m._.beatInterval = (St.timeout - St.timeoutWarning) / 3) : St.activated = !1,
                m.reconnectWindow = m.disconnectTimeout + (St.timeout || 0),
                $.each(we.transports, function(Ct) {
                    if (0 === Ct.indexOf("_") || "webSockets" === Ct && !Oe.TryWebSockets)
                        return !0;
                    wt.push(Ct)
                }),
                $.isArray(Ce.transport) ? $.each(Ce.transport, function(Ct, Mt) {
                    $.inArray(Mt, wt) >= 0 && ri.push(Mt)
                }) : "auto" === Ce.transport ? ri = wt : $.inArray(Ce.transport, wt) >= 0 && ri.push(Ce.transport),
                qe(ri)
            }
            ,
            (ye = function(It, Lt) {
                var Ct = we.transports._logic.prepareQueryString(It, It.url + "/negotiate");
                It.log("Negotiating with '" + Ct + "'.");
                var Mt = {
                    url: Ct,
                    error: function(Ft, Ot) {
                        Ot !== ie ? At(Ft, It) : gt.reject(we._.error(Q.stoppedWhileNegotiating, null, It._.negotiateRequest))
                    },
                    success: Lt
                };
                return It.accessToken && (Mt.headers = {
                    Authorization: "Bearer " + It.accessToken
                }),
                we.transports._logic.ajax(It, Mt)
            }
            )(m, gi)),
            gt.promise()
        },
        starting: function(ae) {
            var he = this;
            return $(he).bind(re.onStarting, function(m, Ce) {
                ae.call(he)
            }),
            he
        },
        send: function(ae) {
            var he = this;
            if (he.state === we.connectionState.disconnected)
                throw new Error("SignalR: Connection must be started before data can be sent. Call .start() before .send()");
            if (he.state === we.connectionState.connecting)
                throw new Error("SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.");
            return he.transport.send(he, ae),
            he
        },
        received: function(ae) {
            var he = this;
            return $(he).bind(re.onReceived, function(m, Ce) {
                ae.call(he, Ce)
            }),
            he
        },
        stateChanged: function(ae) {
            var he = this;
            return $(he).bind(re.onStateChanged, function(m, Ce) {
                ae.call(he, Ce)
            }),
            he
        },
        error: function(ae) {
            var he = this;
            return $(he).bind(re.onError, function(m, Ce, qe) {
                he.lastError = Ce,
                ae.call(he, Ce, qe)
            }),
            he
        },
        disconnected: function(ae) {
            var he = this;
            return $(he).bind(re.onDisconnect, function(m, Ce) {
                ae.call(he)
            }),
            he
        },
        connectionSlow: function(ae) {
            var he = this;
            return $(he).bind(re.onConnectionSlow, function(m, Ce) {
                ae.call(he)
            }),
            he
        },
        reconnecting: function(ae) {
            var he = this;
            return $(he).bind(re.onReconnecting, function(m, Ce) {
                ae.call(he)
            }),
            he
        },
        reconnected: function(ae) {
            var he = this;
            return $(he).bind(re.onReconnect, function(m, Ce) {
                ae.call(he)
            }),
            he
        },
        stop: function(ae, he) {
            var m = this
              , Ce = m._deferral;
            return m._.deferredStartHandler && pe.unbind("load", m._.deferredStartHandler),
            delete m._.config,
            delete m._.deferredStartHandler,
            Re || m._.config && !0 !== m._.config.waitForPageLoad ? m.state !== we.connectionState.disconnected ? (m.log("Stopping connection."),
            K.clearTimeout(m._.beatHandle),
            K.clearInterval(m._.pingIntervalId),
            m.transport && (m.transport.stop(m),
            !1 !== he && m.transport.abort(m, ae),
            Y(m) && we.transports._logic.stopMonitoringKeepAlive(m),
            m.transport = null),
            m._.negotiateRequest && (m._.negotiateRequest.abort(ie),
            delete m._.negotiateRequest),
            m._.initHandler && m._.initHandler.stop(),
            delete m._deferral,
            delete m.messageId,
            delete m.groupsToken,
            delete m.id,
            delete m._.pingIntervalId,
            delete m._.lastMessageAt,
            delete m._.lastActiveAt,
            m._.connectingMessageBuffer.clear(),
            $(m).unbind(re.onStart),
            delete m.accessToken,
            delete m.protocol,
            delete m.host,
            delete m.baseUrl,
            delete m.wsProtocol,
            delete m.contentType,
            m.url = m._originalUrl,
            m._.redirectQs = null,
            F(m, m.state, we.connectionState.disconnected),
            $(m).triggerHandler(re.onDisconnect),
            m) : void 0 : (m.log("Stopping connection prior to negotiate."),
            void (Ce && Ce.reject(we._.error(Q.stoppedWhileLoading))))
        },
        log: function(ae) {
            !function(ae, he) {
                var m;
                !1 !== he && (typeof K.console > "u" || (m = "[" + (new Date).toTimeString() + "] SignalR: " + ae,
                K.console.debug ? K.console.debug(m) : K.console.log && K.console.log(m)))
            }(ae, this.logging)
        }
    },
    we.fn.init.prototype = we.fn,
    we.noConflict = function() {
        return $.connection === we && ($.connection = Te),
        we
    }
    ,
    $.connection && (Te = $.connection),
    $.connection = $.signalR = we
}(window.jQuery, window),
function($, K, Ke) {
    var pe, Q = $.signalR, we = $.signalR.events, Te = $.signalR.changeState, Re = "__Start Aborted__";
    function ie(F) {
        F._.keepAliveData.monitoring && function re(F) {
            var Y, J = F._.keepAliveData;
            F.state === Q.connectionState.connected && ((Y = (new Date).getTime() - F._.lastMessageAt) >= J.timeout ? (F.log("Keep alive timed out.  Notifying transport that connection has been lost."),
            F.transport.lostConnection(F)) : Y >= J.timeoutWarning ? J.userNotified || (F.log("Keep alive has been missed, connection may be dead/slow."),
            $(F).triggerHandler(we.onConnectionSlow),
            J.userNotified = !0) : J.userNotified = !1)
        }(F),
        pe.markActive(F) && (F._.beatHandle = K.setTimeout(function() {
            ie(F)
        }, F._.beatInterval))
    }
    function De(F, J) {
        var Y = F.url + J;
        return F.transport && (Y += "?transport=" + F.transport.name),
        pe.prepareQueryString(F, Y)
    }
    function He(F) {
        this.connection = F,
        this.startRequested = !1,
        this.startCompleted = !1,
        this.connectionStopped = !1
    }
    Q.transports = {},
    He.prototype = {
        start: function(F, J, Y) {
            var ne = this
              , D = ne.connection
              , Se = !1;
            ne.startRequested || ne.connectionStopped ? D.log("WARNING! " + F.name + " transport cannot be started. Initialization ongoing or completed.") : (D.log(F.name + " transport starting."),
            F.start(D, function() {
                Se || ne.initReceived(F, J)
            }, function(_e) {
                return Se || (Se = !0,
                ne.transportFailed(F, _e, Y)),
                !ne.startCompleted || ne.connectionStopped
            }),
            ne.transportTimeoutHandle = K.setTimeout(function() {
                Se || (Se = !0,
                D.log(F.name + " transport timed out when trying to connect."),
                ne.transportFailed(F, void 0, Y))
            }, D._.totalTransportConnectTimeout))
        },
        stop: function() {
            this.connectionStopped = !0,
            K.clearTimeout(this.transportTimeoutHandle),
            Q.transports._logic.tryAbortStartRequest(this.connection)
        },
        initReceived: function(F, J) {
            var Y = this
              , ne = Y.connection;
            Y.startRequested ? ne.log("WARNING! The client received multiple init messages.") : Y.connectionStopped || (Y.startRequested = !0,
            K.clearTimeout(Y.transportTimeoutHandle),
            ne.log(F.name + " transport connected. Initiating start request."),
            Q.transports._logic.ajaxStart(ne, function() {
                Y.startCompleted = !0,
                J()
            }))
        },
        transportFailed: function(F, J, Y) {
            var Se, ne = this.connection, D = ne._deferral;
            this.connectionStopped || (K.clearTimeout(this.transportTimeoutHandle),
            this.startRequested ? this.startCompleted || (Se = Q._.error(Q.resources.errorDuringStartRequest, J),
            ne.log(F.name + " transport failed during the start request. Stopping the connection."),
            $(ne).triggerHandler(we.onError, [Se]),
            D && D.reject(Se),
            ne.stop()) : (F.stop(ne),
            ne.log(F.name + " transport failed to connect. Attempting to fall back."),
            Y()))
        }
    },
    pe = Q.transports._logic = {
        ajax: function(F, J) {
            return $.ajax($.extend(!0, {}, $.signalR.ajaxDefaults, {
                type: "GET",
                data: {},
                xhrFields: {
                    withCredentials: F.withCredentials
                },
                contentType: F.contentType,
                dataType: F.ajaxDataType
            }, J))
        },
        pingServer: function(F) {
            var J, Y, ne = $.Deferred();
            return F.transport ? (J = pe.addQs(J = F.url + "/ping", F.qs),
            Y = pe.ajax(F, {
                url: J,
                headers: F.accessToken ? {
                    Authorization: "Bearer " + F.accessToken
                } : {},
                success: function(D) {
                    var Se;
                    try {
                        Se = F._parseResponse(D)
                    } catch (_e) {
                        return ne.reject(Q._.transportError(Q.resources.pingServerFailedParse, F.transport, _e, Y)),
                        void F.stop()
                    }
                    "pong" === Se.Response ? ne.resolve() : ne.reject(Q._.transportError(Q._.format(Q.resources.pingServerFailedInvalidResponse, D), F.transport, null, Y))
                },
                error: function(D) {
                    401 === D.status || 403 === D.status ? (ne.reject(Q._.transportError(Q._.format(Q.resources.pingServerFailedStatusCode, D.status), F.transport, D, Y)),
                    F.stop()) : ne.reject(Q._.transportError(Q.resources.pingServerFailed, F.transport, D, Y))
                }
            })) : ne.reject(Q._.transportError(Q.resources.noConnectionTransport, F.transport)),
            ne.promise()
        },
        prepareQueryString: function(F, J) {
            var Y;
            return Y = pe.addQs(J, "clientProtocol=" + F.clientProtocol),
            Y = pe.addQs(Y, "string" == typeof F._.redirectQs ? F._.redirectQs : F.qs),
            F.token && (Y += "&connectionToken=" + K.encodeURIComponent(F.token)),
            F.data && (Y += "&connectionData=" + K.encodeURIComponent(F.data)),
            Y
        },
        addQs: function(F, J) {
            var ne, Y = -1 !== F.indexOf("?") ? "&" : "?";
            if (!J)
                return F;
            if ("object" == typeof J)
                return F + Y + $.param(J);
            if ("string" == typeof J)
                return ("?" === (ne = J.charAt(0)) || "&" === ne) && (Y = ""),
                F + Y + J;
            throw new Error("Query string property must be either a string or object.")
        },
        getUrl: function(F, J, Y, ne, D) {
            var _e = ("webSockets" === J ? "" : F.baseUrl) + F.appRelativeUrl
              , U = "transport=" + J;
            return !D && F.groupsToken && (U += "&groupsToken=" + K.encodeURIComponent(F.groupsToken)),
            Y ? (_e += ne ? "/poll" : "/reconnect",
            !D && F.messageId && (U += "&messageId=" + K.encodeURIComponent(F.messageId))) : _e += "/connect",
            _e = pe.prepareQueryString(F, _e += "?" + U),
            F.transport && F.accessToken && ("serverSentEvents" === F.transport.name || "webSockets" === F.transport.name) && (_e += "&access_token=" + K.encodeURIComponent(F.accessToken)),
            D || (_e += "&tid=" + Math.floor(11 * Math.random())),
            _e
        },
        maximizePersistentResponse: function(F) {
            return {
                MessageId: F.C,
                Messages: F.M,
                Initialized: typeof F.S < "u",
                ShouldReconnect: typeof F.T < "u",
                LongPollDelay: F.L,
                GroupsToken: F.G,
                Error: F.E
            }
        },
        updateGroups: function(F, J) {
            J && (F.groupsToken = J)
        },
        stringifySend: function(F, J) {
            return "string" == typeof J || typeof J > "u" || null === J ? J : F.json.stringify(J)
        },
        ajaxSend: function(F, J) {
            var D, Y = pe.stringifySend(F, J), ne = De(F, "/send"), Se = function(_e, U) {
                $(U).triggerHandler(we.onError, [Q._.transportError(Q.resources.sendFailed, U.transport, _e, D), J])
            };
            return D = pe.ajax(F, {
                url: ne,
                type: "jsonp" === F.ajaxDataType ? "GET" : "POST",
                contentType: Q._.defaultContentType,
                headers: F.accessToken ? {
                    Authorization: "Bearer " + F.accessToken
                } : {},
                data: {
                    data: Y
                },
                success: function(_e) {
                    var U;
                    if (_e) {
                        try {
                            U = F._parseResponse(_e)
                        } catch (ae) {
                            return Se(ae, F),
                            void F.stop()
                        }
                        pe.triggerReceived(F, U)
                    }
                },
                error: function(_e, U) {
                    "abort" === U || "parsererror" === U || Se(_e, F)
                }
            })
        },
        ajaxAbort: function(F, J) {
            if (!(typeof F.transport > "u")) {
                J = typeof J > "u" || J;
                var Y = De(F, "/abort")
                  , ne = F.accessToken ? {
                    Authorization: "Bearer " + F.accessToken
                } : {};
                K.fetch ? K.fetch(Y, {
                    method: "POST",
                    keepalive: !0,
                    headers: ne,
                    credentials: !0 === F.withCredentials ? "include" : "same-origin"
                }) : pe.ajax(F, {
                    url: Y,
                    async: J,
                    timeout: 1e3,
                    type: "POST",
                    headers: ne,
                    dataType: "text"
                }),
                F.log("Fired ajax abort async = " + J + ".")
            }
        },
        ajaxStart: function(F, J) {
            var Y = function(D) {
                var Se = F._deferral;
                Se && Se.reject(D)
            }
              , ne = function(D) {
                F.log("The start request failed. Stopping the connection."),
                $(F).triggerHandler(we.onError, [D]),
                Y(D),
                F.stop()
            };
            F._.startRequest = pe.ajax(F, {
                url: De(F, "/start"),
                headers: F.accessToken ? {
                    Authorization: "Bearer " + F.accessToken
                } : {},
                success: function(D, Se, _e) {
                    var U;
                    try {
                        U = F._parseResponse(D)
                    } catch (ae) {
                        return void ne(Q._.error(Q._.format(Q.resources.errorParsingStartResponse, D), ae, _e))
                    }
                    "started" === U.Response ? J() : ne(Q._.error(Q._.format(Q.resources.invalidStartResponse, D), null, _e))
                },
                error: function(D, Se, _e) {
                    Se !== Re ? ne(Q._.error(Q.resources.errorDuringStartRequest, _e, D)) : (F.log("The start request aborted because connection.stop() was called."),
                    Y(Q._.error(Q.resources.stoppedDuringStartRequest, null, D)))
                }
            })
        },
        tryAbortStartRequest: function(F) {
            F._.startRequest && (F._.startRequest.abort(Re),
            delete F._.startRequest)
        },
        tryInitialize: function(F, J, Y) {
            J.Initialized && Y ? Y() : J.Initialized && F.log("WARNING! The client received an init message after reconnecting.")
        },
        triggerReceived: function(F, J) {
            F._.connectingMessageBuffer.tryBuffer(J) || $(F).triggerHandler(we.onReceived, [J])
        },
        processMessages: function(F, J, Y) {
            var ne;
            if (J && typeof J.I < "u")
                pe.triggerReceived(F, J);
            else if (pe.markLastMessage(F),
            J) {
                if ((ne = pe.maximizePersistentResponse(J)).Error)
                    return F.log("Received an error message from the server: " + J.E),
                    $(F).triggerHandler(Q.events.onError, [Q._.error(J.E, "ServerError")]),
                    void F.stop(!1, !1);
                pe.updateGroups(F, ne.GroupsToken),
                ne.MessageId && (F.messageId = ne.MessageId),
                ne.Messages && ($.each(ne.Messages, function(D, Se) {
                    pe.triggerReceived(F, Se)
                }),
                pe.tryInitialize(F, ne, Y))
            }
        },
        monitorKeepAlive: function(F) {
            var J = F._.keepAliveData;
            J.monitoring ? F.log("Tried to monitor keep alive but it's already being monitored.") : (J.monitoring = !0,
            pe.markLastMessage(F),
            F._.keepAliveData.reconnectKeepAliveUpdate = function() {
                pe.markLastMessage(F)
            }
            ,
            $(F).bind(we.onReconnect, F._.keepAliveData.reconnectKeepAliveUpdate),
            F.log("Now monitoring keep alive with a warning timeout of " + J.timeoutWarning + ", keep alive timeout of " + J.timeout + " and disconnecting timeout of " + F.disconnectTimeout))
        },
        stopMonitoringKeepAlive: function(F) {
            var J = F._.keepAliveData;
            J.monitoring && (J.monitoring = !1,
            $(F).unbind(we.onReconnect, F._.keepAliveData.reconnectKeepAliveUpdate),
            F._.keepAliveData = {},
            F.log("Stopping the monitoring of the keep alive."))
        },
        startHeartbeat: function(F) {
            F._.lastActiveAt = (new Date).getTime(),
            ie(F)
        },
        markLastMessage: function(F) {
            F._.lastMessageAt = (new Date).getTime(),
            F._.lastActiveAt = F._.lastMessageAt
        },
        markActive: function(F) {
            return !!pe.verifyLastActive(F) && (F._.lastActiveAt = (new Date).getTime(),
            !0)
        },
        isConnectedOrReconnecting: function(F) {
            return F.state === Q.connectionState.connected || F.state === Q.connectionState.reconnecting
        },
        ensureReconnectingState: function(F) {
            return !0 === Te(F, Q.connectionState.connected, Q.connectionState.reconnecting) && $(F).triggerHandler(we.onReconnecting),
            F.state === Q.connectionState.reconnecting
        },
        clearReconnectTimeout: function(F) {
            F && F._.reconnectTimeout && (K.clearTimeout(F._.reconnectTimeout),
            delete F._.reconnectTimeout)
        },
        verifyLastActive: function(F) {
            if (!F._.keepAliveData.activated || (new Date).getTime() - F._.lastActiveAt < F.reconnectWindow)
                return !0;
            var J = Q._.format(Q.resources.reconnectWindowTimeout, new Date(F._.lastActiveAt), F.reconnectWindow);
            return F.log(J),
            $(F).triggerHandler(we.onError, [Q._.error(J, "TimeoutException")]),
            F.stop(!1, !1),
            !1
        },
        reconnect: function(F, J) {
            var Y = Q.transports[J];
            if (pe.isConnectedOrReconnecting(F) && !F._.reconnectTimeout) {
                if (!pe.verifyLastActive(F))
                    return;
                F._.reconnectTimeout = K.setTimeout(function() {
                    !pe.verifyLastActive(F) || (Y.stop(F),
                    pe.ensureReconnectingState(F) && (F.log(J + " reconnecting."),
                    Y.start(F)))
                }, F.reconnectDelay)
            }
        },
        handleParseFailure: function(F, J, Y, ne, D) {
            var Se = Q._.transportError(Q._.format(Q.resources.parseFailed, J), F.transport, Y, D);
            ne && ne(Se) ? F.log("Failed to parse server response while attempting to connect.") : ($(F).triggerHandler(we.onError, [Se]),
            F.stop())
        },
        initHandler: function(F) {
            return new He(F)
        },
        foreverFrame: {
            count: 0,
            connections: {}
        }
    }
}(window.jQuery, window),
function($, K, Ke) {
    var Q = $.signalR
      , we = $.signalR.events
      , Te = $.signalR.changeState
      , Re = Q.transports._logic;
    Q.transports.webSockets = {
        name: "webSockets",
        supportsKeepAlive: function() {
            return !0
        },
        send: function(pe, ie) {
            var re = Re.stringifySend(pe, ie);
            try {
                pe.socket.send(re)
            } catch (De) {
                $(pe).triggerHandler(we.onError, [Q._.transportError(Q.resources.webSocketsInvalidState, pe.transport, De, pe.socket), ie])
            }
        },
        start: function(pe, ie, re) {
            var De, He = !1, F = this, J = !ie, Y = $(pe);
            K.WebSocket ? pe.socket || (De = pe.webSocketServerUrl ? pe.webSocketServerUrl : pe.wsProtocol + pe.host,
            De += Re.getUrl(pe, this.name, J),
            pe.log("Connecting to websocket endpoint '" + De + "'."),
            pe.socket = new K.WebSocket(De),
            pe.socket.onopen = function() {
                He = !0,
                pe.log("Websocket opened."),
                Re.clearReconnectTimeout(pe),
                !0 === Te(pe, Q.connectionState.reconnecting, Q.connectionState.connected) && Y.triggerHandler(we.onReconnect)
            }
            ,
            pe.socket.onclose = function(ne) {
                var D;
                this === pe.socket && (He && typeof ne.wasClean < "u" && !1 === ne.wasClean ? (D = Q._.transportError(Q.resources.webSocketClosed, pe.transport, ne),
                pe.log("Unclean disconnect from websocket: " + (ne.reason || "[no reason given]."))) : pe.log("Websocket closed."),
                (!re || !re(D)) && (D && $(pe).triggerHandler(we.onError, [D]),
                F.reconnect(pe)))
            }
            ,
            pe.socket.onmessage = function(ne) {
                var D;
                try {
                    D = pe._parseResponse(ne.data)
                } catch (Se) {
                    return void Re.handleParseFailure(pe, ne.data, Se, re, ne)
                }
                D && Re.processMessages(pe, D, ie)
            }
            ) : re()
        },
        reconnect: function(pe) {
            Re.reconnect(pe, this.name)
        },
        lostConnection: function(pe) {
            this.reconnect(pe)
        },
        stop: function(pe) {
            Re.clearReconnectTimeout(pe),
            pe.socket && (pe.log("Closing the Websocket."),
            pe.socket.close(),
            pe.socket = null)
        },
        abort: function(pe, ie) {
            Re.ajaxAbort(pe, ie)
        }
    }
}(window.jQuery, window),
function($, K, Ke) {
    var Q = $.signalR
      , we = $.signalR.events
      , Te = $.signalR.changeState
      , Re = Q.transports._logic
      , pe = function(ie) {
        K.clearTimeout(ie._.reconnectAttemptTimeoutHandle),
        delete ie._.reconnectAttemptTimeoutHandle
    };
    Q.transports.serverSentEvents = {
        name: "serverSentEvents",
        supportsKeepAlive: function() {
            return !0
        },
        timeOut: 3e3,
        start: function(ie, re, De) {
            var ne, He = this, F = !1, J = $(ie), Y = !re;
            if (ie.eventSource && (ie.log("The connection already has an event source. Stopping it."),
            ie.stop()),
            K.EventSource) {
                ne = Re.getUrl(ie, this.name, Y);
                try {
                    ie.log("Attempting to connect to SSE endpoint '" + ne + "'."),
                    ie.eventSource = new K.EventSource(ne,{
                        withCredentials: ie.withCredentials
                    })
                } catch (D) {
                    return ie.log("EventSource failed trying to connect with error " + D.Message + "."),
                    void (De ? De() : (J.triggerHandler(we.onError, [Q._.transportError(Q.resources.eventSourceFailedToConnect, ie.transport, D)]),
                    Y && He.reconnect(ie)))
                }
                Y && (ie._.reconnectAttemptTimeoutHandle = K.setTimeout(function() {
                    !1 === F && ie.eventSource.readyState !== K.EventSource.OPEN && He.reconnect(ie)
                }, He.timeOut)),
                ie.eventSource.addEventListener("open", function(D) {
                    ie.log("EventSource connected."),
                    pe(ie),
                    Re.clearReconnectTimeout(ie),
                    !1 === F && (F = !0,
                    !0 === Te(ie, Q.connectionState.reconnecting, Q.connectionState.connected) && J.triggerHandler(we.onReconnect))
                }, !1),
                ie.eventSource.addEventListener("message", function(D) {
                    var Se;
                    if ("initialized" !== D.data) {
                        try {
                            Se = ie._parseResponse(D.data)
                        } catch (_e) {
                            return void Re.handleParseFailure(ie, D.data, _e, De, D)
                        }
                        Re.processMessages(ie, Se, re)
                    }
                }, !1),
                ie.eventSource.addEventListener("error", function(D) {
                    var Se = Q._.transportError(Q.resources.eventSourceError, ie.transport, D);
                    this === ie.eventSource && (De && De(Se) || (ie.log("EventSource readyState: " + ie.eventSource.readyState + "."),
                    D.eventPhase === K.EventSource.CLOSED ? (ie.log("EventSource reconnecting due to the server connection ending."),
                    He.reconnect(ie)) : (ie.log("EventSource error."),
                    J.triggerHandler(we.onError, [Se]))))
                }, !1)
            } else
                De && (ie.log("This browser doesn't support SSE."),
                De())
        },
        reconnect: function(ie) {
            Re.reconnect(ie, this.name)
        },
        lostConnection: function(ie) {
            this.reconnect(ie)
        },
        send: function(ie, re) {
            Re.ajaxSend(ie, re)
        },
        stop: function(ie) {
            pe(ie),
            Re.clearReconnectTimeout(ie),
            ie && ie.eventSource && (ie.log("EventSource calling close()."),
            ie.eventSource.close(),
            ie.eventSource = null,
            delete ie.eventSource)
        },
        abort: function(ie, re) {
            Re.ajaxAbort(ie, re)
        }
    }
}(window.jQuery, window),
function($, K, Ke) {
    var re, He, Q = $.signalR, we = $.signalR.events, Te = $.signalR.changeState, Re = Q.transports._logic, pe = function() {
        var re = K.document.createElement("iframe");
        return re.setAttribute("style", "position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;"),
        re
    }, ie = (re = null,
    He = 0,
    {
        prevent: function() {
            Q._.ieVersion <= 8 && (0 === He && (re = K.setInterval(function() {
                var F = pe();
                K.document.body.appendChild(F),
                K.document.body.removeChild(F),
                F = null
            }, 1e3)),
            He++)
        },
        cancel: function() {
            1 === He && K.clearInterval(re),
            He > 0 && He--
        }
    });
    Q.transports.foreverFrame = {
        name: "foreverFrame",
        supportsKeepAlive: function() {
            return !0
        },
        iframeClearThreshold: 50,
        start: function(re, De, He) {
            if (re.accessToken)
                He && (re.log("Forever Frame does not support connections that require a Bearer token to connect, such as the Azure SignalR Service."),
                He());
            else {
                var Y, F = this, J = Re.foreverFrame.count += 1, ne = pe(), D = function() {
                    re.log("Forever frame iframe finished loading and is no longer receiving messages."),
                    (!He || !He()) && F.reconnect(re)
                };
                K.EventSource ? He && (re.log("Forever Frame is not supported by SignalR on browsers with SSE support."),
                He()) : (ne.setAttribute("data-signalr-connection-id", re.id),
                ie.prevent(),
                Y = Re.getUrl(re, this.name),
                Y += "&frameId=" + J,
                K.document.documentElement.appendChild(ne),
                re.log("Binding to iframe's load event."),
                ne.addEventListener ? ne.addEventListener("load", D, !1) : ne.attachEvent && ne.attachEvent("onload", D),
                ne.src = Y,
                Re.foreverFrame.connections[J] = re,
                re.frame = ne,
                re.frameId = J,
                De && (re.onSuccess = function() {
                    re.log("Iframe transport started."),
                    De()
                }
                ))
            }
        },
        reconnect: function(re) {
            var De = this;
            Re.isConnectedOrReconnecting(re) && Re.verifyLastActive(re) && K.setTimeout(function() {
                if (Re.verifyLastActive(re) && re.frame && Re.ensureReconnectingState(re)) {
                    var He = re.frame
                      , F = Re.getUrl(re, De.name, !0) + "&frameId=" + re.frameId;
                    re.log("Updating iframe src to '" + F + "'."),
                    He.src = F
                }
            }, re.reconnectDelay)
        },
        lostConnection: function(re) {
            this.reconnect(re)
        },
        send: function(re, De) {
            Re.ajaxSend(re, De)
        },
        receive: function(re, De) {
            var He, F, J;
            if (re.json !== re._originalJson && (De = re._originalJson.stringify(De)),
            J = re._parseResponse(De),
            Re.processMessages(re, J, re.onSuccess),
            re.state === $.signalR.connectionState.connected && (re.frameMessageCount = (re.frameMessageCount || 0) + 1,
            re.frameMessageCount > Q.transports.foreverFrame.iframeClearThreshold && (re.frameMessageCount = 0,
            (He = re.frame.contentWindow || re.frame.contentDocument) && He.document && He.document.body)))
                for (F = He.document.body; F.firstChild; )
                    F.removeChild(F.firstChild)
        },
        stop: function(re) {
            var De = null;
            if (ie.cancel(),
            re.frame) {
                if (re.frame.stop)
                    re.frame.stop();
                else
                    try {
                        (De = re.frame.contentWindow || re.frame.contentDocument).document && De.document.execCommand && De.document.execCommand("Stop")
                    } catch (He) {
                        re.log("Error occurred when stopping foreverFrame transport. Message = " + He.message + ".")
                    }
                re.frame.parentNode === K.document.documentElement && K.document.documentElement.removeChild(re.frame),
                delete Re.foreverFrame.connections[re.frameId],
                re.frame = null,
                re.frameId = null,
                delete re.frame,
                delete re.frameId,
                delete re.onSuccess,
                delete re.frameMessageCount,
                re.log("Stopping forever frame.")
            }
        },
        abort: function(re, De) {
            Re.ajaxAbort(re, De)
        },
        getConnection: function(re) {
            return Re.foreverFrame.connections[re]
        },
        started: function(re) {
            !0 === Te(re, Q.connectionState.reconnecting, Q.connectionState.connected) && $(re).triggerHandler(we.onReconnect)
        }
    }
}(window.jQuery, window),
function($, K, Ke) {
    var Q = $.signalR
      , we = $.signalR.events
      , Te = $.signalR.changeState
      , Re = $.signalR.isDisconnecting
      , pe = Q.transports._logic;
    Q.transports.longPolling = {
        name: "longPolling",
        supportsKeepAlive: function() {
            return !1
        },
        reconnectDelay: 3e3,
        start: function(ie, re, De) {
            var He = this
              , F = function() {
                F = $.noop,
                ie.log("LongPolling connected."),
                re ? re() : ie.log("WARNING! The client received an init message after reconnecting.")
            }
              , J = function(_e) {
                return !!De(_e) && (ie.log("LongPolling failed to connect."),
                !0)
            }
              , Y = ie._
              , ne = 0
              , D = function(_e) {
                K.clearTimeout(Y.reconnectTimeoutId),
                Y.reconnectTimeoutId = null,
                !0 === Te(_e, Q.connectionState.reconnecting, Q.connectionState.connected) && (_e.log("Raising the reconnect event"),
                $(_e).triggerHandler(we.onReconnect))
            };
            ie.pollXhr && (ie.log("Polling xhr requests already exists, aborting."),
            ie.stop()),
            ie.messageId = null,
            Y.reconnectTimeoutId = null,
            Y.pollTimeoutId = K.setTimeout(function() {
                !function _e(U, ae) {
                    var Ce = !(null === U.messageId)
                      , gt = pe.getUrl(U, He.name, Ce, !ae, !0)
                      , kt = {};
                    U.messageId && (kt.messageId = U.messageId),
                    U.groupsToken && (kt.groupsToken = U.groupsToken),
                    !0 !== Re(U) && (ie.log("Opening long polling request to '" + gt + "'."),
                    U.pollXhr = pe.ajax(ie, {
                        xhrFields: {
                            onprogress: function() {
                                pe.markLastMessage(ie)
                            }
                        },
                        url: gt,
                        type: "POST",
                        contentType: Q._.defaultContentType,
                        data: kt,
                        timeout: ie._.pollTimeout,
                        headers: ie.accessToken ? {
                            Authorization: "Bearer " + ie.accessToken
                        } : {},
                        success: function(Kt) {
                            var We, Oe, pt, At = 0;
                            ie.log("Long poll complete."),
                            ne = 0;
                            try {
                                We = ie._parseResponse(Kt)
                            } catch (xt) {
                                return void pe.handleParseFailure(U, Kt, xt, J, U.pollXhr)
                            }
                            null !== Y.reconnectTimeoutId && D(U),
                            We && (Oe = pe.maximizePersistentResponse(We)),
                            pe.processMessages(U, We, F),
                            Oe && "number" === $.type(Oe.LongPollDelay) && (At = Oe.LongPollDelay),
                            !0 !== Re(U) && (!(pt = Oe && Oe.ShouldReconnect) || pe.ensureReconnectingState(U)) && (At > 0 ? Y.pollTimeoutId = K.setTimeout(function() {
                                _e(U, pt)
                            }, At) : _e(U, pt))
                        },
                        error: function(Kt, We) {
                            var At = Q._.transportError(Q.resources.longPollFailed, ie.transport, Kt, U.pollXhr);
                            if (K.clearTimeout(Y.reconnectTimeoutId),
                            Y.reconnectTimeoutId = null,
                            "abort" !== We) {
                                if (!J(At)) {
                                    if (ne++,
                                    ie.state !== Q.connectionState.reconnecting && (ie.log("An error occurred using longPolling. Status = " + We + ".  Response = " + Kt.responseText + "."),
                                    $(U).triggerHandler(we.onError, [At])),
                                    (ie.state === Q.connectionState.connected || ie.state === Q.connectionState.reconnecting) && !pe.verifyLastActive(ie) || !pe.ensureReconnectingState(U))
                                        return;
                                    Y.pollTimeoutId = K.setTimeout(function() {
                                        _e(U, !0)
                                    }, He.reconnectDelay)
                                }
                            } else
                                ie.log("Aborted xhr request.")
                        }
                    }),
                    Ce && !0 === ae && (Y.reconnectTimeoutId = K.setTimeout(function() {
                        D(U)
                    }, Math.min(1e3 * (Math.pow(2, ne) - 1), 36e5))))
                }(ie)
            }, 250)
        },
        lostConnection: function(ie) {
            ie.pollXhr && ie.pollXhr.abort("lostConnection")
        },
        send: function(ie, re) {
            pe.ajaxSend(ie, re)
        },
        stop: function(ie) {
            K.clearTimeout(ie._.pollTimeoutId),
            K.clearTimeout(ie._.reconnectTimeoutId),
            delete ie._.pollTimeoutId,
            delete ie._.reconnectTimeoutId,
            ie.pollXhr && (ie.pollXhr.abort(),
            ie.pollXhr = null,
            delete ie.pollXhr)
        },
        abort: function(ie, re) {
            pe.ajaxAbort(ie, re)
        }
    }
}(window.jQuery, window),
function($, K, Ke) {
    var Q = 0
      , Te = $.signalR;
    function Re(Y) {
        return Y + ".hubProxy"
    }
    function pe(Y, ne, D) {
        var Se, _e = Y.length, U = [];
        for (Se = 0; Se < _e; Se += 1)
            Y.hasOwnProperty(Se) && (U[Se] = ne.call(D, Y[Se], Se, Y));
        return U
    }
    function ie(Y) {
        return $.isFunction(Y) || "undefined" === $.type(Y) ? null : Y
    }
    function re(Y) {
        for (var ne in Y)
            if (Y.hasOwnProperty(ne))
                return !0;
        return !1
    }
    function De(Y, ne) {
        var Se, D = Y._.invocationCallbacks;
        for (var _e in re(D) && Y.log("Clearing hub invocation callbacks with error: " + ne + "."),
        Y._.invocationCallbackId = 0,
        delete Y._.invocationCallbacks,
        Y._.invocationCallbacks = {},
        D)
            (Se = D[_e]).method.call(Se.scope, {
                E: ne
            })
    }
    function He(Y) {
        return $.isFunction(Y) && Y.toString().slice(0, 256).indexOf("// Call the client hub method") >= 0
    }
    function F(Y, ne) {
        return new F.fn.init(Y,ne)
    }
    function J(Y, ne) {
        var D = {
            qs: null,
            logging: !1,
            useDefaultPath: !0
        };
        return $.extend(D, ne),
        (!Y || D.useDefaultPath) && (Y = (Y || "") + "/signalr"),
        new J.fn.init(Y,D)
    }
    (F.fn = F.prototype = {
        init: function(Y, ne) {
            this.state = {},
            this.connection = Y,
            this.hubName = ne,
            this._ = {
                callbackMap: {}
            }
        },
        constructor: F,
        hasSubscriptions: function() {
            return re(this._.callbackMap)
        },
        on: function(Y, ne, D) {
            var Se = this
              , _e = Se._.callbackMap
              , U = !D && He(ne);
            (D = D || ne)._signalRGuid || (D._signalRGuid = Q++);
            var ae = _e[Y = Y.toLowerCase()];
            ae || (_e[Y] = ae = []);
            for (var he, m = 0; m < ae.length; m++)
                (ae[m].guid === D._signalRGuid || U && ae[m].isFromOldGeneratedHubProxy) && (he = ae[m]);
            he || _e[Y].push(he = {
                guid: D._signalRGuid,
                eventHandlers: [],
                isFromOldGeneratedHubProxy: U
            });
            var Ce = function(qe, gt) {
                ne.apply(Se, gt)
            };
            return he.eventHandlers.push(Ce),
            $(Se).bind(Re(Y), Ce),
            Se
        },
        off: function(Y, ne, D) {
            var U, _e = this._.callbackMap, ae = !D && He(ne);
            if (D = D || ne,
            U = _e[Y = Y.toLowerCase()])
                if (ne) {
                    for (var he, Ce = 0; Ce < U.length; Ce++)
                        (U[Ce].guid === D._signalRGuid || ae && U[Ce].isFromOldGeneratedHubProxy) && (he = U[Ce]);
                    if (he) {
                        for (var qe = 0; qe < he.eventHandlers.length; qe++)
                            $(this).unbind(Re(Y), he.eventHandlers[qe]);
                        U.splice(Ce, 1),
                        0 === U.length && delete _e[Y]
                    }
                } else
                    ne || ($(this).unbind(Re(Y)),
                    delete _e[Y]);
            return this
        },
        invoke: function(Y) {
            var ne = this
              , D = ne.connection
              , Se = $.makeArray(arguments).slice(1)
              , _e = pe(Se, ie)
              , U = {
                H: ne.hubName,
                M: Y,
                A: _e,
                I: D._.invocationCallbackId
            }
              , ae = $.Deferred()
              , he = function(m) {
                var gt, Ce = ne._maximizeHubResponse(m);
                $.extend(ne.state, Ce.State),
                Ce.Progress ? ae.notifyWith ? ae.notifyWith(ne, [Ce.Progress.Data]) : D._.progressjQueryVersionLogged || (D.log("A hub method invocation progress update was received but the version of jQuery in use (" + $.prototype.jquery + ") does not support progress updates. Upgrade to jQuery 1.7+ to receive progress notifications."),
                D._.progressjQueryVersionLogged = !0) : Ce.Error ? (Ce.StackTrace && D.log(Ce.Error + "\n" + Ce.StackTrace + "."),
                (gt = Te._.error(Ce.Error, Ce.IsHubException ? "HubException" : "Exception")).data = Ce.ErrorData,
                D.log(ne.hubName + "." + Y + " failed to execute. Error: " + gt.message),
                ae.rejectWith(ne, [gt])) : (D.log("Invoked " + ne.hubName + "." + Y),
                ae.resolveWith(ne, [Ce.Result]))
            };
            return D._.invocationCallbacks[D._.invocationCallbackId.toString()] = {
                scope: ne,
                method: he
            },
            D._.invocationCallbackId += 1,
            $.isEmptyObject(ne.state) || (U.S = ne.state),
            D.log("Invoking " + ne.hubName + "." + Y),
            D.send(U),
            ae.promise()
        },
        _maximizeHubResponse: function(Y) {
            return {
                State: Y.S,
                Result: Y.R,
                Progress: Y.P ? {
                    Id: Y.P.I,
                    Data: Y.P.D
                } : null,
                Id: Y.I,
                IsHubException: Y.H,
                Error: Y.E,
                StackTrace: Y.T,
                ErrorData: Y.D
            }
        }
    }).init.prototype = F.fn,
    (J.fn = J.prototype = $.connection()).init = function(Y, ne) {
        var D = {
            qs: null,
            logging: !1,
            useDefaultPath: !0
        }
          , Se = this;
        $.extend(D, ne),
        $.signalR.fn.init.call(Se, Y, D.qs, D.logging),
        Se.proxies = {},
        Se._.invocationCallbackId = 0,
        Se._.invocationCallbacks = {},
        Se.received(function(_e) {
            var U, ae, he, m, Ce, qe;
            !_e || (typeof _e.P < "u" ? (he = _e.P.I.toString(),
            (m = Se._.invocationCallbacks[he]) && m.method.call(m.scope, _e)) : typeof _e.I < "u" ? (he = _e.I.toString(),
            (m = Se._.invocationCallbacks[he]) && (Se._.invocationCallbacks[he] = null,
            delete Se._.invocationCallbacks[he],
            m.method.call(m.scope, _e))) : (U = this._maximizeClientHubInvocation(_e),
            Se.log("Triggering client hub event '" + U.Method + "' on hub '" + U.Hub + "'."),
            Ce = U.Hub.toLowerCase(),
            qe = U.Method.toLowerCase(),
            $.extend((ae = this.proxies[Ce]).state, U.State),
            $(ae).triggerHandler(Re(qe), [U.Args])))
        }),
        Se.error(function(_e, U) {
            var ae, he;
            !U || (he = Se._.invocationCallbacks[ae = U.I]) && (Se._.invocationCallbacks[ae] = null,
            delete Se._.invocationCallbacks[ae],
            he.method.call(he.scope, {
                E: _e
            }))
        }),
        Se.reconnecting(function() {
            Se.transport && "webSockets" === Se.transport.name && De(Se, "Connection started reconnecting before invocation result was received.")
        }),
        Se.disconnected(function() {
            De(Se, "Connection was disconnected before invocation result was received.")
        })
    }
    ,
    J.fn._maximizeClientHubInvocation = function(Y) {
        return {
            Hub: Y.H,
            Method: Y.M,
            Args: Y.A,
            State: Y.S
        }
    }
    ,
    J.fn._registerSubscribedHubs = function() {
        var Y = this;
        Y._subscribedToHubs || (Y._subscribedToHubs = !0,
        Y.starting(function() {
            var ne = [];
            $.each(Y.proxies, function(D) {
                this.hasSubscriptions() && (ne.push({
                    name: D
                }),
                Y.log("Client subscribed to hub '" + D + "'."))
            }),
            0 === ne.length && Y.log("No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to."),
            Y.data = Y.json.stringify(ne)
        }))
    }
    ,
    J.fn.createHubProxy = function(Y) {
        Y = Y.toLowerCase();
        var ne = this.proxies[Y];
        return ne || (ne = F(this, Y),
        this.proxies[Y] = ne),
        this._registerSubscribedHubs(),
        ne
    }
    ,
    J.fn.init.prototype = J.fn,
    $.hubConnection = J
}(window.jQuery, window),
window.jQuery.signalR.version = "2.4.3",
function($, K, Ke) {
    "use strict";
    if ("function" != typeof $.signalR)
        throw new Error("SignalR: SignalR is not loaded. Please ensure jquery.signalR-x.js is referenced before ~/signalr/js.");
    var Q = $.signalR;
    function Te(ie, re) {
        return function() {
            re.apply(ie, $.makeArray(arguments))
        }
    }
    function Re(ie, re) {
        var De, He, F, J, Y;
        for (De in ie)
            if (ie.hasOwnProperty(De)) {
                if (!(He = ie[De]).hubName)
                    continue;
                for (F in Y = re ? He.on : He.off,
                He.client)
                    if (He.client.hasOwnProperty(F)) {
                        if (!$.isFunction(J = He.client[F]))
                            continue;
                        Y.call(He, F, Te(He, J), J)
                    }
            }
    }
    $.hubConnection.prototype.createHubProxies = function() {
        var ie = {};
        return this.starting(function() {
            Re(ie, !0),
            this._registerSubscribedHubs()
        }).disconnected(function() {
            Re(ie, !1)
        }),
        ie.dKMHHub = this.createHubProxy("dKMHHub"),
        ie.dKMHHub.client = {},
        ie.dKMHHub.server = {
            themXoaMH: function(re, De) {
                return ie.dKMHHub.invoke.apply(ie.dKMHHub, $.merge(["ThemXoaMH"], $.makeArray(arguments)))
            }
        },
        ie.loginsStat = this.createHubProxy("loginsStat"),
        ie.loginsStat.client = {},
        ie.loginsStat.server = {
            getCurrentStats: function() {
                return ie.loginsStat.invoke.apply(ie.loginsStat, $.merge(["GetCurrentStats"], $.makeArray(arguments)))
            }
        },
        ie.subjectRegister = this.createHubProxy("subjectRegister"),
        ie.subjectRegister.client = {},
        ie.subjectRegister.server = {
            register: function(re) {
                return ie.subjectRegister.invoke.apply(ie.subjectRegister, $.merge(["Register"], $.makeArray(arguments)))
            },
            unRegister: function(re) {
                return ie.subjectRegister.invoke.apply(ie.subjectRegister, $.merge(["UnRegister"], $.makeArray(arguments)))
            }
        },
        ie
    }
    ;
    var pe = function we() {
        var ie = new XMLHttpRequest
          , re = K.location.pathname.toLowerCase().split("/").filter(He => "" !== He && "admin" !== He)
          , De = "/";
        re?.length > 0 && (De = `/${re.join("/")}/`),
        ie.open("GET", `${De}assets/config.json`, !1),
        ie.send(null);
        try {
            return JSON.parse(ie.responseText).apiUrl || De
        } catch {}
        return De
    }();
    Q.hub = $.hubConnection(`${pe}signalr`, {
        useDefaultPath: !1
    }),
    $.extend(Q, Q.hub.createHubProxies())
}(window.jQuery, window),
function($, K) {
    "object" == typeof exports && typeof module < "u" ? module.exports = K() : "function" == typeof define && define.amd ? define(K) : ($ = typeof globalThis < "u" ? globalThis : $ || self).ApexCharts = K()
}(this, function() {
    "use strict";
    function $(C, e) {
        var t = Object.keys(C);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(C);
            e && (i = i.filter(function(a) {
                return Object.getOwnPropertyDescriptor(C, a).enumerable
            })),
            t.push.apply(t, i)
        }
        return t
    }
    function K(C) {
        for (var e = 1; e < arguments.length; e++) {
            var t = null != arguments[e] ? arguments[e] : {};
            e % 2 ? $(Object(t), !0).forEach(function(i) {
                Re(C, i, t[i])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(C, Object.getOwnPropertyDescriptors(t)) : $(Object(t)).forEach(function(i) {
                Object.defineProperty(C, i, Object.getOwnPropertyDescriptor(t, i))
            })
        }
        return C
    }
    function Ke(C) {
        return (Ke = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(C)
    }
    function Q(C, e) {
        if (!(C instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function we(C, e) {
        for (var t = 0; t < e.length; t++) {
            var i = e[t];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(C, i.key, i)
        }
    }
    function Te(C, e, t) {
        return e && we(C.prototype, e),
        t && we(C, t),
        C
    }
    function Re(C, e, t) {
        return e in C ? Object.defineProperty(C, e, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : C[e] = t,
        C
    }
    function pe(C, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Super expression must either be null or a function");
        C.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: C,
                writable: !0,
                configurable: !0
            }
        }),
        e && re(C, e)
    }
    function ie(C) {
        return (ie = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }
        )(C)
    }
    function re(C, e) {
        return (re = Object.setPrototypeOf || function(t, i) {
            return t.__proto__ = i,
            t
        }
        )(C, e)
    }
    function De(C, e) {
        if (e && ("object" == typeof e || "function" == typeof e))
            return e;
        if (void 0 !== e)
            throw new TypeError("Derived constructors may only return object or undefined");
        return function(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(C)
    }
    function He(C) {
        var e = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
                !0
            } catch {
                return !1
            }
        }();
        return function() {
            var t, i = ie(C);
            if (e) {
                var a = ie(this).constructor;
                t = Reflect.construct(i, arguments, a)
            } else
                t = i.apply(this, arguments);
            return De(this, t)
        }
    }
    function F(C, e) {
        return function(t) {
            if (Array.isArray(t))
                return t
        }(C) || function(t, i) {
            var a = null == t ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
            if (null != a) {
                var s, r, n = [], o = !0, h = !1;
                try {
                    for (a = a.call(t); !(o = (s = a.next()).done) && (n.push(s.value),
                    !i || n.length !== i); o = !0)
                        ;
                } catch (d) {
                    h = !0,
                    r = d
                } finally {
                    try {
                        o || null == a.return || a.return()
                    } finally {
                        if (h)
                            throw r
                    }
                }
                return n
            }
        }(C, e) || Y(C, e) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function J(C) {
        return function(e) {
            if (Array.isArray(e))
                return ne(e)
        }(C) || function(e) {
            if (typeof Symbol < "u" && null != e[Symbol.iterator] || null != e["@@iterator"])
                return Array.from(e)
        }(C) || Y(C) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function Y(C, e) {
        if (C) {
            if ("string" == typeof C)
                return ne(C, e);
            var t = Object.prototype.toString.call(C).slice(8, -1);
            return "Object" === t && C.constructor && (t = C.constructor.name),
            "Map" === t || "Set" === t ? Array.from(C) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? ne(C, e) : void 0
        }
    }
    function ne(C, e) {
        (null == e || e > C.length) && (e = C.length);
        for (var t = 0, i = new Array(e); t < e; t++)
            i[t] = C[t];
        return i
    }
    var D = function() {
        function C() {
            Q(this, C)
        }
        return Te(C, [{
            key: "shadeRGBColor",
            value: function(e, t) {
                var i = t.split(",")
                  , a = e < 0 ? 0 : 255
                  , s = e < 0 ? -1 * e : e
                  , r = parseInt(i[0].slice(4), 10)
                  , n = parseInt(i[1], 10)
                  , o = parseInt(i[2], 10);
                return "rgb(" + (Math.round((a - r) * s) + r) + "," + (Math.round((a - n) * s) + n) + "," + (Math.round((a - o) * s) + o) + ")"
            }
        }, {
            key: "shadeHexColor",
            value: function(e, t) {
                var i = parseInt(t.slice(1), 16)
                  , a = e < 0 ? 0 : 255
                  , s = e < 0 ? -1 * e : e
                  , r = i >> 16
                  , n = i >> 8 & 255
                  , o = 255 & i;
                return "#" + (16777216 + 65536 * (Math.round((a - r) * s) + r) + 256 * (Math.round((a - n) * s) + n) + (Math.round((a - o) * s) + o)).toString(16).slice(1)
            }
        }, {
            key: "shadeColor",
            value: function(e, t) {
                return C.isColorHex(t) ? this.shadeHexColor(e, t) : this.shadeRGBColor(e, t)
            }
        }], [{
            key: "bind",
            value: function(e, t) {
                return function() {
                    return e.apply(t, arguments)
                }
            }
        }, {
            key: "isObject",
            value: function(e) {
                return e && "object" === Ke(e) && !Array.isArray(e) && null != e
            }
        }, {
            key: "is",
            value: function(e, t) {
                return Object.prototype.toString.call(t) === "[object " + e + "]"
            }
        }, {
            key: "listToArray",
            value: function(e) {
                var t, i = [];
                for (t = 0; t < e.length; t++)
                    i[t] = e[t];
                return i
            }
        }, {
            key: "extend",
            value: function(e, t) {
                var i = this;
                "function" != typeof Object.assign && (Object.assign = function(s) {
                    if (null == s)
                        throw new TypeError("Cannot convert undefined or null to object");
                    for (var r = Object(s), n = 1; n < arguments.length; n++) {
                        var o = arguments[n];
                        if (null != o)
                            for (var h in o)
                                o.hasOwnProperty(h) && (r[h] = o[h])
                    }
                    return r
                }
                );
                var a = Object.assign({}, e);
                return this.isObject(e) && this.isObject(t) && Object.keys(t).forEach(function(s) {
                    i.isObject(t[s]) && s in e ? a[s] = i.extend(e[s], t[s]) : Object.assign(a, Re({}, s, t[s]))
                }),
                a
            }
        }, {
            key: "extendArray",
            value: function(e, t) {
                var i = [];
                return e.map(function(a) {
                    i.push(C.extend(t, a))
                }),
                i
            }
        }, {
            key: "monthMod",
            value: function(e) {
                return e % 12
            }
        }, {
            key: "clone",
            value: function(e) {
                if (C.is("Array", e)) {
                    for (var t = [], i = 0; i < e.length; i++)
                        t[i] = this.clone(e[i]);
                    return t
                }
                if (C.is("Null", e))
                    return null;
                if (C.is("Date", e))
                    return e;
                if ("object" === Ke(e)) {
                    var a = {};
                    for (var s in e)
                        e.hasOwnProperty(s) && (a[s] = this.clone(e[s]));
                    return a
                }
                return e
            }
        }, {
            key: "log10",
            value: function(e) {
                return Math.log(e) / Math.LN10
            }
        }, {
            key: "roundToBase10",
            value: function(e) {
                return Math.pow(10, Math.floor(Math.log10(e)))
            }
        }, {
            key: "roundToBase",
            value: function(e, t) {
                return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)))
            }
        }, {
            key: "parseNumber",
            value: function(e) {
                return null === e ? e : parseFloat(e)
            }
        }, {
            key: "stripNumber",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                return Number.isInteger(e) ? e : parseFloat(e.toPrecision(t))
            }
        }, {
            key: "randomId",
            value: function() {
                return (Math.random() + 1).toString(36).substring(4)
            }
        }, {
            key: "noExponents",
            value: function(e) {
                var t = String(e).split(/[eE]/);
                if (1 === t.length)
                    return t[0];
                var i = ""
                  , a = e < 0 ? "-" : ""
                  , s = t[0].replace(".", "")
                  , r = Number(t[1]) + 1;
                if (r < 0) {
                    for (i = a + "0."; r++; )
                        i += "0";
                    return i + s.replace(/^-/, "")
                }
                for (r -= s.length; r--; )
                    i += "0";
                return s + i
            }
        }, {
            key: "getDimensions",
            value: function(e) {
                var t = getComputedStyle(e, null)
                  , i = e.clientHeight
                  , a = e.clientWidth;
                return i -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom),
                [a -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), i]
            }
        }, {
            key: "getBoundingClientRect",
            value: function(e) {
                var t = e.getBoundingClientRect();
                return {
                    top: t.top,
                    right: t.right,
                    bottom: t.bottom,
                    left: t.left,
                    width: e.clientWidth,
                    height: e.clientHeight,
                    x: t.left,
                    y: t.top
                }
            }
        }, {
            key: "getLargestStringFromArr",
            value: function(e) {
                return e.reduce(function(t, i) {
                    return Array.isArray(i) && (i = i.reduce(function(a, s) {
                        return a.length > s.length ? a : s
                    })),
                    t.length > i.length ? t : i
                }, 0)
            }
        }, {
            key: "hexToRgba",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999"
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                "#" !== e.substring(0, 1) && (e = "#999999");
                var i = e.replace("#", "");
                i = i.match(new RegExp("(.{" + i.length / 3 + "})","g"));
                for (var a = 0; a < i.length; a++)
                    i[a] = parseInt(1 === i[a].length ? i[a] + i[a] : i[a], 16);
                return void 0 !== t && i.push(t),
                "rgba(" + i.join(",") + ")"
            }
        }, {
            key: "getOpacityFromRGBA",
            value: function(e) {
                return parseFloat(e.replace(/^.*,(.+)\)/, "$1"))
            }
        }, {
            key: "rgb2hex",
            value: function(e) {
                return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === e.length ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : ""
            }
        }, {
            key: "isColorHex",
            value: function(e) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e)
            }
        }, {
            key: "getPolygonPos",
            value: function(e, t) {
                for (var i = [], a = 2 * Math.PI / t, s = 0; s < t; s++) {
                    var r = {};
                    r.x = e * Math.sin(s * a),
                    r.y = -e * Math.cos(s * a),
                    i.push(r)
                }
                return i
            }
        }, {
            key: "polarToCartesian",
            value: function(e, t, i, a) {
                var s = (a - 90) * Math.PI / 180;
                return {
                    x: e + i * Math.cos(s),
                    y: t + i * Math.sin(s)
                }
            }
        }, {
            key: "escapeString",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x"
                  , i = e.toString().slice();
                return i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, t)
            }
        }, {
            key: "negToZero",
            value: function(e) {
                return e < 0 ? 0 : e
            }
        }, {
            key: "moveIndexInArray",
            value: function(e, t, i) {
                if (i >= e.length)
                    for (var a = i - e.length + 1; a--; )
                        e.push(void 0);
                return e.splice(i, 0, e.splice(t, 1)[0]),
                e
            }
        }, {
            key: "extractNumber",
            value: function(e) {
                return parseFloat(e.replace(/[^\d.]*/g, ""))
            }
        }, {
            key: "findAncestor",
            value: function(e, t) {
                for (; (e = e.parentElement) && !e.classList.contains(t); )
                    ;
                return e
            }
        }, {
            key: "setELstyles",
            value: function(e, t) {
                for (var i in t)
                    t.hasOwnProperty(i) && (e.style.key = t[i])
            }
        }, {
            key: "isNumber",
            value: function(e) {
                return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10))
            }
        }, {
            key: "isFloat",
            value: function(e) {
                return Number(e) === e && e % 1 != 0
            }
        }, {
            key: "isSafari",
            value: function() {
                return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
            }
        }, {
            key: "isFirefox",
            value: function() {
                return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
            }
        }, {
            key: "isIE11",
            value: function() {
                if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1)
                    return !0
            }
        }, {
            key: "isIE",
            value: function() {
                var e = window.navigator.userAgent
                  , t = e.indexOf("MSIE ");
                if (t > 0)
                    return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
                if (e.indexOf("Trident/") > 0) {
                    var i = e.indexOf("rv:");
                    return parseInt(e.substring(i + 3, e.indexOf(".", i)), 10)
                }
                var a = e.indexOf("Edge/");
                return a > 0 && parseInt(e.substring(a + 5, e.indexOf(".", a)), 10)
            }
        }]),
        C
    }()
      , Se = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.setEasingFunctions()
        }
        return Te(C, [{
            key: "setEasingFunctions",
            value: function() {
                var e;
                if (!this.w.globals.easing) {
                    switch (this.w.config.chart.animations.easing) {
                    case "linear":
                        e = "-";
                        break;
                    case "easein":
                        e = "<";
                        break;
                    case "easeout":
                        e = ">";
                        break;
                    case "easeinout":
                    default:
                        e = "<>";
                        break;
                    case "swing":
                        e = function(t) {
                            var i = 1.70158;
                            return (t -= 1) * t * ((i + 1) * t + i) + 1
                        }
                        ;
                        break;
                    case "bounce":
                        e = function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        }
                        ;
                        break;
                    case "elastic":
                        e = function(t) {
                            return t === !!t ? t : Math.pow(2, -10 * t) * Math.sin((t - .075) * (2 * Math.PI) / .3) + 1
                        }
                    }
                    this.w.globals.easing = e
                }
            }
        }, {
            key: "animateLine",
            value: function(e, t, i, a) {
                e.attr(t).animate(a).attr(i)
            }
        }, {
            key: "animateMarker",
            value: function(e, t, i, a, s, r) {
                t || (t = 0),
                e.attr({
                    r: t,
                    width: t,
                    height: t
                }).animate(a, s).attr({
                    r: i,
                    width: i.width,
                    height: i.height
                }).afterAll(function() {
                    r()
                })
            }
        }, {
            key: "animateCircle",
            value: function(e, t, i, a, s) {
                e.attr({
                    r: t.r,
                    cx: t.cx,
                    cy: t.cy
                }).animate(a, s).attr({
                    r: i.r,
                    cx: i.cx,
                    cy: i.cy
                })
            }
        }, {
            key: "animateRect",
            value: function(e, t, i, a, s) {
                e.attr(t).animate(a).attr(i).afterAll(function() {
                    return s()
                })
            }
        }, {
            key: "animatePathsGradually",
            value: function(e) {
                var d = this.w
                  , u = 0;
                d.config.chart.animations.animateGradually.enabled && (u = d.config.chart.animations.animateGradually.delay),
                d.config.chart.animations.dynamicAnimation.enabled && d.globals.dataChanged && "bar" !== d.config.chart.type && (u = 0),
                this.morphSVG(e.el, e.realIndex, e.j, "line" !== d.config.chart.type || d.globals.comboCharts ? e.fill : "stroke", e.pathFrom, e.pathTo, e.speed, e.delay * u)
            }
        }, {
            key: "showDelayedElements",
            value: function() {
                this.w.globals.delayedElements.forEach(function(e) {
                    var t = e.el;
                    t.classList.remove("apexcharts-element-hidden"),
                    t.classList.add("apexcharts-hidden-element-shown")
                })
            }
        }, {
            key: "animationCompleted",
            value: function(e) {
                var t = this.w;
                t.globals.animationEnded || (t.globals.animationEnded = !0,
                this.showDelayedElements(),
                "function" == typeof t.config.chart.events.animationEnd && t.config.chart.events.animationEnd(this.ctx, {
                    el: e,
                    w: t
                }))
            }
        }, {
            key: "morphSVG",
            value: function(e, t, i, a, s, r, n, o) {
                var h = this
                  , d = this.w;
                s || (s = e.attr("pathFrom")),
                r || (r = e.attr("pathTo"));
                var u = function(p) {
                    return "radar" === d.config.chart.type && (n = 1),
                    "M 0 ".concat(d.globals.gridHeight)
                };
                (!s || s.indexOf("undefined") > -1 || s.indexOf("NaN") > -1) && (s = u()),
                (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = u()),
                d.globals.shouldAnimate || (n = 1),
                e.plot(s).animate(1, d.globals.easing, o).plot(s).animate(n, d.globals.easing, o).plot(r).afterAll(function() {
                    D.isNumber(i) ? i === d.globals.series[d.globals.maxValsInArrayIndex].length - 2 && d.globals.shouldAnimate && h.animationCompleted(e) : "none" !== a && d.globals.shouldAnimate && (!d.globals.comboCharts && t === d.globals.series.length - 1 || d.globals.comboCharts) && h.animationCompleted(e),
                    h.showDelayedElements()
                })
            }
        }]),
        C
    }()
      , _e = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "getDefaultFilter",
            value: function(e, t) {
                var i = this.w;
                e.unfilter(!0),
                (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"),
                "none" !== i.config.states.normal.filter ? this.applyFilter(e, t, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(e, i.config.chart.dropShadow, t)
            }
        }, {
            key: "addNormalFilter",
            value: function(e, t) {
                var i = this.w;
                i.config.chart.dropShadow.enabled && !e.node.classList.contains("apexcharts-marker") && this.dropShadow(e, i.config.chart.dropShadow, t)
            }
        }, {
            key: "addLightenFilter",
            value: function(e, t, i) {
                var a = this
                  , s = this.w
                  , r = i.intensity;
                e.unfilter(!0),
                new window.SVG.Filter,
                e.filter(function(n) {
                    var o = s.config.chart.dropShadow;
                    (o.enabled ? a.addShadow(n, t, o) : n).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: 1.5,
                            intercept: r
                        }
                    })
                }),
                e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)
            }
        }, {
            key: "addDarkenFilter",
            value: function(e, t, i) {
                var a = this
                  , s = this.w
                  , r = i.intensity;
                e.unfilter(!0),
                new window.SVG.Filter,
                e.filter(function(n) {
                    var o = s.config.chart.dropShadow;
                    (o.enabled ? a.addShadow(n, t, o) : n).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: r
                        }
                    })
                }),
                e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)
            }
        }, {
            key: "applyFilter",
            value: function(e, t, i) {
                var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                switch (i) {
                case "none":
                    this.addNormalFilter(e, t);
                    break;
                case "lighten":
                    this.addLightenFilter(e, t, {
                        intensity: a
                    });
                    break;
                case "darken":
                    this.addDarkenFilter(e, t, {
                        intensity: a
                    })
                }
            }
        }, {
            key: "addShadow",
            value: function(e, t, i) {
                var a = i.blur
                  , s = i.top
                  , r = i.left
                  , n = i.color
                  , o = i.opacity
                  , h = e.flood(Array.isArray(n) ? n[t] : n, o).composite(e.sourceAlpha, "in").offset(r, s).gaussianBlur(a).merge(e.source);
                return e.blend(e.source, h)
            }
        }, {
            key: "dropShadow",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , a = t.top
                  , s = t.left
                  , r = t.blur
                  , n = t.color
                  , o = t.opacity
                  , h = t.noUserSpaceOnUse
                  , d = this.w;
                return e.unfilter(!0),
                D.isIE() && "radialBar" === d.config.chart.type || (n = Array.isArray(n) ? n[i] : n,
                e.filter(function(u) {
                    var p;
                    p = D.isSafari() || D.isFirefox() || D.isIE() ? u.flood(n, o).composite(u.sourceAlpha, "in").offset(s, a).gaussianBlur(r) : u.flood(n, o).composite(u.sourceAlpha, "in").offset(s, a).gaussianBlur(r).merge(u.source),
                    u.blend(u.source, p)
                }),
                h || e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)),
                e
            }
        }, {
            key: "setSelectionFilter",
            value: function(e, t, i) {
                var a = this.w;
                if (void 0 !== a.globals.selectedDataPoints[t] && a.globals.selectedDataPoints[t].indexOf(i) > -1) {
                    e.node.setAttribute("selected", !0);
                    var s = a.config.states.active.filter;
                    "none" !== s && this.applyFilter(e, t, s.type, s.value)
                }
            }
        }, {
            key: "_scaleFilterSize",
            value: function(e) {
                !function(t) {
                    for (var i in t)
                        t.hasOwnProperty(i) && e.setAttribute(i, t[i])
                }({
                    width: "200%",
                    height: "200%",
                    x: "-50%",
                    y: "-50%"
                })
            }
        }]),
        C
    }()
      , U = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "roundPathCorners",
            value: function(e, t) {
                function i(H, B, j) {
                    var ce = B.x - H.x
                      , me = B.y - H.y
                      , ue = Math.sqrt(ce * ce + me * me);
                    return a(H, B, Math.min(1, j / ue))
                }
                function a(H, B, j) {
                    return {
                        x: H.x + (B.x - H.x) * j,
                        y: H.y + (B.y - H.y) * j
                    }
                }
                function s(H, B) {
                    H.length > 2 && (H[H.length - 2] = B.x,
                    H[H.length - 1] = B.y)
                }
                function r(H) {
                    return {
                        x: parseFloat(H[H.length - 2]),
                        y: parseFloat(H[H.length - 1])
                    }
                }
                e.indexOf("NaN") > -1 && (e = "");
                var n = e.split(/[,\s]/).reduce(function(H, B) {
                    var j = B.match("([a-zA-Z])(.+)");
                    return j ? (H.push(j[1]),
                    H.push(j[2])) : H.push(B),
                    H
                }, []).reduce(function(H, B) {
                    return parseFloat(B) == B && H.length ? H[H.length - 1].push(B) : H.push([B]),
                    H
                }, [])
                  , o = [];
                if (n.length > 1) {
                    var h = r(n[0])
                      , d = null;
                    "Z" == n[n.length - 1][0] && n[0].length > 2 && (n[n.length - 1] = d = ["L", h.x, h.y]),
                    o.push(n[0]);
                    for (var u = 1; u < n.length; u++) {
                        var p = o[o.length - 1]
                          , x = n[u]
                          , b = x == d ? n[1] : n[u + 1];
                        if (b && p && p.length > 2 && "L" == x[0] && b.length > 2 && "L" == b[0]) {
                            var k, S, E = r(p), M = r(x), l = r(b);
                            k = i(M, E, t),
                            S = i(M, l, t),
                            s(x, k),
                            x.origPoint = M,
                            o.push(x);
                            var f = a(k, M, .5)
                              , w = a(M, S, .5)
                              , _ = ["C", f.x, f.y, w.x, w.y, S.x, S.y];
                            _.origPoint = M,
                            o.push(_)
                        } else
                            o.push(x)
                    }
                    if (d) {
                        var R = r(o[o.length - 1]);
                        o.push(["Z"]),
                        s(o[0], R)
                    }
                } else
                    o = n;
                return o.reduce(function(H, B) {
                    return H + B.join(" ") + " "
                }, "")
            }
        }, {
            key: "drawLine",
            value: function(e, t, i, a) {
                var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8"
                  , r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0
                  , n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null
                  , o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
                return this.w.globals.dom.Paper.line().attr({
                    x1: e,
                    y1: t,
                    x2: i,
                    y2: a,
                    stroke: s,
                    "stroke-dasharray": r,
                    "stroke-width": n,
                    "stroke-linecap": o
                })
            }
        }, {
            key: "drawRect",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe"
                  , n = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1
                  , o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null
                  , h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null
                  , d = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0
                  , u = this.w.globals.dom.Paper.rect();
                return u.attr({
                    x: e,
                    y: t,
                    width: i > 0 ? i : 0,
                    height: a > 0 ? a : 0,
                    rx: s,
                    ry: s,
                    opacity: n,
                    "stroke-width": null !== o ? o : 0,
                    stroke: null !== h ? h : "none",
                    "stroke-dasharray": d
                }),
                u.node.setAttribute("fill", r),
                u
            }
        }, {
            key: "drawPolygon",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1"
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
                return this.w.globals.dom.Paper.polygon(e).attr({
                    fill: a,
                    stroke: t,
                    "stroke-width": i
                })
            }
        }, {
            key: "drawCircle",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                e < 0 && (e = 0);
                var i = this.w.globals.dom.Paper.circle(2 * e);
                return null !== t && i.attr(t),
                i
            }
        }, {
            key: "drawPath",
            value: function(e) {
                var t = e.d
                  , i = void 0 === t ? "" : t
                  , a = e.stroke
                  , s = void 0 === a ? "#a8a8a8" : a
                  , r = e.strokeWidth
                  , n = void 0 === r ? 1 : r
                  , o = e.fill
                  , h = e.fillOpacity
                  , d = void 0 === h ? 1 : h
                  , u = e.strokeOpacity
                  , p = void 0 === u ? 1 : u
                  , x = e.classes
                  , b = e.strokeLinecap
                  , k = void 0 === b ? null : b
                  , S = e.strokeDashArray
                  , E = void 0 === S ? 0 : S
                  , M = this.w;
                return null === k && (k = M.config.stroke.lineCap),
                (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(M.globals.gridHeight)),
                M.globals.dom.Paper.path(i).attr({
                    fill: o,
                    "fill-opacity": d,
                    stroke: s,
                    "stroke-opacity": p,
                    "stroke-linecap": k,
                    "stroke-width": n,
                    "stroke-dasharray": E,
                    class: x
                })
            }
        }, {
            key: "group",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = this.w.globals.dom.Paper.group();
                return null !== e && t.attr(e),
                t
            }
        }, {
            key: "move",
            value: function(e, t) {
                return ["M", e, t].join(" ")
            }
        }, {
            key: "line",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , a = null;
                return null === i ? a = [" L", e, t].join(" ") : "H" === i ? a = [" H", e].join(" ") : "V" === i && (a = [" V", t].join(" ")),
                a
            }
        }, {
            key: "curve",
            value: function(e, t, i, a, s, r) {
                return ["C", e, t, i, a, s, r].join(" ")
            }
        }, {
            key: "quadraticCurve",
            value: function(e, t, i, a) {
                return ["Q", e, t, i, a].join(" ")
            }
        }, {
            key: "arc",
            value: function(e, t, i, a, s, r, n) {
                var o = "A";
                arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (o = "a");
                var h = [o, e, t, i, a, s, r, n].join(" ");
                return h
            }
        }, {
            key: "renderPaths",
            value: function(e) {
                var t, i = e.j, a = e.realIndex, s = e.pathFrom, r = e.pathTo, n = e.stroke, o = e.strokeWidth, h = e.strokeLinecap, d = e.fill, u = e.animationDelay, p = e.initialSpeed, x = e.dataChangeSpeed, b = e.className, k = e.shouldClipToGrid, S = void 0 === k || k, E = e.bindEventsOnPaths, M = void 0 === E || E, l = e.drawShadow, f = void 0 === l || l, w = this.w, _ = new _e(this.ctx), R = new Se(this.ctx), H = this.w.config.chart.animations.enabled, B = H && this.w.config.chart.animations.dynamicAnimation.enabled, j = !!(H && !w.globals.resized || B && w.globals.dataChanged && w.globals.shouldAnimate);
                j ? t = s : (t = r,
                w.globals.animationEnded = !0);
                var me, ce = w.config.stroke.dashArray;
                me = Array.isArray(ce) ? ce[a] : w.config.stroke.dashArray;
                var ue = this.drawPath({
                    d: t,
                    stroke: n,
                    strokeWidth: o,
                    fill: d,
                    fillOpacity: 1,
                    classes: b,
                    strokeLinecap: h,
                    strokeDashArray: me
                });
                ue.attr("index", a),
                S && ue.attr({
                    "clip-path": "url(#gridRectMask".concat(w.globals.cuid, ")")
                }),
                "none" !== w.config.states.normal.filter.type ? _.getDefaultFilter(ue, a) : w.config.chart.dropShadow.enabled && f && (!w.config.chart.dropShadow.enabledOnSeries || w.config.chart.dropShadow.enabledOnSeries && -1 !== w.config.chart.dropShadow.enabledOnSeries.indexOf(a)) && _.dropShadow(ue, w.config.chart.dropShadow, a),
                M && (ue.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, ue)),
                ue.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, ue)),
                ue.node.addEventListener("mousedown", this.pathMouseDown.bind(this, ue))),
                ue.attr({
                    pathTo: r,
                    pathFrom: s
                });
                var Ie = {
                    el: ue,
                    j: i,
                    realIndex: a,
                    pathFrom: s,
                    pathTo: r,
                    fill: d,
                    strokeWidth: o,
                    delay: u
                };
                return !H || w.globals.resized || w.globals.dataChanged ? !w.globals.resized && w.globals.dataChanged || R.showDelayedElements() : R.animatePathsGradually(K(K({}, Ie), {}, {
                    speed: p
                })),
                w.globals.dataChanged && B && j && R.animatePathsGradually(K(K({}, Ie), {}, {
                    speed: x
                })),
                ue
            }
        }, {
            key: "drawPattern",
            value: function(e, t, i) {
                var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8"
                  , s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                return this.w.globals.dom.Paper.pattern(t, i, function(r) {
                    "horizontalLines" === e ? r.line(0, 0, i, 0).stroke({
                        color: a,
                        width: s + 1
                    }) : "verticalLines" === e ? r.line(0, 0, 0, t).stroke({
                        color: a,
                        width: s + 1
                    }) : "slantedLines" === e ? r.line(0, 0, t, i).stroke({
                        color: a,
                        width: s
                    }) : "squares" === e ? r.rect(t, i).fill("none").stroke({
                        color: a,
                        width: s
                    }) : "circles" === e && r.circle(t).fill("none").stroke({
                        color: a,
                        width: s
                    })
                })
            }
        }, {
            key: "drawGradient",
            value: function(e, t, i, a, s) {
                var r, n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, h = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, d = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, u = this.w;
                t.length < 9 && 0 === t.indexOf("#") && (t = D.hexToRgba(t, a)),
                i.length < 9 && 0 === i.indexOf("#") && (i = D.hexToRgba(i, s));
                var p = 0
                  , x = 1
                  , b = 1
                  , k = null;
                null !== o && (p = void 0 !== o[0] ? o[0] / 100 : 0,
                x = void 0 !== o[1] ? o[1] / 100 : 1,
                b = void 0 !== o[2] ? o[2] / 100 : 1,
                k = void 0 !== o[3] ? o[3] / 100 : null);
                var S = !("donut" !== u.config.chart.type && "pie" !== u.config.chart.type && "polarArea" !== u.config.chart.type && "bubble" !== u.config.chart.type);
                if (r = u.globals.dom.Paper.gradient(S ? "radial" : "linear", null === h || 0 === h.length ? function(l) {
                    l.at(p, t, a),
                    l.at(x, i, s),
                    l.at(b, i, s),
                    null !== k && l.at(k, t, a)
                }
                : function(l) {
                    (Array.isArray(h[d]) ? h[d] : h).forEach(function(f) {
                        l.at(f.offset / 100, f.color, f.opacity)
                    })
                }
                ),
                S) {
                    var E = u.globals.gridWidth / 2
                      , M = u.globals.gridHeight / 2;
                    r.attr("bubble" !== u.config.chart.type ? {
                        gradientUnits: "userSpaceOnUse",
                        cx: E,
                        cy: M,
                        r: n
                    } : {
                        cx: .5,
                        cy: .5,
                        r: .8,
                        fx: .2,
                        fy: .2
                    })
                } else
                    "vertical" === e ? r.from(0, 0).to(0, 1) : "diagonal" === e ? r.from(0, 0).to(1, 1) : "horizontal" === e ? r.from(0, 1).to(1, 1) : "diagonal2" === e && r.from(1, 0).to(0, 1);
                return r
            }
        }, {
            key: "getTextBasedOnMaxWidth",
            value: function(e) {
                var t = e.text
                  , i = e.maxWidth
                  , r = this.getTextRects(t, e.fontSize, e.fontFamily)
                  , o = Math.floor(i / (r.width / t.length));
                return i < r.width ? t.slice(0, o - 3) + "..." : t
            }
        }, {
            key: "drawText",
            value: function(e) {
                var t = this
                  , i = e.x
                  , a = e.y
                  , s = e.text
                  , r = e.textAnchor
                  , n = e.fontSize
                  , o = e.fontFamily
                  , h = e.fontWeight
                  , d = e.foreColor
                  , u = e.opacity
                  , p = e.maxWidth
                  , x = e.cssClass
                  , b = void 0 === x ? "" : x
                  , k = e.isPlainText
                  , S = void 0 === k || k
                  , E = this.w;
                void 0 === s && (s = "");
                var M = s;
                r || (r = "start"),
                d && d.length || (d = E.config.chart.foreColor),
                h = h || "regular";
                var l, f = {
                    maxWidth: p,
                    fontSize: n = n || "11px",
                    fontFamily: o = o || E.config.chart.fontFamily
                };
                return Array.isArray(s) ? l = E.globals.dom.Paper.text(function(w) {
                    for (var _ = 0; _ < s.length; _++)
                        M = s[_],
                        p && (M = t.getTextBasedOnMaxWidth(K({
                            text: s[_]
                        }, f))),
                        0 === _ ? w.tspan(M) : w.tspan(M).newLine()
                }) : (p && (M = this.getTextBasedOnMaxWidth(K({
                    text: s
                }, f))),
                l = S ? E.globals.dom.Paper.plain(s) : E.globals.dom.Paper.text(function(w) {
                    return w.tspan(M)
                })),
                l.attr({
                    x: i,
                    y: a,
                    "text-anchor": r,
                    "dominant-baseline": "auto",
                    "font-size": n,
                    "font-family": o,
                    "font-weight": h,
                    fill: d,
                    class: "apexcharts-text " + b
                }),
                l.node.style.fontFamily = o,
                l.node.style.opacity = u,
                l
            }
        }, {
            key: "drawMarker",
            value: function(e, t, i) {
                e = e || 0;
                var a = i.pSize || 0
                  , s = null;
                if ("square" === i.shape || "rect" === i.shape) {
                    var r = void 0 === i.pRadius ? a / 2 : i.pRadius;
                    null !== t && a || (a = 0,
                    r = 0);
                    var n = 1.2 * a + r
                      , o = this.drawRect(n, n, n, n, r);
                    o.attr({
                        x: e - n / 2,
                        y: t - n / 2,
                        cx: e,
                        cy: t,
                        class: i.class ? i.class : "",
                        fill: i.pointFillColor,
                        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                        stroke: i.pointStrokeColor,
                        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                    }),
                    s = o
                } else
                    "circle" !== i.shape && i.shape || (D.isNumber(t) || (a = 0,
                    t = 0),
                    s = this.drawCircle(a, {
                        cx: e,
                        cy: t,
                        class: i.class ? i.class : "",
                        stroke: i.pointStrokeColor,
                        fill: i.pointFillColor,
                        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                    }));
                return s
            }
        }, {
            key: "pathMouseEnter",
            value: function(e, t) {
                var i = this.w
                  , a = new _e(this.ctx)
                  , s = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10);
                if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(t, this.ctx, {
                    seriesIndex: s,
                    dataPointIndex: r,
                    w: i
                }),
                this.ctx.events.fireEvent("dataPointMouseEnter", [t, this.ctx, {
                    seriesIndex: s,
                    dataPointIndex: r,
                    w: i
                }]),
                ("none" === i.config.states.active.filter.type || "true" !== e.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && !i.globals.isTouchDevice) {
                    var n = i.config.states.hover.filter;
                    a.applyFilter(e, s, n.type, n.value)
                }
            }
        }, {
            key: "pathMouseLeave",
            value: function(e, t) {
                var i = this.w
                  , a = new _e(this.ctx)
                  , s = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10);
                "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(t, this.ctx, {
                    seriesIndex: s,
                    dataPointIndex: r,
                    w: i
                }),
                this.ctx.events.fireEvent("dataPointMouseLeave", [t, this.ctx, {
                    seriesIndex: s,
                    dataPointIndex: r,
                    w: i
                }]),
                "none" !== i.config.states.active.filter.type && "true" === e.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && a.getDefaultFilter(e, s)
            }
        }, {
            key: "pathMouseDown",
            value: function(e, t) {
                var i = this.w
                  , a = new _e(this.ctx)
                  , s = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10)
                  , n = "false";
                if ("true" === e.node.getAttribute("selected")) {
                    if (e.node.setAttribute("selected", "false"),
                    i.globals.selectedDataPoints[s].indexOf(r) > -1) {
                        var o = i.globals.selectedDataPoints[s].indexOf(r);
                        i.globals.selectedDataPoints[s].splice(o, 1)
                    }
                } else {
                    if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
                        i.globals.selectedDataPoints = [];
                        var h = i.globals.dom.Paper.select(".apexcharts-series path").members
                          , d = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members
                          , u = function(b) {
                            Array.prototype.forEach.call(b, function(k) {
                                k.node.setAttribute("selected", "false"),
                                a.getDefaultFilter(k, s)
                            })
                        };
                        u(h),
                        u(d)
                    }
                    e.node.setAttribute("selected", "true"),
                    n = "true",
                    void 0 === i.globals.selectedDataPoints[s] && (i.globals.selectedDataPoints[s] = []),
                    i.globals.selectedDataPoints[s].push(r)
                }
                if ("true" === n) {
                    var p = i.config.states.active.filter;
                    if ("none" !== p)
                        a.applyFilter(e, s, p.type, p.value);
                    else if ("none" !== i.config.states.hover.filter && !i.globals.isTouchDevice) {
                        var x = i.config.states.hover.filter;
                        a.applyFilter(e, s, x.type, x.value)
                    }
                } else
                    "none" !== i.config.states.active.filter.type && ("none" === i.config.states.hover.filter.type || i.globals.isTouchDevice ? a.getDefaultFilter(e, s) : a.applyFilter(e, s, (x = i.config.states.hover.filter).type, x.value));
                "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(t, this.ctx, {
                    selectedDataPoints: i.globals.selectedDataPoints,
                    seriesIndex: s,
                    dataPointIndex: r,
                    w: i
                }),
                t && this.ctx.events.fireEvent("dataPointSelection", [t, this.ctx, {
                    selectedDataPoints: i.globals.selectedDataPoints,
                    seriesIndex: s,
                    dataPointIndex: r,
                    w: i
                }])
            }
        }, {
            key: "rotateAroundCenter",
            value: function(e) {
                var t = {};
                return e && "function" == typeof e.getBBox && (t = e.getBBox()),
                {
                    x: t.x + t.width / 2,
                    y: t.y + t.height / 2
                }
            }
        }, {
            key: "getTextRects",
            value: function(e, t, i, a) {
                var s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
                  , r = this.w
                  , n = this.drawText({
                    x: -200,
                    y: -200,
                    text: e,
                    textAnchor: "start",
                    fontSize: t,
                    fontFamily: i,
                    foreColor: "#fff",
                    opacity: 0
                });
                a && n.attr("transform", a),
                r.globals.dom.Paper.add(n);
                var o = n.bbox();
                return s || (o = n.node.getBoundingClientRect()),
                n.remove(),
                {
                    width: o.width,
                    height: o.height
                }
            }
        }, {
            key: "placeTextWithEllipsis",
            value: function(e, t, i) {
                if ("function" == typeof e.getComputedTextLength && (e.textContent = t,
                t.length > 0 && e.getComputedTextLength() >= i / 1.1)) {
                    for (var a = t.length - 3; a > 0; a -= 3)
                        if (e.getSubStringLength(0, a) <= i / 1.1)
                            return void (e.textContent = t.substring(0, a) + "...");
                    e.textContent = "."
                }
            }
        }], [{
            key: "setAttrs",
            value: function(e, t) {
                for (var i in t)
                    t.hasOwnProperty(i) && e.setAttribute(i, t[i])
            }
        }]),
        C
    }()
      , ae = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "getStackedSeriesTotals",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = this.w
                  , i = [];
                if (0 === t.globals.series.length)
                    return i;
                for (var a = 0; a < t.globals.series[t.globals.maxValsInArrayIndex].length; a++) {
                    for (var s = 0, r = 0; r < t.globals.series.length; r++)
                        void 0 !== t.globals.series[r][a] && -1 === e.indexOf(r) && (s += t.globals.series[r][a]);
                    i.push(s)
                }
                return i
            }
        }, {
            key: "getSeriesTotalByIndex",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return null === e ? this.w.config.series.reduce(function(t, i) {
                    return t + i
                }, 0) : this.w.globals.series[e].reduce(function(t, i) {
                    return t + i
                }, 0)
            }
        }, {
            key: "isSeriesNull",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return 0 === (null === e ? this.w.config.series.filter(function(t) {
                    return null !== t
                }) : this.w.config.series[e].data.filter(function(t) {
                    return null !== t
                })).length
            }
        }, {
            key: "seriesHaveSameValues",
            value: function(e) {
                return this.w.globals.series[e].every(function(t, i, a) {
                    return t === a[0]
                })
            }
        }, {
            key: "getCategoryLabels",
            value: function(e) {
                var t = this.w
                  , i = e.slice();
                return t.config.xaxis.convertedCatToNumeric && (i = e.map(function(a, s) {
                    return t.config.xaxis.labels.formatter(a - t.globals.minX + 1)
                })),
                i
            }
        }, {
            key: "getLargestSeries",
            value: function() {
                var e = this.w;
                e.globals.maxValsInArrayIndex = e.globals.series.map(function(t) {
                    return t.length
                }).indexOf(Math.max.apply(Math, e.globals.series.map(function(t) {
                    return t.length
                })))
            }
        }, {
            key: "getLargestMarkerSize",
            value: function() {
                var e = this.w
                  , t = 0;
                return e.globals.markers.size.forEach(function(i) {
                    t = Math.max(t, i)
                }),
                e.config.markers.discrete && e.config.markers.discrete.length && e.config.markers.discrete.forEach(function(i) {
                    t = Math.max(t, i.size)
                }),
                t > 0 && (t += e.config.markers.hover.sizeOffset + 1),
                e.globals.markers.largestSize = t,
                t
            }
        }, {
            key: "getSeriesTotals",
            value: function() {
                var e = this.w;
                e.globals.seriesTotals = e.globals.series.map(function(t, i) {
                    var a = 0;
                    if (Array.isArray(t))
                        for (var s = 0; s < t.length; s++)
                            a += t[s];
                    else
                        a += t;
                    return a
                })
            }
        }, {
            key: "getSeriesTotalsXRange",
            value: function(e, t) {
                var i = this.w;
                return i.globals.series.map(function(a, s) {
                    for (var r = 0, n = 0; n < a.length; n++)
                        i.globals.seriesX[s][n] > e && i.globals.seriesX[s][n] < t && (r += a[n]);
                    return r
                })
            }
        }, {
            key: "getPercentSeries",
            value: function() {
                var e = this.w;
                e.globals.seriesPercent = e.globals.series.map(function(t, i) {
                    var a = [];
                    if (Array.isArray(t))
                        for (var s = 0; s < t.length; s++) {
                            var r = e.globals.stackedSeriesTotals[s]
                              , n = 0;
                            r && (n = 100 * t[s] / r),
                            a.push(n)
                        }
                    else {
                        var o = 100 * t / e.globals.seriesTotals.reduce(function(h, d) {
                            return h + d
                        }, 0);
                        a.push(o)
                    }
                    return a
                })
            }
        }, {
            key: "getCalculatedRatios",
            value: function() {
                var e, t, i, a, s = this.w.globals, r = [], n = 0, o = [], h = .1, d = 0;
                if (s.yRange = [],
                s.isMultipleYAxis)
                    for (var u = 0; u < s.minYArr.length; u++)
                        s.yRange.push(Math.abs(s.minYArr[u] - s.maxYArr[u])),
                        o.push(0);
                else
                    s.yRange.push(Math.abs(s.minY - s.maxY));
                s.xRange = Math.abs(s.maxX - s.minX),
                s.zRange = Math.abs(s.maxZ - s.minZ);
                for (var p = 0; p < s.yRange.length; p++)
                    r.push(s.yRange[p] / s.gridHeight);
                if (t = s.xRange / s.gridWidth,
                i = Math.abs(s.initialMaxX - s.initialMinX) / s.gridWidth,
                e = s.yRange / s.gridWidth,
                a = s.xRange / s.gridHeight,
                (n = s.zRange / s.gridHeight * 16) || (n = 1),
                s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (s.hasNegs = !0),
                s.isMultipleYAxis) {
                    o = [];
                    for (var x = 0; x < r.length; x++)
                        o.push(-s.minYArr[x] / r[x])
                } else
                    o.push(-s.minY / r[0]),
                    s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (h = -s.minY / e,
                    d = s.minX / t);
                return {
                    yRatio: r,
                    invertedYRatio: e,
                    zRatio: n,
                    xRatio: t,
                    initialXRatio: i,
                    invertedXRatio: a,
                    baseLineInvertedY: h,
                    baseLineY: o,
                    baseLineX: d
                }
            }
        }, {
            key: "getLogSeries",
            value: function(e) {
                var t = this
                  , i = this.w;
                return i.globals.seriesLog = e.map(function(a, s) {
                    return i.config.yaxis[s] && i.config.yaxis[s].logarithmic ? a.map(function(r) {
                        return null === r ? null : t.getLogVal(i.config.yaxis[s].logBase, r, s)
                    }) : a
                }),
                i.globals.invalidLogScale ? e : i.globals.seriesLog
            }
        }, {
            key: "getBaseLog",
            value: function(e, t) {
                return Math.log(t) / Math.log(e)
            }
        }, {
            key: "getLogVal",
            value: function(e, t, i) {
                if (0 === t)
                    return 0;
                var a = this.w
                  , s = 0 === a.globals.minYArr[i] ? -1 : this.getBaseLog(e, a.globals.minYArr[i])
                  , r = (0 === a.globals.maxYArr[i] ? 0 : this.getBaseLog(e, a.globals.maxYArr[i])) - s;
                return t < 1 ? t / r : (this.getBaseLog(e, t) - s) / r
            }
        }, {
            key: "getLogYRatios",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = this.w.globals;
                return a.yLogRatio = e.slice(),
                a.logYRange = a.yRange.map(function(s, r) {
                    if (i.config.yaxis[r] && t.w.config.yaxis[r].logarithmic) {
                        var n, o = -Number.MAX_VALUE, h = Number.MIN_VALUE;
                        return a.seriesLog.forEach(function(d, u) {
                            d.forEach(function(p) {
                                i.config.yaxis[u] && i.config.yaxis[u].logarithmic && (o = Math.max(p, o),
                                h = Math.min(p, h))
                            })
                        }),
                        n = Math.pow(a.yRange[r], Math.abs(h - o) / a.yRange[r]),
                        a.yLogRatio[r] = n / a.gridHeight,
                        n
                    }
                }),
                a.invalidLogScale ? e.slice() : a.yLogRatio
            }
        }], [{
            key: "checkComboSeries",
            value: function(e) {
                var t = !1
                  , i = 0
                  , a = 0;
                return e.length && void 0 !== e[0].type && e.forEach(function(s) {
                    "bar" !== s.type && "column" !== s.type && "candlestick" !== s.type && "boxPlot" !== s.type || i++,
                    void 0 !== s.type && a++
                }),
                a > 0 && (t = !0),
                {
                    comboBarCount: i,
                    comboCharts: t
                }
            }
        }, {
            key: "extendArrayProps",
            value: function(e, t, i) {
                return t.yaxis && (t = e.extendYAxis(t, i)),
                t.annotations && (t.annotations.yaxis && (t = e.extendYAxisAnnotations(t)),
                t.annotations.xaxis && (t = e.extendXAxisAnnotations(t)),
                t.annotations.points && (t = e.extendPointAnnotations(t))),
                t
            }
        }]),
        C
    }()
      , he = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.annoCtx = e
        }
        return Te(C, [{
            key: "setOrientations",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , i = this.w;
                if ("vertical" === e.label.orientation) {
                    var a = null !== t ? t : 0
                      , s = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a, "']"));
                    if (null !== s) {
                        var r = s.getBoundingClientRect();
                        s.setAttribute("x", parseFloat(s.getAttribute("x")) - r.height + 4),
                        s.setAttribute("y", "top" === e.label.position ? parseFloat(s.getAttribute("y")) + r.width : parseFloat(s.getAttribute("y")) - r.width);
                        var n = this.annoCtx.graphics.rotateAroundCenter(s)
                          , o = n.x
                          , h = n.y;
                        s.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(h, ")"))
                    }
                }
            }
        }, {
            key: "addBackgroundToAnno",
            value: function(e, t) {
                var i = this.w;
                if (!e || void 0 === t.label.text || void 0 !== t.label.text && !String(t.label.text).trim())
                    return null;
                var a = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect()
                  , s = e.getBoundingClientRect()
                  , r = t.label.style.padding.left
                  , n = t.label.style.padding.right
                  , o = t.label.style.padding.top
                  , h = t.label.style.padding.bottom;
                "vertical" === t.label.orientation && (o = t.label.style.padding.left,
                h = t.label.style.padding.right,
                r = t.label.style.padding.top,
                n = t.label.style.padding.bottom);
                var p = this.annoCtx.graphics.drawRect(s.left - a.left - r - i.globals.barPadForNumericAxis, s.top - a.top - o, s.width + r + n, s.height + o + h, t.label.borderRadius, t.label.style.background, 1, t.label.borderWidth, t.label.borderColor, 0);
                return t.id && p.node.classList.add(t.id),
                p
            }
        }, {
            key: "annotationsBackground",
            value: function() {
                var e = this
                  , t = this.w
                  , i = function(a, s, r) {
                    var n = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(r, "-annotations .apexcharts-").concat(r, "-annotation-label[rel='").concat(s, "']"));
                    if (n) {
                        var o = n.parentNode
                          , h = e.addBackgroundToAnno(n, a);
                        h && (o.insertBefore(h.node, n),
                        a.label.mouseEnter && h.node.addEventListener("mouseenter", a.label.mouseEnter.bind(e, a)),
                        a.label.mouseLeave && h.node.addEventListener("mouseleave", a.label.mouseLeave.bind(e, a)),
                        a.label.click && h.node.addEventListener("click", a.label.click.bind(e, a)))
                    }
                };
                t.config.annotations.xaxis.map(function(a, s) {
                    i(a, s, "xaxis")
                }),
                t.config.annotations.yaxis.map(function(a, s) {
                    i(a, s, "yaxis")
                }),
                t.config.annotations.points.map(function(a, s) {
                    i(a, s, "point")
                })
            }
        }, {
            key: "getY1Y2",
            value: function(e, t) {
                var i, a = "y1" === e ? t.y : t.y2, s = this.w;
                if (this.annoCtx.invertAxis) {
                    var r = s.globals.labels.indexOf(a);
                    s.config.xaxis.convertedCatToNumeric && (r = s.globals.categoryLabels.indexOf(a));
                    var n = s.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
                    n && (i = parseFloat(n.getAttribute("y")))
                } else {
                    var o;
                    o = s.config.yaxis[t.yAxisIndex].logarithmic ? (a = new ae(this.annoCtx.ctx).getLogVal(a, t.yAxisIndex)) / s.globals.yLogRatio[t.yAxisIndex] : (a - s.globals.minYArr[t.yAxisIndex]) / (s.globals.yRange[t.yAxisIndex] / s.globals.gridHeight),
                    i = s.globals.gridHeight - o,
                    !t.marker || null != t.y || (i = 0),
                    s.config.yaxis[t.yAxisIndex] && s.config.yaxis[t.yAxisIndex].reversed && (i = o)
                }
                return "string" == typeof a && a.indexOf("px") > -1 && (i = parseFloat(a)),
                i
            }
        }, {
            key: "getX1X2",
            value: function(e, t) {
                var i = this.w
                  , a = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX
                  , s = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX
                  , r = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange
                  , n = (t.x - a) / (r / i.globals.gridWidth);
                this.annoCtx.inversedReversedAxis && (n = (s - t.x) / (r / i.globals.gridWidth)),
                "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (n = this.getStringX(t.x));
                var o = (t.x2 - a) / (r / i.globals.gridWidth);
                return this.annoCtx.inversedReversedAxis && (o = (s - t.x2) / (r / i.globals.gridWidth)),
                "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (o = this.getStringX(t.x2)),
                null != t.x || !t.marker || (n = i.globals.gridWidth),
                "x1" === e && "string" == typeof t.x && t.x.indexOf("px") > -1 && (n = parseFloat(t.x)),
                "x2" === e && "string" == typeof t.x2 && t.x2.indexOf("px") > -1 && (o = parseFloat(t.x2)),
                "x1" === e ? n : o
            }
        }, {
            key: "getStringX",
            value: function(e) {
                var t = this.w
                  , i = e;
                t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1);
                var a = t.globals.labels.indexOf(e)
                  , s = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a + 1) + ")");
                return s && (i = parseFloat(s.getAttribute("x"))),
                i
            }
        }]),
        C
    }()
      , m = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.annoCtx = e,
            this.invertAxis = this.annoCtx.invertAxis,
            this.helpers = new he(this.annoCtx)
        }
        return Te(C, [{
            key: "addXaxisAnnotation",
            value: function(e, t, i) {
                var a, s = this.w, r = this.helpers.getX1X2("x1", e), n = e.label.text, o = e.strokeDashArray;
                if (D.isNumber(r)) {
                    if (null == e.x2) {
                        var h = this.annoCtx.graphics.drawLine(r + e.offsetX, 0 + e.offsetY, r + e.offsetX, s.globals.gridHeight + e.offsetY, e.borderColor, o, e.borderWidth);
                        t.appendChild(h.node),
                        e.id && h.node.classList.add(e.id)
                    } else {
                        if ((a = this.helpers.getX1X2("x2", e)) < r) {
                            var d = r;
                            r = a,
                            a = d
                        }
                        var u = this.annoCtx.graphics.drawRect(r + e.offsetX, 0 + e.offsetY, a - r, s.globals.gridHeight + e.offsetY, 0, e.fillColor, e.opacity, 1, e.borderColor, o);
                        u.node.classList.add("apexcharts-annotation-rect"),
                        u.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")),
                        t.appendChild(u.node),
                        e.id && u.node.classList.add(e.id)
                    }
                    var p = this.annoCtx.graphics.getTextRects(n, parseFloat(e.label.style.fontSize))
                      , b = this.annoCtx.graphics.drawText({
                        x: r + e.label.offsetX,
                        y: ("top" === e.label.position ? 4 : "center" === e.label.position ? s.globals.gridHeight / 2 + ("vertical" === e.label.orientation ? p.width / 2 : 0) : s.globals.gridHeight) + e.label.offsetY - ("vertical" === e.label.orientation ? "top" === e.label.position ? p.width / 2 - 12 : -p.width / 2 : 0),
                        text: n,
                        textAnchor: e.label.textAnchor,
                        fontSize: e.label.style.fontSize,
                        fontFamily: e.label.style.fontFamily,
                        fontWeight: e.label.style.fontWeight,
                        foreColor: e.label.style.color,
                        cssClass: "apexcharts-xaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                    });
                    b.attr({
                        rel: i
                    }),
                    t.appendChild(b.node),
                    this.annoCtx.helpers.setOrientations(e, i)
                }
            }
        }, {
            key: "drawXAxisAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.annoCtx.graphics.group({
                    class: "apexcharts-xaxis-annotations"
                });
                return t.config.annotations.xaxis.map(function(a, s) {
                    e.addXaxisAnnotation(a, i.node, s)
                }),
                i
            }
        }]),
        C
    }()
      , Ce = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.annoCtx = e,
            this.helpers = new he(this.annoCtx)
        }
        return Te(C, [{
            key: "addYaxisAnnotation",
            value: function(e, t, i) {
                var a, s = this.w, r = e.strokeDashArray, n = this.helpers.getY1Y2("y1", e), o = e.label.text;
                if (null == e.y2) {
                    var h = this.annoCtx.graphics.drawLine(0 + e.offsetX, n + e.offsetY, this._getYAxisAnnotationWidth(e), n + e.offsetY, e.borderColor, r, e.borderWidth);
                    t.appendChild(h.node),
                    e.id && h.node.classList.add(e.id)
                } else {
                    if ((a = this.helpers.getY1Y2("y2", e)) > n) {
                        var d = n;
                        n = a,
                        a = d
                    }
                    var u = this.annoCtx.graphics.drawRect(0 + e.offsetX, a + e.offsetY, this._getYAxisAnnotationWidth(e), n - a, 0, e.fillColor, e.opacity, 1, e.borderColor, r);
                    u.node.classList.add("apexcharts-annotation-rect"),
                    u.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")),
                    t.appendChild(u.node),
                    e.id && u.node.classList.add(e.id)
                }
                var x = this.annoCtx.graphics.drawText({
                    x: ("right" === e.label.position ? s.globals.gridWidth : "center" === e.label.position ? s.globals.gridWidth / 2 : 0) + e.label.offsetX,
                    y: (a ?? n) + e.label.offsetY - 3,
                    text: o,
                    textAnchor: e.label.textAnchor,
                    fontSize: e.label.style.fontSize,
                    fontFamily: e.label.style.fontFamily,
                    fontWeight: e.label.style.fontWeight,
                    foreColor: e.label.style.color,
                    cssClass: "apexcharts-yaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                });
                x.attr({
                    rel: i
                }),
                t.appendChild(x.node)
            }
        }, {
            key: "_getYAxisAnnotationWidth",
            value: function(e) {
                var t = this.w;
                return (e.width.indexOf("%") > -1 ? t.globals.gridWidth * parseInt(e.width, 10) / 100 : parseInt(e.width, 10)) + e.offsetX
            }
        }, {
            key: "drawYAxisAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.annoCtx.graphics.group({
                    class: "apexcharts-yaxis-annotations"
                });
                return t.config.annotations.yaxis.map(function(a, s) {
                    e.addYaxisAnnotation(a, i.node, s)
                }),
                i
            }
        }]),
        C
    }()
      , qe = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.annoCtx = e,
            this.helpers = new he(this.annoCtx)
        }
        return Te(C, [{
            key: "addPointAnnotation",
            value: function(e, t, i) {
                var a = this.helpers.getX1X2("x1", e)
                  , s = this.helpers.getY1Y2("y1", e);
                if (D.isNumber(a)) {
                    var r = {
                        pSize: e.marker.size,
                        pointStrokeWidth: e.marker.strokeWidth,
                        pointFillColor: e.marker.fillColor,
                        pointStrokeColor: e.marker.strokeColor,
                        shape: e.marker.shape,
                        pRadius: e.marker.radius,
                        class: "apexcharts-point-annotation-marker ".concat(e.marker.cssClass, " ").concat(e.id ? e.id : "")
                    }
                      , n = this.annoCtx.graphics.drawMarker(a + e.marker.offsetX, s + e.marker.offsetY, r);
                    t.appendChild(n.node);
                    var o = e.label.text ? e.label.text : ""
                      , h = this.annoCtx.graphics.drawText({
                        x: a + e.label.offsetX,
                        y: s + e.label.offsetY - e.marker.size - parseFloat(e.label.style.fontSize) / 1.6,
                        text: o,
                        textAnchor: e.label.textAnchor,
                        fontSize: e.label.style.fontSize,
                        fontFamily: e.label.style.fontFamily,
                        fontWeight: e.label.style.fontWeight,
                        foreColor: e.label.style.color,
                        cssClass: "apexcharts-point-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                    });
                    if (h.attr({
                        rel: i
                    }),
                    t.appendChild(h.node),
                    e.customSVG.SVG) {
                        var d = this.annoCtx.graphics.group({
                            class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass
                        });
                        d.attr({
                            transform: "translate(".concat(a + e.customSVG.offsetX, ", ").concat(s + e.customSVG.offsetY, ")")
                        }),
                        d.node.innerHTML = e.customSVG.SVG,
                        t.appendChild(d.node)
                    }
                    if (e.image.path) {
                        var u = e.image.width ? e.image.width : 20
                          , p = e.image.height ? e.image.height : 20;
                        n = this.annoCtx.addImage({
                            x: a + e.image.offsetX - u / 2,
                            y: s + e.image.offsetY - p / 2,
                            width: u,
                            height: p,
                            path: e.image.path,
                            appendTo: ".apexcharts-point-annotations"
                        })
                    }
                    e.mouseEnter && n.node.addEventListener("mouseenter", e.mouseEnter.bind(this, e)),
                    e.mouseLeave && n.node.addEventListener("mouseleave", e.mouseLeave.bind(this, e)),
                    e.click && n.node.addEventListener("click", e.click.bind(this, e))
                }
            }
        }, {
            key: "drawPointAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.annoCtx.graphics.group({
                    class: "apexcharts-point-annotations"
                });
                return t.config.annotations.points.map(function(a, s) {
                    e.addPointAnnotation(a, i.node, s)
                }),
                i
            }
        }]),
        C
    }()
      , gt = {
        name: "en",
        options: {
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            toolbar: {
                exportToSVG: "Download SVG",
                exportToPNG: "Download PNG",
                exportToCSV: "Download CSV",
                menu: "Menu",
                selection: "Selection",
                selectionZoom: "Selection Zoom",
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                pan: "Panning",
                reset: "Reset Zoom"
            }
        }
    }
      , kt = function() {
        function C() {
            Q(this, C),
            this.yAxis = {
                show: !0,
                showAlways: !1,
                showForNullSeries: !0,
                seriesName: void 0,
                opposite: !1,
                reversed: !1,
                logarithmic: !1,
                logBase: 10,
                tickAmount: void 0,
                forceNiceScale: !1,
                max: void 0,
                min: void 0,
                floating: !1,
                decimalsInFloat: void 0,
                labels: {
                    show: !0,
                    minWidth: 0,
                    maxWidth: 160,
                    offsetX: 0,
                    offsetY: 0,
                    align: void 0,
                    rotate: 0,
                    padding: 20,
                    style: {
                        colors: [],
                        fontSize: "11px",
                        fontWeight: 400,
                        fontFamily: void 0,
                        cssClass: ""
                    },
                    formatter: void 0
                },
                axisBorder: {
                    show: !1,
                    color: "#e0e0e0",
                    width: 1,
                    offsetX: 0,
                    offsetY: 0
                },
                axisTicks: {
                    show: !1,
                    color: "#e0e0e0",
                    width: 6,
                    offsetX: 0,
                    offsetY: 0
                },
                title: {
                    text: void 0,
                    rotate: -90,
                    offsetY: 0,
                    offsetX: 0,
                    style: {
                        color: void 0,
                        fontSize: "11px",
                        fontWeight: 900,
                        fontFamily: void 0,
                        cssClass: ""
                    }
                },
                tooltip: {
                    enabled: !1,
                    offsetX: 0
                },
                crosshairs: {
                    show: !0,
                    position: "front",
                    stroke: {
                        color: "#b6b6b6",
                        width: 1,
                        dashArray: 0
                    }
                }
            },
            this.pointAnnotation = {
                id: void 0,
                x: 0,
                y: null,
                yAxisIndex: 0,
                seriesIndex: 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                click: void 0,
                marker: {
                    size: 4,
                    fillColor: "#fff",
                    strokeWidth: 2,
                    strokeColor: "#333",
                    shape: "circle",
                    offsetX: 0,
                    offsetY: 0,
                    radius: 2,
                    cssClass: ""
                },
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    offsetX: 0,
                    offsetY: 0,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    click: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                },
                customSVG: {
                    SVG: void 0,
                    cssClass: void 0,
                    offsetX: 0,
                    offsetY: 0
                },
                image: {
                    path: void 0,
                    width: 20,
                    height: 20,
                    offsetX: 0,
                    offsetY: 0
                }
            },
            this.yAxisAnnotation = {
                id: void 0,
                y: 0,
                y2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                width: "100%",
                yAxisIndex: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "end",
                    position: "right",
                    offsetX: 0,
                    offsetY: -3,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    click: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                }
            },
            this.xAxisAnnotation = {
                id: void 0,
                x: 0,
                x2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    orientation: "vertical",
                    position: "top",
                    offsetX: 0,
                    offsetY: 0,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    click: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                }
            },
            this.text = {
                x: 0,
                y: 0,
                text: "",
                textAnchor: "start",
                foreColor: void 0,
                fontSize: "13px",
                fontFamily: void 0,
                fontWeight: 400,
                appendTo: ".apexcharts-annotations",
                backgroundColor: "transparent",
                borderColor: "#c2c2c2",
                borderRadius: 0,
                borderWidth: 0,
                paddingLeft: 4,
                paddingRight: 4,
                paddingTop: 2,
                paddingBottom: 2
            }
        }
        return Te(C, [{
            key: "init",
            value: function() {
                return {
                    annotations: {
                        yaxis: [this.yAxisAnnotation],
                        xaxis: [this.xAxisAnnotation],
                        points: [this.pointAnnotation],
                        texts: [],
                        images: [],
                        shapes: []
                    },
                    chart: {
                        animations: {
                            enabled: !0,
                            easing: "easeinout",
                            speed: 800,
                            animateGradually: {
                                delay: 150,
                                enabled: !0
                            },
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 350
                            }
                        },
                        background: "transparent",
                        locales: [gt],
                        defaultLocale: "en",
                        dropShadow: {
                            enabled: !1,
                            enabledOnSeries: void 0,
                            top: 2,
                            left: 2,
                            blur: 4,
                            color: "#000",
                            opacity: .35
                        },
                        events: {
                            animationEnd: void 0,
                            beforeMount: void 0,
                            mounted: void 0,
                            updated: void 0,
                            click: void 0,
                            mouseMove: void 0,
                            mouseLeave: void 0,
                            xAxisLabelClick: void 0,
                            legendClick: void 0,
                            markerClick: void 0,
                            selection: void 0,
                            dataPointSelection: void 0,
                            dataPointMouseEnter: void 0,
                            dataPointMouseLeave: void 0,
                            beforeZoom: void 0,
                            beforeResetZoom: void 0,
                            zoomed: void 0,
                            scrolled: void 0,
                            brushScrolled: void 0
                        },
                        foreColor: "#373d3f",
                        fontFamily: "Helvetica, Arial, sans-serif",
                        height: "auto",
                        parentHeightOffset: 15,
                        redrawOnParentResize: !0,
                        redrawOnWindowResize: !0,
                        id: void 0,
                        group: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        selection: {
                            enabled: !1,
                            type: "x",
                            fill: {
                                color: "#24292e",
                                opacity: .1
                            },
                            stroke: {
                                width: 1,
                                color: "#24292e",
                                opacity: .4,
                                dashArray: 3
                            },
                            xaxis: {
                                min: void 0,
                                max: void 0
                            },
                            yaxis: {
                                min: void 0,
                                max: void 0
                            }
                        },
                        sparkline: {
                            enabled: !1
                        },
                        brush: {
                            enabled: !1,
                            autoScaleYaxis: !0,
                            target: void 0,
                            targets: void 0
                        },
                        stacked: !1,
                        stackType: "normal",
                        toolbar: {
                            show: !0,
                            offsetX: 0,
                            offsetY: 0,
                            tools: {
                                download: !0,
                                selection: !0,
                                zoom: !0,
                                zoomin: !0,
                                zoomout: !0,
                                pan: !0,
                                reset: !0,
                                customIcons: []
                            },
                            export: {
                                csv: {
                                    filename: void 0,
                                    columnDelimiter: ",",
                                    headerCategory: "category",
                                    headerValue: "value",
                                    dateFormatter: function(e) {
                                        return new Date(e).toDateString()
                                    }
                                },
                                png: {
                                    filename: void 0
                                },
                                svg: {
                                    filename: void 0
                                }
                            },
                            autoSelected: "zoom"
                        },
                        type: "line",
                        width: "100%",
                        zoom: {
                            enabled: !0,
                            type: "x",
                            autoScaleYaxis: !1,
                            zoomedArea: {
                                fill: {
                                    color: "#90CAF9",
                                    opacity: .4
                                },
                                stroke: {
                                    color: "#0D47A1",
                                    opacity: .4,
                                    width: 1
                                }
                            }
                        }
                    },
                    plotOptions: {
                        area: {
                            fillTo: "origin"
                        },
                        bar: {
                            horizontal: !1,
                            columnWidth: "70%",
                            barHeight: "70%",
                            distributed: !1,
                            borderRadius: 0,
                            borderRadiusApplication: "around",
                            borderRadiusWhenStacked: "last",
                            rangeBarOverlap: !0,
                            rangeBarGroupRows: !1,
                            hideZeroBarsWhenGrouped: !1,
                            isDumbbell: !1,
                            dumbbellColors: void 0,
                            isFunnel: !1,
                            isFunnel3d: !0,
                            colors: {
                                ranges: [],
                                backgroundBarColors: [],
                                backgroundBarOpacity: 1,
                                backgroundBarRadius: 0
                            },
                            dataLabels: {
                                position: "top",
                                maxItems: 100,
                                hideOverflowingLabels: !0,
                                orientation: "horizontal",
                                total: {
                                    enabled: !1,
                                    formatter: void 0,
                                    offsetX: 0,
                                    offsetY: 0,
                                    style: {
                                        color: "#373d3f",
                                        fontSize: "12px",
                                        fontFamily: void 0,
                                        fontWeight: 600
                                    }
                                }
                            }
                        },
                        bubble: {
                            zScaling: !0,
                            minBubbleRadius: void 0,
                            maxBubbleRadius: void 0
                        },
                        candlestick: {
                            colors: {
                                upward: "#00B746",
                                downward: "#EF403C"
                            },
                            wick: {
                                useFillColor: !0
                            }
                        },
                        boxPlot: {
                            colors: {
                                upper: "#00E396",
                                lower: "#008FFB"
                            }
                        },
                        heatmap: {
                            radius: 2,
                            enableShades: !0,
                            shadeIntensity: .5,
                            reverseNegativeShade: !1,
                            distributed: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        treemap: {
                            enableShades: !0,
                            shadeIntensity: .5,
                            distributed: !1,
                            reverseNegativeShade: !1,
                            useFillColorAsStroke: !1,
                            dataLabels: {
                                format: "scale"
                            },
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        radialBar: {
                            inverseOrder: !1,
                            startAngle: 0,
                            endAngle: 360,
                            offsetX: 0,
                            offsetY: 0,
                            hollow: {
                                margin: 5,
                                size: "50%",
                                background: "transparent",
                                image: void 0,
                                imageWidth: 150,
                                imageHeight: 150,
                                imageOffsetX: 0,
                                imageOffsetY: 0,
                                imageClipped: !0,
                                position: "front",
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            track: {
                                show: !0,
                                startAngle: void 0,
                                endAngle: void 0,
                                background: "#f2f2f2",
                                strokeWidth: "97%",
                                opacity: 1,
                                margin: 5,
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            dataLabels: {
                                show: !0,
                                name: {
                                    show: !0,
                                    fontSize: "16px",
                                    fontFamily: void 0,
                                    fontWeight: 600,
                                    color: void 0,
                                    offsetY: 0,
                                    formatter: function(e) {
                                        return e
                                    }
                                },
                                value: {
                                    show: !0,
                                    fontSize: "14px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    color: void 0,
                                    offsetY: 16,
                                    formatter: function(e) {
                                        return e + "%"
                                    }
                                },
                                total: {
                                    show: !1,
                                    label: "Total",
                                    fontSize: "16px",
                                    fontWeight: 600,
                                    fontFamily: void 0,
                                    color: void 0,
                                    formatter: function(e) {
                                        return e.globals.seriesTotals.reduce(function(t, i) {
                                            return t + i
                                        }, 0) / e.globals.series.length + "%"
                                    }
                                }
                            }
                        },
                        pie: {
                            customScale: 1,
                            offsetX: 0,
                            offsetY: 0,
                            startAngle: 0,
                            endAngle: 360,
                            expandOnClick: !0,
                            dataLabels: {
                                offset: 0,
                                minAngleToShowLabel: 10
                            },
                            donut: {
                                size: "65%",
                                background: "transparent",
                                labels: {
                                    show: !1,
                                    name: {
                                        show: !0,
                                        fontSize: "16px",
                                        fontFamily: void 0,
                                        fontWeight: 600,
                                        color: void 0,
                                        offsetY: -10,
                                        formatter: function(e) {
                                            return e
                                        }
                                    },
                                    value: {
                                        show: !0,
                                        fontSize: "20px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        color: void 0,
                                        offsetY: 10,
                                        formatter: function(e) {
                                            return e
                                        }
                                    },
                                    total: {
                                        show: !1,
                                        showAlways: !1,
                                        label: "Total",
                                        fontSize: "16px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        color: void 0,
                                        formatter: function(e) {
                                            return e.globals.seriesTotals.reduce(function(t, i) {
                                                return t + i
                                            }, 0)
                                        }
                                    }
                                }
                            }
                        },
                        polarArea: {
                            rings: {
                                strokeWidth: 1,
                                strokeColor: "#e8e8e8"
                            },
                            spokes: {
                                strokeWidth: 1,
                                connectorColors: "#e8e8e8"
                            }
                        },
                        radar: {
                            size: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            polygons: {
                                strokeWidth: 1,
                                strokeColors: "#e8e8e8",
                                connectorColors: "#e8e8e8",
                                fill: {
                                    colors: void 0
                                }
                            }
                        }
                    },
                    colors: void 0,
                    dataLabels: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        formatter: function(e) {
                            return null !== e ? e : ""
                        },
                        textAnchor: "middle",
                        distributed: !1,
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0,
                            fontWeight: 600,
                            colors: void 0
                        },
                        background: {
                            enabled: !0,
                            foreColor: "#fff",
                            borderRadius: 2,
                            padding: 4,
                            opacity: .9,
                            borderWidth: 1,
                            borderColor: "#fff",
                            dropShadow: {
                                enabled: !1,
                                top: 1,
                                left: 1,
                                blur: 1,
                                color: "#000",
                                opacity: .45
                            }
                        },
                        dropShadow: {
                            enabled: !1,
                            top: 1,
                            left: 1,
                            blur: 1,
                            color: "#000",
                            opacity: .45
                        }
                    },
                    fill: {
                        type: "solid",
                        colors: void 0,
                        opacity: .85,
                        gradient: {
                            shade: "dark",
                            type: "horizontal",
                            shadeIntensity: .5,
                            gradientToColors: void 0,
                            inverseColors: !0,
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [0, 50, 100],
                            colorStops: []
                        },
                        image: {
                            src: [],
                            width: void 0,
                            height: void 0
                        },
                        pattern: {
                            style: "squares",
                            width: 6,
                            height: 6,
                            strokeWidth: 2
                        }
                    },
                    forecastDataPoints: {
                        count: 0,
                        fillOpacity: .5,
                        strokeWidth: void 0,
                        dashArray: 4
                    },
                    grid: {
                        show: !0,
                        borderColor: "#e0e0e0",
                        strokeDashArray: 0,
                        position: "back",
                        xaxis: {
                            lines: {
                                show: !1
                            }
                        },
                        yaxis: {
                            lines: {
                                show: !0
                            }
                        },
                        row: {
                            colors: void 0,
                            opacity: .5
                        },
                        column: {
                            colors: void 0,
                            opacity: .5
                        },
                        padding: {
                            top: 0,
                            right: 10,
                            bottom: 0,
                            left: 12
                        }
                    },
                    labels: [],
                    legend: {
                        show: !0,
                        showForSingleSeries: !1,
                        showForNullSeries: !0,
                        showForZeroSeries: !0,
                        floating: !1,
                        position: "bottom",
                        horizontalAlign: "center",
                        inverseOrder: !1,
                        fontSize: "12px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        width: void 0,
                        height: void 0,
                        formatter: void 0,
                        tooltipHoverFormatter: void 0,
                        offsetX: -20,
                        offsetY: 4,
                        customLegendItems: [],
                        labels: {
                            colors: void 0,
                            useSeriesColors: !1
                        },
                        markers: {
                            width: 12,
                            height: 12,
                            strokeWidth: 0,
                            fillColors: void 0,
                            strokeColor: "#fff",
                            radius: 12,
                            customHTML: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            onClick: void 0
                        },
                        itemMargin: {
                            horizontal: 5,
                            vertical: 2
                        },
                        onItemClick: {
                            toggleDataSeries: !0
                        },
                        onItemHover: {
                            highlightDataSeries: !0
                        }
                    },
                    markers: {
                        discrete: [],
                        size: 0,
                        colors: void 0,
                        strokeColors: "#fff",
                        strokeWidth: 2,
                        strokeOpacity: .9,
                        strokeDashArray: 0,
                        fillOpacity: 1,
                        shape: "circle",
                        width: 8,
                        height: 8,
                        radius: 2,
                        offsetX: 0,
                        offsetY: 0,
                        onClick: void 0,
                        onDblClick: void 0,
                        showNullDataPoints: !0,
                        hover: {
                            size: void 0,
                            sizeOffset: 3
                        }
                    },
                    noData: {
                        text: void 0,
                        align: "center",
                        verticalAlign: "middle",
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            color: void 0,
                            fontSize: "14px",
                            fontFamily: void 0
                        }
                    },
                    responsive: [],
                    series: void 0,
                    states: {
                        normal: {
                            filter: {
                                type: "none",
                                value: 0
                            }
                        },
                        hover: {
                            filter: {
                                type: "lighten",
                                value: .1
                            }
                        },
                        active: {
                            allowMultipleDataPointsSelection: !1,
                            filter: {
                                type: "darken",
                                value: .5
                            }
                        }
                    },
                    title: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 0,
                        floating: !1,
                        style: {
                            fontSize: "14px",
                            fontWeight: 900,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    subtitle: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 30,
                        floating: !1,
                        style: {
                            fontSize: "12px",
                            fontWeight: 400,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    stroke: {
                        show: !0,
                        curve: "smooth",
                        lineCap: "butt",
                        width: 2,
                        colors: void 0,
                        dashArray: 0,
                        fill: {
                            type: "solid",
                            colors: void 0,
                            opacity: .85,
                            gradient: {
                                shade: "dark",
                                type: "horizontal",
                                shadeIntensity: .5,
                                gradientToColors: void 0,
                                inverseColors: !0,
                                opacityFrom: 1,
                                opacityTo: 1,
                                stops: [0, 50, 100],
                                colorStops: []
                            }
                        }
                    },
                    tooltip: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        shared: !0,
                        followCursor: !1,
                        intersect: !1,
                        inverseOrder: !1,
                        custom: void 0,
                        fillSeriesColor: !1,
                        theme: "light",
                        cssClass: "",
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0
                        },
                        onDatasetHover: {
                            highlightDataSeries: !1
                        },
                        x: {
                            show: !0,
                            format: "dd MMM",
                            formatter: void 0
                        },
                        y: {
                            formatter: void 0,
                            title: {
                                formatter: function(e) {
                                    return e ? e + ": " : ""
                                }
                            }
                        },
                        z: {
                            formatter: void 0,
                            title: "Size: "
                        },
                        marker: {
                            show: !0,
                            fillColors: void 0
                        },
                        items: {
                            display: "flex"
                        },
                        fixed: {
                            enabled: !1,
                            position: "topRight",
                            offsetX: 0,
                            offsetY: 0
                        }
                    },
                    xaxis: {
                        type: "category",
                        categories: [],
                        convertedCatToNumeric: !1,
                        offsetX: 0,
                        offsetY: 0,
                        overwriteCategories: void 0,
                        labels: {
                            show: !0,
                            rotate: -45,
                            rotateAlways: !1,
                            hideOverlappingLabels: !0,
                            trim: !1,
                            minHeight: void 0,
                            maxHeight: 120,
                            showDuplicates: !0,
                            style: {
                                colors: [],
                                fontSize: "12px",
                                fontWeight: 400,
                                fontFamily: void 0,
                                cssClass: ""
                            },
                            offsetX: 0,
                            offsetY: 0,
                            format: void 0,
                            formatter: void 0,
                            datetimeUTC: !0,
                            datetimeFormatter: {
                                year: "yyyy",
                                month: "MMM 'yy",
                                day: "dd MMM",
                                hour: "HH:mm",
                                minute: "HH:mm:ss",
                                second: "HH:mm:ss"
                            }
                        },
                        group: {
                            groups: [],
                            style: {
                                colors: [],
                                fontSize: "12px",
                                fontWeight: 400,
                                fontFamily: void 0,
                                cssClass: ""
                            }
                        },
                        axisBorder: {
                            show: !0,
                            color: "#e0e0e0",
                            width: "100%",
                            height: 1,
                            offsetX: 0,
                            offsetY: 0
                        },
                        axisTicks: {
                            show: !0,
                            color: "#e0e0e0",
                            height: 6,
                            offsetX: 0,
                            offsetY: 0
                        },
                        tickAmount: void 0,
                        tickPlacement: "on",
                        min: void 0,
                        max: void 0,
                        range: void 0,
                        floating: !1,
                        decimalsInFloat: void 0,
                        position: "bottom",
                        title: {
                            text: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            style: {
                                color: void 0,
                                fontSize: "12px",
                                fontWeight: 900,
                                fontFamily: void 0,
                                cssClass: ""
                            }
                        },
                        crosshairs: {
                            show: !0,
                            width: 1,
                            position: "back",
                            opacity: .9,
                            stroke: {
                                color: "#b6b6b6",
                                width: 1,
                                dashArray: 3
                            },
                            fill: {
                                type: "solid",
                                color: "#B1B9C4",
                                gradient: {
                                    colorFrom: "#D8E3F0",
                                    colorTo: "#BED1E6",
                                    stops: [0, 100],
                                    opacityFrom: .4,
                                    opacityTo: .5
                                }
                            },
                            dropShadow: {
                                enabled: !1,
                                left: 0,
                                top: 0,
                                blur: 1,
                                opacity: .4
                            }
                        },
                        tooltip: {
                            enabled: !0,
                            offsetY: 0,
                            formatter: void 0,
                            style: {
                                fontSize: "12px",
                                fontFamily: void 0
                            }
                        }
                    },
                    yaxis: this.yAxis,
                    theme: {
                        mode: "light",
                        palette: "palette1",
                        monochrome: {
                            enabled: !1,
                            color: "#008FFB",
                            shadeTo: "light",
                            shadeIntensity: .65
                        }
                    }
                }
            }
        }]),
        C
    }()
      , Kt = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.graphics = new U(this.ctx),
            this.w.globals.isBarHorizontal && (this.invertAxis = !0),
            this.helpers = new he(this),
            this.xAxisAnnotations = new m(this),
            this.yAxisAnnotations = new Ce(this),
            this.pointsAnnotations = new qe(this),
            this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0),
            this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
        }
        return Te(C, [{
            key: "drawAxesAnnotations",
            value: function() {
                var e = this.w;
                if (e.globals.axisCharts) {
                    for (var t = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a = this.pointsAnnotations.drawPointAnnotations(), s = e.config.chart.animations.enabled, r = [t, i, a], n = [i.node, t.node, a.node], o = 0; o < 3; o++)
                        e.globals.dom.elGraphical.add(r[o]),
                        !s || e.globals.resized || e.globals.dataChanged || "scatter" !== e.config.chart.type && "bubble" !== e.config.chart.type && e.globals.dataPoints > 1 && n[o].classList.add("apexcharts-element-hidden"),
                        e.globals.delayedElements.push({
                            el: n[o],
                            index: 0
                        });
                    this.helpers.annotationsBackground()
                }
            }
        }, {
            key: "drawImageAnnos",
            value: function() {
                var e = this;
                this.w.config.annotations.images.map(function(t, i) {
                    e.addImage(t, i)
                })
            }
        }, {
            key: "drawTextAnnos",
            value: function() {
                var e = this;
                this.w.config.annotations.texts.map(function(t, i) {
                    e.addText(t, i)
                })
            }
        }, {
            key: "addXaxisAnnotation",
            value: function(e, t, i) {
                this.xAxisAnnotations.addXaxisAnnotation(e, t, i)
            }
        }, {
            key: "addYaxisAnnotation",
            value: function(e, t, i) {
                this.yAxisAnnotations.addYaxisAnnotation(e, t, i)
            }
        }, {
            key: "addPointAnnotation",
            value: function(e, t, i) {
                this.pointsAnnotations.addPointAnnotation(e, t, i)
            }
        }, {
            key: "addText",
            value: function(e, t) {
                var s = e.text
                  , p = e.backgroundColor
                  , x = e.borderWidth
                  , b = e.strokeDashArray
                  , k = e.borderRadius
                  , S = e.borderColor
                  , E = e.appendTo
                  , M = void 0 === E ? ".apexcharts-annotations" : E
                  , l = e.paddingLeft
                  , f = void 0 === l ? 4 : l
                  , w = e.paddingRight
                  , _ = void 0 === w ? 4 : w
                  , R = e.paddingBottom
                  , H = void 0 === R ? 2 : R
                  , B = e.paddingTop
                  , j = void 0 === B ? 2 : B
                  , ce = this.w
                  , me = this.graphics.drawText({
                    x: e.x,
                    y: e.y,
                    text: s,
                    textAnchor: e.textAnchor || "start",
                    fontSize: e.fontSize || "12px",
                    fontWeight: e.fontWeight || "regular",
                    fontFamily: e.fontFamily || ce.config.chart.fontFamily,
                    foreColor: e.foreColor || ce.config.chart.foreColor,
                    cssClass: e.cssClass
                })
                  , ue = ce.globals.dom.baseEl.querySelector(M);
                ue && ue.appendChild(me.node);
                var Ee = me.bbox();
                if (s) {
                    var Ie = this.graphics.drawRect(Ee.x - f, Ee.y - j, Ee.width + f + _, Ee.height + H + j, k, p || "transparent", 1, x, S, b);
                    ue.insertBefore(Ie.node, me.node)
                }
            }
        }, {
            key: "addImage",
            value: function(e, t) {
                var i = this.w
                  , s = e.x
                  , r = void 0 === s ? 0 : s
                  , n = e.y
                  , o = void 0 === n ? 0 : n
                  , h = e.width
                  , d = void 0 === h ? 20 : h
                  , u = e.height
                  , p = void 0 === u ? 20 : u
                  , x = e.appendTo
                  , b = void 0 === x ? ".apexcharts-annotations" : x
                  , k = i.globals.dom.Paper.image(e.path);
                k.size(d, p).move(r, o);
                var S = i.globals.dom.baseEl.querySelector(b);
                return S && S.appendChild(k.node),
                k
            }
        }, {
            key: "addXaxisAnnotationExternal",
            value: function(e, t, i) {
                return this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: i,
                    type: "xaxis",
                    contextMethod: i.addXaxisAnnotation
                }),
                i
            }
        }, {
            key: "addYaxisAnnotationExternal",
            value: function(e, t, i) {
                return this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: i,
                    type: "yaxis",
                    contextMethod: i.addYaxisAnnotation
                }),
                i
            }
        }, {
            key: "addPointAnnotationExternal",
            value: function(e, t, i) {
                return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal),
                this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: i,
                    type: "point",
                    contextMethod: i.addPointAnnotation
                }),
                i
            }
        }, {
            key: "addAnnotationExternal",
            value: function(e) {
                var t = e.params
                  , i = e.pushToMemory
                  , a = e.context
                  , s = e.type
                  , r = e.contextMethod
                  , n = a
                  , o = n.w
                  , h = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations"))
                  , d = h.childNodes.length + 1
                  , u = new kt
                  , p = Object.assign({}, "xaxis" === s ? u.xAxisAnnotation : "yaxis" === s ? u.yAxisAnnotation : u.pointAnnotation)
                  , x = D.extend(p, t);
                switch (s) {
                case "xaxis":
                    this.addXaxisAnnotation(x, h, d);
                    break;
                case "yaxis":
                    this.addYaxisAnnotation(x, h, d);
                    break;
                case "point":
                    this.addPointAnnotation(x, h, d)
                }
                var b = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(d, "']"))
                  , k = this.helpers.addBackgroundToAnno(b, x);
                return k && h.insertBefore(k.node, b),
                i && o.globals.memory.methodsToExec.push({
                    context: n,
                    id: x.id ? x.id : D.randomId(),
                    method: r,
                    label: "addAnnotation",
                    params: t
                }),
                a
            }
        }, {
            key: "clearAnnotations",
            value: function(e) {
                var t = e.w
                  , i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                t.globals.memory.methodsToExec.map(function(a, s) {
                    "addText" !== a.label && "addAnnotation" !== a.label || t.globals.memory.methodsToExec.splice(s, 1)
                }),
                i = D.listToArray(i),
                Array.prototype.forEach.call(i, function(a) {
                    for (; a.firstChild; )
                        a.removeChild(a.firstChild)
                })
            }
        }, {
            key: "removeAnnotation",
            value: function(e, t) {
                var i = e.w
                  , a = i.globals.dom.baseEl.querySelectorAll(".".concat(t));
                a && (i.globals.memory.methodsToExec.map(function(s, r) {
                    s.id === t && i.globals.memory.methodsToExec.splice(r, 1)
                }),
                Array.prototype.forEach.call(a, function(s) {
                    s.parentElement.removeChild(s)
                }))
            }
        }]),
        C
    }()
      , We = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.months31 = [1, 3, 5, 7, 8, 10, 12],
            this.months30 = [2, 4, 6, 9, 11],
            this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        }
        return Te(C, [{
            key: "isValidDate",
            value: function(e) {
                return !isNaN(this.parseDate(e))
            }
        }, {
            key: "getTimeStamp",
            value: function(e) {
                return Date.parse(e) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)).getTime() : new Date(e).getTime() : e
            }
        }, {
            key: "getDate",
            value: function(e) {
                return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e)
            }
        }, {
            key: "parseDate",
            value: function(e) {
                var t = Date.parse(e);
                if (!isNaN(t))
                    return this.getTimeStamp(e);
                var i = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                return this.getTimeStamp(i)
            }
        }, {
            key: "parseDateWithTimezone",
            value: function(e) {
                return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
            }
        }, {
            key: "formatDate",
            value: function(e, t) {
                var i = this.w.globals.locale
                  , a = this.w.config.xaxis.labels.datetimeUTC
                  , s = ["\0"].concat(J(i.months))
                  , r = ["\x01"].concat(J(i.shortMonths))
                  , n = ["\x02"].concat(J(i.days))
                  , o = ["\x03"].concat(J(i.shortDays));
                function h(H, B) {
                    var j = H + "";
                    for (B = B || 2; j.length < B; )
                        j = "0" + j;
                    return j
                }
                var d = a ? e.getUTCFullYear() : e.getFullYear();
                t = (t = (t = t.replace(/(^|[^\\])yyyy+/g, "$1" + d)).replace(/(^|[^\\])yy/g, "$1" + d.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + d);
                var u = (a ? e.getUTCMonth() : e.getMonth()) + 1;
                t = (t = (t = (t = t.replace(/(^|[^\\])MMMM+/g, "$1" + s[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + h(u))).replace(/(^|[^\\])M/g, "$1" + u);
                var p = a ? e.getUTCDate() : e.getDate();
                t = (t = (t = (t = t.replace(/(^|[^\\])dddd+/g, "$1" + n[0])).replace(/(^|[^\\])ddd/g, "$1" + o[0])).replace(/(^|[^\\])dd/g, "$1" + h(p))).replace(/(^|[^\\])d/g, "$1" + p);
                var x = a ? e.getUTCHours() : e.getHours()
                  , b = x > 12 ? x - 12 : 0 === x ? 12 : x;
                t = (t = (t = (t = t.replace(/(^|[^\\])HH+/g, "$1" + h(x))).replace(/(^|[^\\])H/g, "$1" + x)).replace(/(^|[^\\])hh+/g, "$1" + h(b))).replace(/(^|[^\\])h/g, "$1" + b);
                var k = a ? e.getUTCMinutes() : e.getMinutes();
                t = (t = t.replace(/(^|[^\\])mm+/g, "$1" + h(k))).replace(/(^|[^\\])m/g, "$1" + k);
                var S = a ? e.getUTCSeconds() : e.getSeconds();
                t = (t = t.replace(/(^|[^\\])ss+/g, "$1" + h(S))).replace(/(^|[^\\])s/g, "$1" + S);
                var E = a ? e.getUTCMilliseconds() : e.getMilliseconds();
                t = t.replace(/(^|[^\\])fff+/g, "$1" + h(E, 3)),
                E = Math.round(E / 10),
                t = t.replace(/(^|[^\\])ff/g, "$1" + h(E)),
                E = Math.round(E / 10);
                var M = x < 12 ? "AM" : "PM";
                t = (t = (t = t.replace(/(^|[^\\])f/g, "$1" + E)).replace(/(^|[^\\])TT+/g, "$1" + M)).replace(/(^|[^\\])T/g, "$1" + M.charAt(0));
                var l = M.toLowerCase();
                t = (t = t.replace(/(^|[^\\])tt+/g, "$1" + l)).replace(/(^|[^\\])t/g, "$1" + l.charAt(0));
                var f = -e.getTimezoneOffset()
                  , w = a || !f ? "Z" : f > 0 ? "+" : "-";
                if (!a) {
                    var _ = (f = Math.abs(f)) % 60;
                    w += h(Math.floor(f / 60)) + ":" + h(_)
                }
                t = t.replace(/(^|[^\\])K/g, "$1" + w);
                var R = (a ? e.getUTCDay() : e.getDay()) + 1;
                return (t = (t = (t = (t = t.replace(new RegExp(n[0],"g"), n[R])).replace(new RegExp(o[0],"g"), o[R])).replace(new RegExp(s[0],"g"), s[u])).replace(new RegExp(r[0],"g"), r[u])).replace(/\\(.)/g, "$1")
            }
        }, {
            key: "getTimeUnitsfromTimestamp",
            value: function(e, t, i) {
                var a = this.w;
                void 0 !== a.config.xaxis.min && (e = a.config.xaxis.min),
                void 0 !== a.config.xaxis.max && (t = a.config.xaxis.max);
                var s = this.getDate(e)
                  , r = this.getDate(t)
                  , n = this.formatDate(s, "yyyy MM dd HH mm ss fff").split(" ")
                  , o = this.formatDate(r, "yyyy MM dd HH mm ss fff").split(" ");
                return {
                    minMillisecond: parseInt(n[6], 10),
                    maxMillisecond: parseInt(o[6], 10),
                    minSecond: parseInt(n[5], 10),
                    maxSecond: parseInt(o[5], 10),
                    minMinute: parseInt(n[4], 10),
                    maxMinute: parseInt(o[4], 10),
                    minHour: parseInt(n[3], 10),
                    maxHour: parseInt(o[3], 10),
                    minDate: parseInt(n[2], 10),
                    maxDate: parseInt(o[2], 10),
                    minMonth: parseInt(n[1], 10) - 1,
                    maxMonth: parseInt(o[1], 10) - 1,
                    minYear: parseInt(n[0], 10),
                    maxYear: parseInt(o[0], 10)
                }
            }
        }, {
            key: "isLeapYear",
            value: function(e) {
                return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
            }
        }, {
            key: "calculcateLastDaysOfMonth",
            value: function(e, t, i) {
                return this.determineDaysOfMonths(e, t) - i
            }
        }, {
            key: "determineDaysOfYear",
            value: function(e) {
                var t = 365;
                return this.isLeapYear(e) && (t = 366),
                t
            }
        }, {
            key: "determineRemainingDaysOfYear",
            value: function(e, t, i) {
                var a = this.daysCntOfYear[t] + i;
                return t > 1 && this.isLeapYear() && a++,
                a
            }
        }, {
            key: "determineDaysOfMonths",
            value: function(e, t) {
                var i = 30;
                switch (e = D.monthMod(e),
                !0) {
                case this.months30.indexOf(e) > -1:
                    2 === e && (i = this.isLeapYear(t) ? 29 : 28);
                    break;
                case this.months31.indexOf(e) > -1:
                default:
                    i = 31
                }
                return i
            }
        }]),
        C
    }()
      , At = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.tooltipKeyFormat = "dd MMM"
        }
        return Te(C, [{
            key: "xLabelFormat",
            value: function(e, t, i, a) {
                var s = this.w;
                if ("datetime" === s.config.xaxis.type && void 0 === s.config.xaxis.labels.formatter && void 0 === s.config.tooltip.x.formatter) {
                    var r = new We(this.ctx);
                    return r.formatDate(r.getDate(t), s.config.tooltip.x.format)
                }
                return e(t, i, a)
            }
        }, {
            key: "defaultGeneralFormatter",
            value: function(e) {
                return Array.isArray(e) ? e.map(function(t) {
                    return t
                }) : e
            }
        }, {
            key: "defaultYFormatter",
            value: function(e, t, i) {
                var a = this.w;
                return D.isNumber(e) && (e = e.toFixed(0 !== a.globals.yValueDecimal ? void 0 !== t.decimalsInFloat ? t.decimalsInFloat : a.globals.yValueDecimal : a.globals.maxYArr[i] - a.globals.minYArr[i] < 5 ? 1 : 0)),
                e
            }
        }, {
            key: "setLabelFormatters",
            value: function() {
                var e = this
                  , t = this.w;
                return t.globals.xaxisTooltipFormatter = function(i) {
                    return e.defaultGeneralFormatter(i)
                }
                ,
                t.globals.ttKeyFormatter = function(i) {
                    return e.defaultGeneralFormatter(i)
                }
                ,
                t.globals.ttZFormatter = function(i) {
                    return i
                }
                ,
                t.globals.legendFormatter = function(i) {
                    return e.defaultGeneralFormatter(i)
                }
                ,
                t.globals.xLabelFormatter = void 0 !== t.config.xaxis.labels.formatter ? t.config.xaxis.labels.formatter : function(i) {
                    if (D.isNumber(i)) {
                        if (!t.config.xaxis.convertedCatToNumeric && "numeric" === t.config.xaxis.type) {
                            if (D.isNumber(t.config.xaxis.decimalsInFloat))
                                return i.toFixed(t.config.xaxis.decimalsInFloat);
                            var a = t.globals.maxX - t.globals.minX;
                            return i.toFixed(a > 0 && a < 100 ? 1 : 0)
                        }
                        return i.toFixed(t.globals.isBarHorizontal && t.globals.maxY - t.globals.minYArr < 4 ? 1 : 0)
                    }
                    return i
                }
                ,
                t.globals.ttKeyFormatter = "function" == typeof t.config.tooltip.x.formatter ? t.config.tooltip.x.formatter : t.globals.xLabelFormatter,
                "function" == typeof t.config.xaxis.tooltip.formatter && (t.globals.xaxisTooltipFormatter = t.config.xaxis.tooltip.formatter),
                (Array.isArray(t.config.tooltip.y) || void 0 !== t.config.tooltip.y.formatter) && (t.globals.ttVal = t.config.tooltip.y),
                void 0 !== t.config.tooltip.z.formatter && (t.globals.ttZFormatter = t.config.tooltip.z.formatter),
                void 0 !== t.config.legend.formatter && (t.globals.legendFormatter = t.config.legend.formatter),
                t.config.yaxis.forEach(function(i, a) {
                    t.globals.yLabelFormatters[a] = void 0 !== i.labels.formatter ? i.labels.formatter : function(s) {
                        return t.globals.xyCharts ? Array.isArray(s) ? s.map(function(r) {
                            return e.defaultYFormatter(r, i, a)
                        }) : e.defaultYFormatter(s, i, a) : s
                    }
                }),
                t.globals
            }
        }, {
            key: "heatmapLabelFormatters",
            value: function() {
                var e = this.w;
                if ("heatmap" === e.config.chart.type) {
                    e.globals.yAxisScale[0].result = e.globals.seriesNames.slice();
                    var t = e.globals.seriesNames.reduce(function(i, a) {
                        return i.length > a.length ? i : a
                    }, 0);
                    e.globals.yAxisScale[0].niceMax = t,
                    e.globals.yAxisScale[0].niceMin = t
                }
            }
        }]),
        C
    }()
      , Oe = function(C) {
        var e, t = C.isTimeline, i = C.ctx, a = C.seriesIndex, s = C.dataPointIndex, r = C.y1, n = C.y2, o = C.w, h = o.globals.seriesRangeStart[a][s], d = o.globals.seriesRangeEnd[a][s], u = o.globals.labels[s], p = o.config.series[a].name ? o.config.series[a].name : "", x = o.globals.ttKeyFormatter, b = o.config.tooltip.y.title.formatter, k = {
            w: o,
            seriesIndex: a,
            dataPointIndex: s,
            start: h,
            end: d
        };
        "function" == typeof b && (p = b(p, k)),
        null !== (e = o.config.series[a].data[s]) && void 0 !== e && e.x && (u = o.config.series[a].data[s].x),
        t || "datetime" === o.config.xaxis.type && (u = new At(i).xLabelFormat(o.globals.ttKeyFormatter, u, u, {
            i: void 0,
            dateFormatter: new We(i).formatDate,
            w: o
        })),
        "function" == typeof x && (u = x(u, k)),
        Number.isFinite(r) && Number.isFinite(n) && (h = r,
        d = n);
        var S = ""
          , E = ""
          , M = o.globals.colors[a];
        if (void 0 === o.config.tooltip.x.formatter)
            if ("datetime" === o.config.xaxis.type) {
                var l = new We(i);
                S = l.formatDate(l.getDate(h), o.config.tooltip.x.format),
                E = l.formatDate(l.getDate(d), o.config.tooltip.x.format)
            } else
                S = h,
                E = d;
        else
            S = o.config.tooltip.x.formatter(h),
            E = o.config.tooltip.x.formatter(d);
        return {
            start: h,
            end: d,
            startVal: S,
            endVal: E,
            ylabel: u,
            color: M,
            seriesName: p
        }
    }
      , pt = function(C) {
        var e = C.color
          , t = C.seriesName
          , i = C.ylabel
          , a = C.start
          , s = C.end
          , r = C.seriesIndex
          , n = C.dataPointIndex
          , o = C.ctx.tooltip.tooltipLabels.getFormatters(r);
        a = o.yLbFormatter(a),
        s = o.yLbFormatter(s);
        var h = o.yLbFormatter(C.w.globals.series[r][n])
          , d = '<span class="value start-value">\n  '.concat(a, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(s, "\n  </span>");
        return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e + '">' + (t || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (C.w.globals.comboCharts ? "rangeArea" === C.w.config.series[r].type || "rangeBar" === C.w.config.series[r].type ? d : "<span>".concat(h, "</span>") : d) + " </div></div>"
    }
      , xt = function() {
        function C(e) {
            Q(this, C),
            this.opts = e
        }
        return Te(C, [{
            key: "hideYAxis",
            value: function() {
                this.opts.yaxis[0].show = !1,
                this.opts.yaxis[0].title.text = "",
                this.opts.yaxis[0].axisBorder.show = !1,
                this.opts.yaxis[0].axisTicks.show = !1,
                this.opts.yaxis[0].floating = !0
            }
        }, {
            key: "line",
            value: function() {
                return {
                    chart: {
                        animations: {
                            easing: "swing"
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 5,
                        curve: "straight"
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "sparkline",
            value: function(e) {
                return this.hideYAxis(),
                D.extend(e, {
                    grid: {
                        show: !1,
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    legend: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        },
                        axisBorder: {
                            show: !1
                        },
                        axisTicks: {
                            show: !1
                        }
                    },
                    chart: {
                        toolbar: {
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    }
                })
            }
        }, {
            key: "bar",
            value: function() {
                return {
                    chart: {
                        stacked: !1,
                        animations: {
                            easing: "swing"
                        }
                    },
                    plotOptions: {
                        bar: {
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        }
                    },
                    stroke: {
                        width: 0,
                        lineCap: "round"
                    },
                    fill: {
                        opacity: .85
                    },
                    legend: {
                        markers: {
                            shape: "square",
                            radius: 2,
                            size: 8
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        },
                        tickPlacement: "between",
                        crosshairs: {
                            width: "barWidth",
                            position: "back",
                            fill: {
                                type: "gradient"
                            },
                            dropShadow: {
                                enabled: !1
                            },
                            stroke: {
                                width: 0
                            }
                        }
                    }
                }
            }
        }, {
            key: "funnel",
            value: function() {
                return this.hideYAxis(),
                K(K({}, this.bar()), {}, {
                    chart: {
                        animations: {
                            easing: "linear",
                            speed: 800,
                            animateGradually: {
                                enabled: !1
                            }
                        }
                    },
                    plotOptions: {
                        bar: {
                            horizontal: !0,
                            borderRadiusApplication: "around",
                            borderRadius: 0,
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    grid: {
                        show: !1,
                        padding: {
                            left: 0,
                            right: 0
                        }
                    },
                    xaxis: {
                        labels: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        },
                        axisBorder: {
                            show: !1
                        },
                        axisTicks: {
                            show: !1
                        }
                    }
                })
            }
        }, {
            key: "candlestick",
            value: function() {
                var e = this;
                return {
                    stroke: {
                        width: 1,
                        colors: ["#333"]
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(t) {
                            return e._getBoxTooltip(t.w, t.seriesIndex, t.dataPointIndex, ["Open", "High", "", "Low", "Close"], "candlestick")
                        }
                    },
                    states: {
                        active: {
                            filter: {
                                type: "none"
                            }
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "boxPlot",
            value: function() {
                var e = this;
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !1
                            }
                        }
                    },
                    stroke: {
                        width: 1,
                        colors: ["#24292e"]
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(t) {
                            return e._getBoxTooltip(t.w, t.seriesIndex, t.dataPointIndex, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
                        }
                    },
                    markers: {
                        size: 5,
                        strokeWidth: 1,
                        strokeColors: "#111"
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "rangeBar",
            value: function() {
                return {
                    chart: {
                        animations: {
                            animateGradually: !1
                        }
                    },
                    stroke: {
                        width: 0,
                        lineCap: "square"
                    },
                    plotOptions: {
                        bar: {
                            borderRadius: 0,
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        enabled: !1,
                        formatter: function(e, t) {
                            var i = t.seriesIndex
                              , a = t.dataPointIndex
                              , s = t.w
                              , r = function() {
                                return s.globals.seriesRangeEnd[i][a] - s.globals.seriesRangeStart[i][a]
                            };
                            return s.globals.comboCharts ? "rangeBar" === s.config.series[i].type || "rangeArea" === s.config.series[i].type ? r() : e : r()
                        },
                        background: {
                            enabled: !1
                        },
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    markers: {
                        size: 10
                    },
                    tooltip: {
                        shared: !1,
                        followCursor: !0,
                        custom: function(e) {
                            return e.w.config.plotOptions && e.w.config.plotOptions.bar && e.w.config.plotOptions.bar.horizontal ? (a = (i = Oe(K(K({}, t = e), {}, {
                                isTimeline: !0
                            }))).color,
                            s = i.seriesName,
                            r = i.ylabel,
                            n = i.startVal,
                            o = i.endVal,
                            pt(K(K({}, t), {}, {
                                color: a,
                                seriesName: s,
                                ylabel: r,
                                start: n,
                                end: o
                            }))) : function(t) {
                                var i = Oe(t)
                                  , a = i.color
                                  , s = i.seriesName
                                  , r = i.ylabel
                                  , n = i.start
                                  , o = i.end;
                                return pt(K(K({}, t), {}, {
                                    color: a,
                                    seriesName: s,
                                    ylabel: r,
                                    start: n,
                                    end: o
                                }))
                            }(e);
                            var t, i, a, s, r, n, o
                        }
                    },
                    xaxis: {
                        tickPlacement: "between",
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            stroke: {
                                width: 0
                            }
                        }
                    }
                }
            }
        }, {
            key: "dumbbell",
            value: function(e) {
                var t, i;
                return null !== (t = e.plotOptions.bar) && void 0 !== t && t.barHeight || (e.plotOptions.bar.barHeight = 2),
                null !== (i = e.plotOptions.bar) && void 0 !== i && i.columnWidth || (e.plotOptions.bar.columnWidth = 2),
                e
            }
        }, {
            key: "area",
            value: function() {
                return {
                    stroke: {
                        width: 4,
                        fill: {
                            type: "solid",
                            gradient: {
                                inverseColors: !1,
                                shade: "light",
                                type: "vertical",
                                opacityFrom: .65,
                                opacityTo: .5,
                                stops: [0, 100, 100]
                            }
                        }
                    },
                    fill: {
                        type: "gradient",
                        gradient: {
                            inverseColors: !1,
                            shade: "light",
                            type: "vertical",
                            opacityFrom: .65,
                            opacityTo: .5,
                            stops: [0, 100, 100]
                        }
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    tooltip: {
                        followCursor: !1
                    }
                }
            }
        }, {
            key: "rangeArea",
            value: function() {
                return {
                    stroke: {
                        curve: "straight",
                        width: 0
                    },
                    fill: {
                        type: "solid",
                        opacity: .6
                    },
                    markers: {
                        size: 0
                    },
                    states: {
                        hover: {
                            filter: {
                                type: "none"
                            }
                        },
                        active: {
                            filter: {
                                type: "none"
                            }
                        }
                    },
                    tooltip: {
                        intersect: !1,
                        shared: !0,
                        followCursor: !0,
                        custom: function(e) {
                            return a = (i = Oe(t = e)).color,
                            s = i.seriesName,
                            r = i.ylabel,
                            n = i.start,
                            o = i.end,
                            pt(K(K({}, t), {}, {
                                color: a,
                                seriesName: s,
                                ylabel: r,
                                start: n,
                                end: o
                            }));
                            var t, i, a, s, r, n, o
                        }
                    }
                }
            }
        }, {
            key: "brush",
            value: function(e) {
                return D.extend(e, {
                    chart: {
                        toolbar: {
                            autoSelected: "selection",
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 1
                    },
                    tooltip: {
                        enabled: !1
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        }
                    }
                })
            }
        }, {
            key: "stacked100",
            value: function(e) {
                e.dataLabels = e.dataLabels || {},
                e.dataLabels.formatter = e.dataLabels.formatter || void 0;
                var t = e.dataLabels.formatter;
                return e.yaxis.forEach(function(i, a) {
                    e.yaxis[a].min = 0,
                    e.yaxis[a].max = 100
                }),
                "bar" === e.chart.type && (e.dataLabels.formatter = t || function(i) {
                    return "number" == typeof i && i ? i.toFixed(0) + "%" : i
                }
                ),
                e
            }
        }, {
            key: "stackedBars",
            value: function() {
                var e = this.bar();
                return K(K({}, e), {}, {
                    plotOptions: K(K({}, e.plotOptions), {}, {
                        bar: K(K({}, e.plotOptions.bar), {}, {
                            borderRadiusApplication: "end",
                            borderRadiusWhenStacked: "last"
                        })
                    })
                })
            }
        }, {
            key: "convertCatToNumeric",
            value: function(e) {
                return e.xaxis.convertedCatToNumeric = !0,
                e
            }
        }, {
            key: "convertCatToNumericXaxis",
            value: function(e, t, i) {
                e.xaxis.type = "numeric",
                e.xaxis.labels = e.xaxis.labels || {},
                e.xaxis.labels.formatter = e.xaxis.labels.formatter || function(r) {
                    return D.isNumber(r) ? Math.floor(r) : r
                }
                ;
                var a = e.xaxis.labels.formatter
                  , s = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
                return i && i.length && (s = i.map(function(r) {
                    return Array.isArray(r) ? r : String(r)
                })),
                s && s.length && (e.xaxis.labels.formatter = function(r) {
                    return D.isNumber(r) ? a(s[Math.floor(r) - 1]) : a(r)
                }
                ),
                e.xaxis.categories = [],
                e.labels = [],
                e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints",
                e
            }
        }, {
            key: "bubble",
            value: function() {
                return {
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        crosshairs: {
                            width: 0
                        }
                    },
                    fill: {
                        type: "solid",
                        gradient: {
                            shade: "light",
                            inverse: !0,
                            shadeIntensity: .55,
                            opacityFrom: .4,
                            opacityTo: .8
                        }
                    }
                }
            }
        }, {
            key: "scatter",
            value: function() {
                return {
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    markers: {
                        size: 6,
                        strokeWidth: 1,
                        hover: {
                            sizeOffset: 2
                        }
                    }
                }
            }
        }, {
            key: "heatmap",
            value: function() {
                return {
                    chart: {
                        stacked: !1
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    tooltip: {
                        followCursor: !0,
                        marker: {
                            show: !1
                        },
                        x: {
                            show: !1
                        }
                    },
                    legend: {
                        position: "top",
                        markers: {
                            shape: "square",
                            size: 10,
                            offsetY: 2
                        }
                    },
                    grid: {
                        padding: {
                            right: 20
                        }
                    }
                }
            }
        }, {
            key: "treemap",
            value: function() {
                return {
                    chart: {
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        style: {
                            fontSize: 14,
                            fontWeight: 600,
                            colors: ["#fff"]
                        }
                    },
                    stroke: {
                        show: !0,
                        width: 2,
                        colors: ["#fff"]
                    },
                    legend: {
                        show: !1
                    },
                    fill: {
                        gradient: {
                            stops: [0, 100]
                        }
                    },
                    tooltip: {
                        followCursor: !0,
                        x: {
                            show: !1
                        }
                    },
                    grid: {
                        padding: {
                            left: 0,
                            right: 0
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        }
                    }
                }
            }
        }, {
            key: "pie",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    plotOptions: {
                        pie: {
                            donut: {
                                labels: {
                                    show: !1
                                }
                            }
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            stops: [0, 100]
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "donut",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            shadeIntensity: .35,
                            stops: [80, 100],
                            opacityFrom: 1,
                            opacityTo: 1
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "polarArea",
            value: function() {
                return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6,
                {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        enabled: !1
                    },
                    stroke: {
                        show: !0,
                        width: 2
                    },
                    fill: {
                        opacity: .7
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "radar",
            value: function() {
                return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6,
                {
                    dataLabels: {
                        enabled: !1,
                        style: {
                            fontSize: "11px"
                        }
                    },
                    stroke: {
                        width: 2
                    },
                    markers: {
                        size: 3,
                        strokeWidth: 1,
                        strokeOpacity: 1
                    },
                    fill: {
                        opacity: .2
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0,
                        followCursor: !0
                    },
                    grid: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            formatter: function(e) {
                                return e
                            },
                            style: {
                                colors: ["#a8a8a8"],
                                fontSize: "11px"
                            }
                        },
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            show: !1
                        }
                    }
                }
            }
        }, {
            key: "radialBar",
            value: function() {
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 800
                            }
                        },
                        toolbar: {
                            show: !1
                        }
                    },
                    fill: {
                        gradient: {
                            shade: "dark",
                            shadeIntensity: .4,
                            inverseColors: !1,
                            type: "diagonal2",
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [70, 98, 100]
                        }
                    },
                    legend: {
                        show: !1,
                        position: "right"
                    },
                    tooltip: {
                        enabled: !1,
                        fillSeriesColor: !0
                    }
                }
            }
        }, {
            key: "_getBoxTooltip",
            value: function(e, t, i, a, s) {
                var r = e.globals.seriesCandleO[t][i]
                  , n = e.globals.seriesCandleH[t][i]
                  , o = e.globals.seriesCandleM[t][i]
                  , h = e.globals.seriesCandleL[t][i]
                  , d = e.globals.seriesCandleC[t][i];
                return e.config.series[t].type && e.config.series[t].type !== s ? '<div class="apexcharts-custom-tooltip">\n          '.concat(e.config.series[t].name ? e.config.series[t].name : "series-" + (t + 1), ": <strong>").concat(e.globals.series[t][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e.config.chart.type, '">') + "<div>".concat(a[0], ': <span class="value">') + r + "</span></div>" + "<div>".concat(a[1], ': <span class="value">') + n + "</span></div>" + (o ? "<div>".concat(a[2], ': <span class="value">') + o + "</span></div>" : "") + "<div>".concat(a[3], ': <span class="value">') + h + "</span></div>" + "<div>".concat(a[4], ': <span class="value">') + d + "</span></div></div>"
            }
        }]),
        C
    }()
      , St = function() {
        function C(e) {
            Q(this, C),
            this.opts = e
        }
        return Te(C, [{
            key: "init",
            value: function(e) {
                var t = e.responsiveOverride
                  , i = this.opts
                  , a = new kt
                  , s = new xt(i);
                this.chartType = i.chart.type,
                i = this.extendYAxis(i),
                i = this.extendAnnotations(i);
                var r = a.init()
                  , n = {};
                if (i && "object" === Ke(i)) {
                    var o, h, d, u, p, x, b, k, S, E, M = {};
                    M = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) ? s[i.chart.type]() : s.line(),
                    null !== (o = i.plotOptions) && void 0 !== o && null !== (h = o.bar) && void 0 !== h && h.isFunnel && (M = s.funnel()),
                    i.chart.stacked && "bar" === i.chart.type && (M = s.stackedBars()),
                    null !== (d = i.chart.brush) && void 0 !== d && d.enabled && (M = s.brush(M)),
                    i.chart.stacked && "100%" === i.chart.stackType && (i = s.stacked100(i)),
                    null !== (u = i.plotOptions) && void 0 !== u && null !== (p = u.bar) && void 0 !== p && p.isDumbbell && (i = s.dumbbell(i)),
                    "monotoneCubic" === (null === (x = i) || void 0 === x || null === (b = x.stroke) || void 0 === b ? void 0 : b.curve) && (i.stroke.curve = "smooth"),
                    this.checkForDarkTheme(window.Apex),
                    this.checkForDarkTheme(i),
                    i.xaxis = i.xaxis || window.Apex.xaxis || {},
                    t || (i.xaxis.convertedCatToNumeric = !1),
                    (null !== (k = (i = this.checkForCatToNumericXAxis(this.chartType, M, i)).chart.sparkline) && void 0 !== k && k.enabled || null !== (S = window.Apex.chart) && void 0 !== S && null !== (E = S.sparkline) && void 0 !== E && E.enabled) && (M = s.sparkline(M)),
                    n = D.extend(r, M)
                }
                var l = D.extend(n, window.Apex);
                return r = D.extend(l, i),
                this.handleUserInputErrors(r)
            }
        }, {
            key: "checkForCatToNumericXAxis",
            value: function(e, t, i) {
                var a, s, r = new xt(i);
                return ("bar" === e || "boxPlot" === e) && (null === (a = i.plotOptions) || void 0 === a || null === (s = a.bar) || void 0 === s ? void 0 : s.horizontal) || "pie" === e || "polarArea" === e || "donut" === e || "radar" === e || "radialBar" === e || "heatmap" === e || !("datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type) || "between" === (i.xaxis.tickPlacement ? i.xaxis.tickPlacement : t.xaxis && t.xaxis.tickPlacement) || (i = r.convertCatToNumeric(i)),
                i
            }
        }, {
            key: "extendYAxis",
            value: function(e, t) {
                var i = new kt;
                (void 0 === e.yaxis || !e.yaxis || Array.isArray(e.yaxis) && 0 === e.yaxis.length) && (e.yaxis = {}),
                e.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e.yaxis = D.extend(e.yaxis, window.Apex.yaxis)),
                e.yaxis = e.yaxis.constructor !== Array ? [D.extend(i.yAxis, e.yaxis)] : D.extendArray(e.yaxis, i.yAxis);
                var a = !1;
                e.yaxis.forEach(function(r) {
                    r.logarithmic && (a = !0)
                });
                var s = e.series;
                return t && !s && (s = t.config.series),
                a && s.length !== e.yaxis.length && s.length && (e.yaxis = s.map(function(r, n) {
                    if (r.name || (s[n].name = "series-".concat(n + 1)),
                    e.yaxis[n])
                        return e.yaxis[n].seriesName = s[n].name,
                        e.yaxis[n];
                    var o = D.extend(i.yAxis, e.yaxis[0]);
                    return o.show = !1,
                    o
                })),
                a && s.length > 1 && s.length !== e.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"),
                e
            }
        }, {
            key: "extendAnnotations",
            value: function(e) {
                return void 0 === e.annotations && (e.annotations = {},
                e.annotations.yaxis = [],
                e.annotations.xaxis = [],
                e.annotations.points = []),
                e = this.extendYAxisAnnotations(e),
                e = this.extendXAxisAnnotations(e),
                this.extendPointAnnotations(e)
            }
        }, {
            key: "extendYAxisAnnotations",
            value: function(e) {
                var t = new kt;
                return e.annotations.yaxis = D.extendArray(void 0 !== e.annotations.yaxis ? e.annotations.yaxis : [], t.yAxisAnnotation),
                e
            }
        }, {
            key: "extendXAxisAnnotations",
            value: function(e) {
                var t = new kt;
                return e.annotations.xaxis = D.extendArray(void 0 !== e.annotations.xaxis ? e.annotations.xaxis : [], t.xAxisAnnotation),
                e
            }
        }, {
            key: "extendPointAnnotations",
            value: function(e) {
                var t = new kt;
                return e.annotations.points = D.extendArray(void 0 !== e.annotations.points ? e.annotations.points : [], t.pointAnnotation),
                e
            }
        }, {
            key: "checkForDarkTheme",
            value: function(e) {
                e.theme && "dark" === e.theme.mode && (e.tooltip || (e.tooltip = {}),
                "light" !== e.tooltip.theme && (e.tooltip.theme = "dark"),
                e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"),
                e.chart.background || (e.chart.background = "#424242"),
                e.theme.palette || (e.theme.palette = "palette4"))
            }
        }, {
            key: "handleUserInputErrors",
            value: function(e) {
                var t = e;
                if (t.tooltip.shared && t.tooltip.intersect)
                    throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                if ("bar" === t.chart.type && t.plotOptions.bar.horizontal) {
                    if (t.yaxis.length > 1)
                        throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                    t.yaxis[0].reversed && (t.yaxis[0].opposite = !0),
                    t.xaxis.tooltip.enabled = !1,
                    t.yaxis[0].tooltip.enabled = !1,
                    t.chart.zoom.enabled = !1
                }
                return "bar" !== t.chart.type && "rangeBar" !== t.chart.type || t.tooltip.shared && "barWidth" === t.xaxis.crosshairs.width && t.series.length > 1 && (t.xaxis.crosshairs.width = "tickWidth"),
                "candlestick" !== t.chart.type && "boxPlot" !== t.chart.type || t.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(t.chart.type, " chart is not supported.")),
                t.yaxis[0].reversed = !1),
                t
            }
        }]),
        C
    }()
      , yt = function() {
        function C() {
            Q(this, C)
        }
        return Te(C, [{
            key: "initGlobalVars",
            value: function(e) {
                e.series = [],
                e.seriesCandleO = [],
                e.seriesCandleH = [],
                e.seriesCandleM = [],
                e.seriesCandleL = [],
                e.seriesCandleC = [],
                e.seriesRangeStart = [],
                e.seriesRangeEnd = [],
                e.seriesRange = [],
                e.seriesPercent = [],
                e.seriesGoals = [],
                e.seriesX = [],
                e.seriesZ = [],
                e.seriesNames = [],
                e.seriesTotals = [],
                e.seriesLog = [],
                e.seriesColors = [],
                e.stackedSeriesTotals = [],
                e.seriesXvalues = [],
                e.seriesYvalues = [],
                e.labels = [],
                e.hasXaxisGroups = !1,
                e.groups = [],
                e.hasSeriesGroups = !1,
                e.seriesGroups = [],
                e.categoryLabels = [],
                e.timescaleLabels = [],
                e.noLabelsProvided = !1,
                e.resizeTimer = null,
                e.selectionResizeTimer = null,
                e.delayedElements = [],
                e.pointsArray = [],
                e.dataLabelsRects = [],
                e.isXNumeric = !1,
                e.skipLastTimelinelabel = !1,
                e.skipFirstTimelinelabel = !1,
                e.isDataXYZ = !1,
                e.isMultiLineX = !1,
                e.isMultipleYAxis = !1,
                e.maxY = -Number.MAX_VALUE,
                e.minY = Number.MIN_VALUE,
                e.minYArr = [],
                e.maxYArr = [],
                e.maxX = -Number.MAX_VALUE,
                e.minX = Number.MAX_VALUE,
                e.initialMaxX = -Number.MAX_VALUE,
                e.initialMinX = Number.MAX_VALUE,
                e.maxDate = 0,
                e.minDate = Number.MAX_VALUE,
                e.minZ = Number.MAX_VALUE,
                e.maxZ = -Number.MAX_VALUE,
                e.minXDiff = Number.MAX_VALUE,
                e.yAxisScale = [],
                e.xAxisScale = null,
                e.xAxisTicksPositions = [],
                e.yLabelsCoords = [],
                e.yTitleCoords = [],
                e.barPadForNumericAxis = 0,
                e.padHorizontal = 0,
                e.xRange = 0,
                e.yRange = [],
                e.zRange = 0,
                e.dataPoints = 0,
                e.xTickAmount = 0
            }
        }, {
            key: "globalVars",
            value: function(e) {
                return {
                    chartID: null,
                    cuid: null,
                    events: {
                        beforeMount: [],
                        mounted: [],
                        updated: [],
                        clicked: [],
                        selection: [],
                        dataPointSelection: [],
                        zoomed: [],
                        scrolled: []
                    },
                    colors: [],
                    clientX: null,
                    clientY: null,
                    fill: {
                        colors: []
                    },
                    stroke: {
                        colors: []
                    },
                    dataLabels: {
                        style: {
                            colors: []
                        }
                    },
                    radarPolygons: {
                        fill: {
                            colors: []
                        }
                    },
                    markers: {
                        colors: [],
                        size: e.markers.size,
                        largestSize: 0
                    },
                    animationEnded: !1,
                    isTouchDevice: "ontouchstart"in window || navigator.msMaxTouchPoints,
                    isDirty: !1,
                    isExecCalled: !1,
                    initialConfig: null,
                    initialSeries: [],
                    lastXAxis: [],
                    lastYAxis: [],
                    columnSeries: null,
                    labels: [],
                    timescaleLabels: [],
                    noLabelsProvided: !1,
                    allSeriesCollapsed: !1,
                    collapsedSeries: [],
                    collapsedSeriesIndices: [],
                    ancillaryCollapsedSeries: [],
                    ancillaryCollapsedSeriesIndices: [],
                    risingSeries: [],
                    dataFormatXNumeric: !1,
                    capturedSeriesIndex: -1,
                    capturedDataPointIndex: -1,
                    selectedDataPoints: [],
                    goldenPadding: 35,
                    invalidLogScale: !1,
                    ignoreYAxisIndexes: [],
                    yAxisSameScaleIndices: [],
                    maxValsInArrayIndex: 0,
                    radialSize: 0,
                    selection: void 0,
                    zoomEnabled: "zoom" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled,
                    panEnabled: "pan" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.pan,
                    selectionEnabled: "selection" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.selection,
                    yaxis: null,
                    mousedown: !1,
                    lastClientPosition: {},
                    visibleXRange: void 0,
                    yValueDecimal: 0,
                    total: 0,
                    SVGNS: "http://www.w3.org/2000/svg",
                    svgWidth: 0,
                    svgHeight: 0,
                    noData: !1,
                    locale: {},
                    dom: {},
                    memory: {
                        methodsToExec: []
                    },
                    shouldAnimate: !0,
                    skipLastTimelinelabel: !1,
                    skipFirstTimelinelabel: !1,
                    delayedElements: [],
                    axisCharts: !0,
                    isDataXYZ: !1,
                    resized: !1,
                    resizeTimer: null,
                    comboCharts: !1,
                    dataChanged: !1,
                    previousPaths: [],
                    allSeriesHasEqualX: !0,
                    pointsArray: [],
                    dataLabelsRects: [],
                    lastDrawnDataLabelsIndexes: [],
                    hasNullValues: !1,
                    easing: null,
                    zoomed: !1,
                    gridWidth: 0,
                    gridHeight: 0,
                    rotateXLabels: !1,
                    defaultLabels: !1,
                    xLabelFormatter: void 0,
                    yLabelFormatters: [],
                    xaxisTooltipFormatter: void 0,
                    ttKeyFormatter: void 0,
                    ttVal: void 0,
                    ttZFormatter: void 0,
                    LINE_HEIGHT_RATIO: 1.618,
                    xAxisLabelsHeight: 0,
                    xAxisGroupLabelsHeight: 0,
                    xAxisLabelsWidth: 0,
                    yAxisLabelsWidth: 0,
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0,
                    translateYAxisX: [],
                    yAxisWidths: [],
                    translateXAxisY: 0,
                    translateXAxisX: 0,
                    tooltip: null
                }
            }
        }, {
            key: "init",
            value: function(e) {
                var t = this.globalVars(e);
                return this.initGlobalVars(t),
                t.initialConfig = D.extend({}, e),
                t.initialSeries = D.clone(e.series),
                t.lastXAxis = D.clone(t.initialConfig.xaxis),
                t.lastYAxis = D.clone(t.initialConfig.yaxis),
                t
            }
        }]),
        C
    }()
      , ri = function() {
        function C(e) {
            Q(this, C),
            this.opts = e
        }
        return Te(C, [{
            key: "init",
            value: function() {
                var e = new St(this.opts).init({
                    responsiveOverride: !1
                });
                return {
                    config: e,
                    globals: (new yt).init(e)
                }
            }
        }]),
        C
    }()
      , wt = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.opts = null,
            this.seriesIndex = 0
        }
        return Te(C, [{
            key: "clippedImgArea",
            value: function(e) {
                var t = this.w
                  , i = t.config
                  , a = parseInt(t.globals.gridWidth, 10)
                  , s = parseInt(t.globals.gridHeight, 10)
                  , r = a > s ? a : s
                  , n = e.image
                  , o = 0
                  , h = 0;
                void 0 === e.width && void 0 === e.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1,
                h = i.fill.image.height) : (o = r + 1,
                h = r) : (o = e.width,
                h = e.height);
                var d = document.createElementNS(t.globals.SVGNS, "pattern");
                U.setAttrs(d, {
                    id: e.patternID,
                    patternUnits: e.patternUnits ? e.patternUnits : "userSpaceOnUse",
                    width: o + "px",
                    height: h + "px"
                });
                var u = document.createElementNS(t.globals.SVGNS, "image");
                d.appendChild(u),
                u.setAttributeNS(window.SVG.xlink, "href", n),
                U.setAttrs(u, {
                    x: 0,
                    y: 0,
                    preserveAspectRatio: "none",
                    width: o + "px",
                    height: h + "px"
                }),
                u.style.opacity = e.opacity,
                t.globals.dom.elDefs.node.appendChild(d)
            }
        }, {
            key: "getSeriesIndex",
            value: function(e) {
                var t = this.w
                  , i = t.config.chart.type;
                return this.seriesIndex = ("bar" === i || "rangeBar" === i) && t.config.plotOptions.bar.distributed || "heatmap" === i || "treemap" === i ? e.seriesNumber : e.seriesNumber % t.globals.series.length,
                this.seriesIndex
            }
        }, {
            key: "fillPath",
            value: function(e) {
                var t = this.w;
                this.opts = e;
                var i, a, s, r = this.w.config;
                this.seriesIndex = this.getSeriesIndex(e);
                var n = this.getFillColors()[this.seriesIndex];
                void 0 !== t.globals.seriesColors[this.seriesIndex] && (n = t.globals.seriesColors[this.seriesIndex]),
                "function" == typeof n && (n = n({
                    seriesIndex: this.seriesIndex,
                    dataPointIndex: e.dataPointIndex,
                    value: e.value,
                    w: t
                }));
                var o = e.fillType ? e.fillType : this.getFillType(this.seriesIndex)
                  , h = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity;
                e.color && (n = e.color),
                n || (n = "#fff",
                console.warn("undefined color - ApexCharts"));
                var d = n;
                if (-1 === n.indexOf("rgb") ? n.length < 9 && (d = D.hexToRgba(n, h)) : n.indexOf("rgba") > -1 && (h = D.getOpacityFromRGBA(n)),
                e.opacity && (h = e.opacity),
                "pattern" === o && (a = this.handlePatternFill({
                    fillConfig: e.fillConfig,
                    patternFill: a,
                    fillColor: n,
                    fillOpacity: h,
                    defaultColor: d
                })),
                "gradient" === o && (s = this.handleGradientFill({
                    fillConfig: e.fillConfig,
                    fillColor: n,
                    fillOpacity: h,
                    i: this.seriesIndex
                })),
                "image" === o) {
                    var u = r.fill.image.src
                      , p = e.patternID ? e.patternID : "";
                    this.clippedImgArea({
                        opacity: h,
                        image: Array.isArray(u) ? e.seriesNumber < u.length ? u[e.seriesNumber] : u[0] : u,
                        width: e.width ? e.width : void 0,
                        height: e.height ? e.height : void 0,
                        patternUnits: e.patternUnits,
                        patternID: "pattern".concat(t.globals.cuid).concat(e.seriesNumber + 1).concat(p)
                    }),
                    i = "url(#pattern".concat(t.globals.cuid).concat(e.seriesNumber + 1).concat(p, ")")
                } else
                    i = "gradient" === o ? s : "pattern" === o ? a : d;
                return e.solid && (i = d),
                i
            }
        }, {
            key: "getFillType",
            value: function(e) {
                var t = this.w;
                return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type
            }
        }, {
            key: "getFillColors",
            value: function() {
                var e = this.w
                  , t = e.config
                  , i = this.opts
                  , a = [];
                return e.globals.comboCharts ? "line" === e.config.series[this.seriesIndex].type ? Array.isArray(e.globals.stroke.colors) ? a = e.globals.stroke.colors : a.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? a = e.globals.fill.colors : a.push(e.globals.fill.colors) : "line" === t.chart.type ? Array.isArray(e.globals.stroke.colors) ? a = e.globals.stroke.colors : a.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? a = e.globals.fill.colors : a.push(e.globals.fill.colors),
                void 0 !== i.fillColors && (a = [],
                Array.isArray(i.fillColors) ? a = i.fillColors.slice() : a.push(i.fillColors)),
                a
            }
        }, {
            key: "handlePatternFill",
            value: function(e) {
                var t = e.fillConfig
                  , a = e.fillColor
                  , s = e.fillOpacity
                  , r = e.defaultColor
                  , n = this.w.config.fill;
                t && (n = t);
                var o = this.opts
                  , h = new U(this.ctx)
                  , d = Array.isArray(n.pattern.strokeWidth) ? n.pattern.strokeWidth[this.seriesIndex] : n.pattern.strokeWidth
                  , u = a;
                return Array.isArray(n.pattern.style) ? void 0 !== n.pattern.style[o.seriesNumber] ? h.drawPattern(n.pattern.style[o.seriesNumber], n.pattern.width, n.pattern.height, u, d, s) : r : h.drawPattern(n.pattern.style, n.pattern.width, n.pattern.height, u, d, s)
            }
        }, {
            key: "handleGradientFill",
            value: function(e) {
                var t = e.fillColor
                  , i = e.fillOpacity
                  , a = e.fillConfig
                  , s = e.i
                  , r = this.w.config.fill;
                a && (r = K(K({}, r), a));
                var n, o = this.opts, h = new U(this.ctx), d = new D, u = r.gradient.type, p = t, x = void 0 === r.gradient.opacityFrom ? i : Array.isArray(r.gradient.opacityFrom) ? r.gradient.opacityFrom[s] : r.gradient.opacityFrom;
                p.indexOf("rgba") > -1 && (x = D.getOpacityFromRGBA(p));
                var b = void 0 === r.gradient.opacityTo ? i : Array.isArray(r.gradient.opacityTo) ? r.gradient.opacityTo[s] : r.gradient.opacityTo;
                if (void 0 === r.gradient.gradientToColors || 0 === r.gradient.gradientToColors.length)
                    n = d.shadeColor("dark" === r.gradient.shade ? -1 * parseFloat(r.gradient.shadeIntensity) : parseFloat(r.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? D.rgb2hex(t) : t);
                else if (r.gradient.gradientToColors[o.seriesNumber]) {
                    var k = r.gradient.gradientToColors[o.seriesNumber];
                    n = k,
                    k.indexOf("rgba") > -1 && (b = D.getOpacityFromRGBA(k))
                } else
                    n = t;
                if (r.gradient.gradientFrom && (p = r.gradient.gradientFrom),
                r.gradient.gradientTo && (n = r.gradient.gradientTo),
                r.gradient.inverseColors) {
                    var S = p;
                    p = n,
                    n = S
                }
                return p.indexOf("rgb") > -1 && (p = D.rgb2hex(p)),
                n.indexOf("rgb") > -1 && (n = D.rgb2hex(n)),
                h.drawGradient(u, p, n, x, b, o.size, r.gradient.stops, r.gradient.colorStops, s)
            }
        }]),
        C
    }()
      , ye = function() {
        function C(e, t) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "setGlobalMarkerSize",
            value: function() {
                var e = this.w;
                if (e.globals.markers.size = Array.isArray(e.config.markers.size) ? e.config.markers.size : [e.config.markers.size],
                e.globals.markers.size.length > 0) {
                    if (e.globals.markers.size.length < e.globals.series.length + 1)
                        for (var t = 0; t <= e.globals.series.length; t++)
                            void 0 === e.globals.markers.size[t] && e.globals.markers.size.push(e.globals.markers.size[0])
                } else
                    e.globals.markers.size = e.config.series.map(function(i) {
                        return e.config.markers.size
                    })
            }
        }, {
            key: "plotChartMarkers",
            value: function(e, t, i, a) {
                var s, r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], n = this.w, o = t, h = e, d = null, u = new U(this.ctx), p = n.config.markers.discrete && n.config.markers.discrete.length;
                if ((n.globals.markers.size[t] > 0 || r || p) && (d = u.group({
                    class: r || p ? "" : "apexcharts-series-markers"
                })).attr("clip-path", "url(#gridRectMarkerMask".concat(n.globals.cuid, ")")),
                Array.isArray(h.x))
                    for (var x = 0; x < h.x.length; x++) {
                        var b = i;
                        1 === i && 0 === x && (b = 0),
                        1 === i && 1 === x && (b = 1);
                        var k = "apexcharts-marker";
                        if ("line" !== n.config.chart.type && "area" !== n.config.chart.type || n.globals.comboCharts || n.config.tooltip.intersect || (k += " no-pointer-events"),
                        (Array.isArray(n.config.markers.size) ? n.globals.markers.size[t] > 0 : n.config.markers.size > 0) || r || p) {
                            D.isNumber(h.y[x]) ? k += " w".concat(D.randomId()) : k = "apexcharts-nullpoint";
                            var S = this.getMarkerConfig({
                                cssClass: k,
                                seriesIndex: t,
                                dataPointIndex: b
                            });
                            n.config.series[o].data[b] && (n.config.series[o].data[b].fillColor && (S.pointFillColor = n.config.series[o].data[b].fillColor),
                            n.config.series[o].data[b].strokeColor && (S.pointStrokeColor = n.config.series[o].data[b].strokeColor)),
                            a && (S.pSize = a),
                            (h.x[x] < 0 || h.x[x] > n.globals.gridWidth || h.y[x] < 0 || h.y[x] > n.globals.gridHeight) && (S.pSize = 0),
                            (s = u.drawMarker(h.x[x], h.y[x], S)).attr("rel", b),
                            s.attr("j", b),
                            s.attr("index", t),
                            s.node.setAttribute("default-marker-size", S.pSize),
                            new _e(this.ctx).setSelectionFilter(s, t, b),
                            this.addEvents(s),
                            d && d.add(s)
                        } else
                            void 0 === n.globals.pointsArray[t] && (n.globals.pointsArray[t] = []),
                            n.globals.pointsArray[t].push([h.x[x], h.y[x]])
                    }
                return d
            }
        }, {
            key: "getMarkerConfig",
            value: function(e) {
                var t = e.cssClass
                  , i = e.seriesIndex
                  , a = e.dataPointIndex
                  , s = void 0 === a ? null : a
                  , r = e.finishRadius
                  , n = void 0 === r ? null : r
                  , o = this.w
                  , h = this.getMarkerStyle(i)
                  , d = o.globals.markers.size[i]
                  , u = o.config.markers;
                return null !== s && u.discrete.length && u.discrete.map(function(p) {
                    p.seriesIndex === i && p.dataPointIndex === s && (h.pointStrokeColor = p.strokeColor,
                    h.pointFillColor = p.fillColor,
                    d = p.size,
                    h.pointShape = p.shape)
                }),
                {
                    pSize: null === n ? d : n,
                    pRadius: u.radius,
                    width: Array.isArray(u.width) ? u.width[i] : u.width,
                    height: Array.isArray(u.height) ? u.height[i] : u.height,
                    pointStrokeWidth: Array.isArray(u.strokeWidth) ? u.strokeWidth[i] : u.strokeWidth,
                    pointStrokeColor: h.pointStrokeColor,
                    pointFillColor: h.pointFillColor,
                    shape: h.pointShape || (Array.isArray(u.shape) ? u.shape[i] : u.shape),
                    class: t,
                    pointStrokeOpacity: Array.isArray(u.strokeOpacity) ? u.strokeOpacity[i] : u.strokeOpacity,
                    pointStrokeDashArray: Array.isArray(u.strokeDashArray) ? u.strokeDashArray[i] : u.strokeDashArray,
                    pointFillOpacity: Array.isArray(u.fillOpacity) ? u.fillOpacity[i] : u.fillOpacity,
                    seriesIndex: i
                }
            }
        }, {
            key: "addEvents",
            value: function(e) {
                var t = this.w
                  , i = new U(this.ctx);
                e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, e)),
                e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, e)),
                e.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, e)),
                e.node.addEventListener("click", t.config.markers.onClick),
                e.node.addEventListener("dblclick", t.config.markers.onDblClick),
                e.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, e), {
                    passive: !0
                })
            }
        }, {
            key: "getMarkerStyle",
            value: function(e) {
                var t = this.w
                  , i = t.globals.markers.colors
                  , a = t.config.markers.strokeColor || t.config.markers.strokeColors;
                return {
                    pointStrokeColor: Array.isArray(a) ? a[e] : a,
                    pointFillColor: Array.isArray(i) ? i[e] : i
                }
            }
        }]),
        C
    }()
      , gi = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
        }
        return Te(C, [{
            key: "draw",
            value: function(e, t, i) {
                var a = this.w
                  , s = new U(this.ctx)
                  , r = i.realIndex
                  , n = i.pointsPos
                  , o = i.zRatio
                  , h = i.elParent
                  , d = s.group({
                    class: "apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)
                });
                if (d.attr("clip-path", "url(#gridRectMarkerMask".concat(a.globals.cuid, ")")),
                Array.isArray(n.x))
                    for (var u = 0; u < n.x.length; u++) {
                        var p = t + 1
                          , x = !0;
                        0 === t && 0 === u && (p = 0),
                        0 === t && 1 === u && (p = 1);
                        var b = 0
                          , k = a.globals.markers.size[r];
                        if (o !== 1 / 0) {
                            var S = a.config.plotOptions.bubble;
                            k = a.globals.seriesZ[r][p],
                            S.zScaling && (k /= o),
                            S.minBubbleRadius && k < S.minBubbleRadius && (k = S.minBubbleRadius),
                            S.maxBubbleRadius && k > S.maxBubbleRadius && (k = S.maxBubbleRadius)
                        }
                        a.config.chart.animations.enabled || (b = k);
                        var M = n.y[u];
                        if (b = b || 0,
                        null !== M && void 0 !== a.globals.series[r][p] || (x = !1),
                        x) {
                            var l = this.drawPoint(n.x[u], M, b, k, r, p, t);
                            d.add(l)
                        }
                        h.add(d)
                    }
            }
        }, {
            key: "drawPoint",
            value: function(e, t, i, a, s, r, n) {
                var o = this.w
                  , h = s
                  , d = new Se(this.ctx)
                  , u = new _e(this.ctx)
                  , p = new wt(this.ctx)
                  , x = new ye(this.ctx)
                  , b = new U(this.ctx)
                  , k = x.getMarkerConfig({
                    cssClass: "apexcharts-marker",
                    seriesIndex: h,
                    dataPointIndex: r,
                    finishRadius: "bubble" === o.config.chart.type || o.globals.comboCharts && o.config.series[s] && "bubble" === o.config.series[s].type ? a : null
                });
                a = k.pSize;
                var S, E = p.fillPath({
                    seriesNumber: s,
                    dataPointIndex: r,
                    color: k.pointFillColor,
                    patternUnits: "objectBoundingBox",
                    value: o.globals.series[s][n]
                });
                if ("circle" === k.shape ? S = b.drawCircle(i) : "square" !== k.shape && "rect" !== k.shape || (S = b.drawRect(0, 0, k.width - k.pointStrokeWidth / 2, k.height - k.pointStrokeWidth / 2, k.pRadius)),
                o.config.series[h].data[r] && o.config.series[h].data[r].fillColor && (E = o.config.series[h].data[r].fillColor),
                S.attr({
                    x: e - k.width / 2 - k.pointStrokeWidth / 2,
                    y: t - k.height / 2 - k.pointStrokeWidth / 2,
                    cx: e,
                    cy: t,
                    fill: E,
                    "fill-opacity": k.pointFillOpacity,
                    stroke: k.pointStrokeColor,
                    r: a,
                    "stroke-width": k.pointStrokeWidth,
                    "stroke-dasharray": k.pointStrokeDashArray,
                    "stroke-opacity": k.pointStrokeOpacity
                }),
                o.config.chart.dropShadow.enabled && u.dropShadow(S, o.config.chart.dropShadow, s),
                !this.initialAnim || o.globals.dataChanged || o.globals.resized ? o.globals.animationEnded = !0 : d.animateMarker(S, 0, "circle" === k.shape ? a : {
                    width: k.width,
                    height: k.height
                }, o.config.chart.animations.speed, o.globals.easing, function() {
                    window.setTimeout(function() {
                        d.animationCompleted(S)
                    }, 100)
                }),
                o.globals.dataChanged && "circle" === k.shape)
                    if (this.dynamicAnim) {
                        var f, w, _, R, H = o.config.chart.animations.dynamicAnimation.speed;
                        null != (R = o.globals.previousPaths[s] && o.globals.previousPaths[s][n]) && (f = R.x,
                        w = R.y,
                        _ = void 0 !== R.r ? R.r : a);
                        for (var B = 0; B < o.globals.collapsedSeries.length; B++)
                            o.globals.collapsedSeries[B].index === s && (H = 1,
                            a = 0);
                        0 === e && 0 === t && (a = 0),
                        d.animateCircle(S, {
                            cx: f,
                            cy: w,
                            r: _
                        }, {
                            cx: e,
                            cy: t,
                            r: a
                        }, H, o.globals.easing)
                    } else
                        S.attr({
                            r: a
                        });
                return S.attr({
                    rel: r,
                    j: r,
                    index: s,
                    "default-marker-size": a
                }),
                u.setSelectionFilter(S, s, r),
                x.addEvents(S),
                S.node.classList.add("apexcharts-marker"),
                S
            }
        }, {
            key: "centerTextInBubble",
            value: function(e) {
                return {
                    y: e += parseInt(this.w.config.dataLabels.style.fontSize, 10) / 4
                }
            }
        }]),
        C
    }()
      , It = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "dataLabelsCorrection",
            value: function(e, t, i, a, s, r, n) {
                var o = this.w
                  , h = !1
                  , d = new U(this.ctx).getTextRects(i, n)
                  , u = d.width
                  , p = d.height;
                if (t < 0 && (t = 0),
                t > o.globals.gridHeight + p && (t = o.globals.gridHeight + p / 2),
                void 0 === o.globals.dataLabelsRects[a] && (o.globals.dataLabelsRects[a] = []),
                o.globals.dataLabelsRects[a].push({
                    x: e,
                    y: t,
                    width: u,
                    height: p
                }),
                void 0 !== o.globals.dataLabelsRects[a][o.globals.dataLabelsRects[a].length - 2]) {
                    var k = o.globals.dataLabelsRects[a][void 0 !== o.globals.lastDrawnDataLabelsIndexes[a] ? o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length - 1] : 0];
                    (e > k.x + k.width || t > k.y + k.height || t + p < k.y || e + u < k.x) && (h = !0)
                }
                return (0 === s || r) && (h = !0),
                {
                    x: e,
                    y: t,
                    textRects: d,
                    drawnextLabel: h
                }
            }
        }, {
            key: "drawDataLabel",
            value: function(e) {
                var t = this
                  , i = e.type
                  , a = e.pos
                  , s = e.i
                  , r = e.j
                  , n = e.isRangeStart
                  , o = e.strokeWidth
                  , h = void 0 === o ? 2 : o
                  , d = this.w
                  , u = new U(this.ctx)
                  , p = d.config.dataLabels
                  , x = 0
                  , b = 0
                  , k = r
                  , S = null;
                if (!p.enabled || !Array.isArray(a.x))
                    return S;
                S = u.group({
                    class: "apexcharts-data-labels"
                });
                for (var E = 0; E < a.x.length; E++)
                    if (x = a.x[E] + p.offsetX,
                    b = a.y[E] + p.offsetY + h,
                    !isNaN(x)) {
                        1 === r && 0 === E && (k = 0),
                        1 === r && 1 === E && (k = 1);
                        var M = d.globals.series[s][k];
                        "rangeArea" === i && (M = n ? d.globals.seriesRangeStart[s][k] : d.globals.seriesRangeEnd[s][k]);
                        var l = ""
                          , f = function(w) {
                            return d.config.dataLabels.formatter(w, {
                                ctx: t.ctx,
                                seriesIndex: s,
                                dataPointIndex: k,
                                w: d
                            })
                        };
                        "bubble" === d.config.chart.type ? (l = f(M = d.globals.seriesZ[s][k]),
                        b = a.y[E],
                        b = new gi(this.ctx).centerTextInBubble(b, s, k).y) : void 0 !== M && (l = f(M)),
                        this.plotDataLabelsText({
                            x,
                            y: b,
                            text: l,
                            i: s,
                            j: k,
                            parent: S,
                            offsetCorrection: !0,
                            dataLabelsConfig: d.config.dataLabels
                        })
                    }
                return S
            }
        }, {
            key: "plotDataLabelsText",
            value: function(e) {
                var t = this.w
                  , i = new U(this.ctx)
                  , a = e.x
                  , s = e.y
                  , r = e.i
                  , n = e.j
                  , o = e.text
                  , h = e.textAnchor
                  , d = e.fontSize
                  , u = e.parent
                  , p = e.dataLabelsConfig
                  , x = e.color
                  , b = e.alwaysDrawDataLabel
                  , k = e.offsetCorrection;
                if (!(Array.isArray(t.config.dataLabels.enabledOnSeries) && t.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
                    var S = {
                        x: a,
                        y: s,
                        drawnextLabel: !0,
                        textRects: null
                    };
                    k && (S = this.dataLabelsCorrection(a, s, o, r, n, b, parseInt(p.style.fontSize, 10))),
                    t.globals.zoomed || (a = S.x,
                    s = S.y),
                    S.textRects && (a < -10 - S.textRects.width || a > t.globals.gridWidth + S.textRects.width + 10) && (o = "");
                    var E = t.globals.dataLabels.style.colors[r];
                    (("bar" === t.config.chart.type || "rangeBar" === t.config.chart.type) && t.config.plotOptions.bar.distributed || t.config.dataLabels.distributed) && (E = t.globals.dataLabels.style.colors[n]),
                    "function" == typeof E && (E = E({
                        series: t.globals.series,
                        seriesIndex: r,
                        dataPointIndex: n,
                        w: t
                    })),
                    x && (E = x);
                    var M = p.offsetX
                      , l = p.offsetY;
                    if ("bar" !== t.config.chart.type && "rangeBar" !== t.config.chart.type || (M = 0,
                    l = 0),
                    S.drawnextLabel) {
                        var f = i.drawText({
                            width: 100,
                            height: parseInt(p.style.fontSize, 10),
                            x: a + M,
                            y: s + l,
                            foreColor: E,
                            textAnchor: h || p.textAnchor,
                            text: o,
                            fontSize: d || p.style.fontSize,
                            fontFamily: p.style.fontFamily,
                            fontWeight: p.style.fontWeight || "normal"
                        });
                        if (f.attr({
                            class: "apexcharts-datalabel",
                            cx: a,
                            cy: s
                        }),
                        p.dropShadow.enabled) {
                            var w = p.dropShadow;
                            new _e(this.ctx).dropShadow(f, w)
                        }
                        u.add(f),
                        void 0 === t.globals.lastDrawnDataLabelsIndexes[r] && (t.globals.lastDrawnDataLabelsIndexes[r] = []),
                        t.globals.lastDrawnDataLabelsIndexes[r].push(n)
                    }
                }
            }
        }, {
            key: "addBackgroundToDataLabel",
            value: function(e, t) {
                var i = this.w
                  , a = i.config.dataLabels.background
                  , s = a.padding
                  , r = a.padding / 2
                  , n = t.width
                  , o = t.height
                  , h = new U(this.ctx).drawRect(t.x - s, t.y - r / 2, n + 2 * s, o + r, a.borderRadius, "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, a.opacity, a.borderWidth, a.borderColor);
                return a.dropShadow.enabled && new _e(this.ctx).dropShadow(h, a.dropShadow),
                h
            }
        }, {
            key: "dataLabelsBackground",
            value: function() {
                var e = this.w;
                if ("bubble" !== e.config.chart.type)
                    for (var t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < t.length; i++) {
                        var a = t[i]
                          , s = a.getBBox()
                          , r = null;
                        if (s.width && s.height && (r = this.addBackgroundToDataLabel(a, s)),
                        r) {
                            a.parentNode.insertBefore(r.node, a);
                            var n = a.getAttribute("fill");
                            !e.config.chart.animations.enabled || e.globals.resized || e.globals.dataChanged ? r.attr({
                                fill: n
                            }) : r.animate().attr({
                                fill: n
                            }),
                            a.setAttribute("fill", e.config.dataLabels.background.foreColor)
                        }
                    }
            }
        }, {
            key: "bringForward",
            value: function() {
                for (var e = this.w, t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = e.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a = 0; a < t.length; a++)
                    i && i.insertBefore(t[a], i.nextSibling)
            }
        }]),
        C
    }()
      , Lt = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.legendInactiveClass = "legend-mouseover-inactive"
        }
        return Te(C, [{
            key: "getAllSeriesEls",
            value: function() {
                return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
            }
        }, {
            key: "getSeriesByName",
            value: function(e) {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(D.escapeString(e), "']"))
            }
        }, {
            key: "isSeriesHidden",
            value: function(e) {
                var t = this.getSeriesByName(e)
                  , i = parseInt(t.getAttribute("data:realIndex"), 10);
                return {
                    isHidden: t.classList.contains("apexcharts-series-collapsed"),
                    realIndex: i
                }
            }
        }, {
            key: "addCollapsedClassToSeries",
            value: function(e, t) {
                var i = this.w;
                function a(s) {
                    for (var r = 0; r < s.length; r++)
                        s[r].index === t && e.node.classList.add("apexcharts-series-collapsed")
                }
                a(i.globals.collapsedSeries),
                a(i.globals.ancillaryCollapsedSeries)
            }
        }, {
            key: "toggleSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                return this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, t.isHidden),
                t.isHidden
            }
        }, {
            key: "showSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                t.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !0)
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                t.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !1)
            }
        }, {
            key: "resetSeries",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , a = this.w
                  , s = D.clone(a.globals.initialSeries);
                a.globals.previousPaths = [],
                i ? (a.globals.collapsedSeries = [],
                a.globals.ancillaryCollapsedSeries = [],
                a.globals.collapsedSeriesIndices = [],
                a.globals.ancillaryCollapsedSeriesIndices = []) : s = this.emptyCollapsedSeries(s),
                a.config.series = s,
                e && (t && (a.globals.zoomed = !1,
                this.ctx.updateHelpers.revertDefaultAxisMinMax()),
                this.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled))
            }
        }, {
            key: "emptyCollapsedSeries",
            value: function(e) {
                for (var t = this.w, i = 0; i < e.length; i++)
                    t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i].data = []);
                return e
            }
        }, {
            key: "toggleSeriesOnHover",
            value: function(e, t) {
                var i = this.w;
                t || (t = e.target);
                var a = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                if ("mousemove" === e.type) {
                    var s = parseInt(t.getAttribute("rel"), 10) - 1
                      , r = null
                      , n = null;
                    i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (r = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")),
                    n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s, "']"))) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']")) : r = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path"));
                    for (var o = 0; o < a.length; o++)
                        a[o].classList.add(this.legendInactiveClass);
                    null !== r && (i.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass),
                    r.classList.remove(this.legendInactiveClass),
                    null !== n && n.classList.remove(this.legendInactiveClass))
                } else if ("mouseout" === e.type)
                    for (var h = 0; h < a.length; h++)
                        a[h].classList.remove(this.legendInactiveClass)
            }
        }, {
            key: "highlightRangeInSeries",
            value: function(e, t) {
                var i = this
                  , a = this.w
                  , s = a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect")
                  , r = function(o) {
                    for (var h = 0; h < s.length; h++)
                        s[h].classList[o](i.legendInactiveClass)
                };
                if ("mousemove" === e.type) {
                    var n = parseInt(t.getAttribute("rel"), 10) - 1;
                    r("add"),
                    function(o) {
                        for (var h = 0; h < s.length; h++) {
                            var d = parseInt(s[h].getAttribute("val"), 10);
                            d >= o.from && d <= o.to && s[h].classList.remove(i.legendInactiveClass)
                        }
                    }(a.config.plotOptions.heatmap.colorScale.ranges[n])
                } else
                    "mouseout" === e.type && r("remove")
            }
        }, {
            key: "getActiveConfigSeriesIndex",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc"
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
                  , i = this.w
                  , a = 0;
                if (i.config.series.length > 1)
                    for (var s = i.config.series.map(function(n, o) {
                        return n.data && n.data.length > 0 && -1 === i.globals.collapsedSeriesIndices.indexOf(o) && (!i.globals.comboCharts || 0 === t.length || t.length && t.indexOf(i.config.series[o].type) > -1) ? o : -1
                    }), r = "asc" === e ? 0 : s.length - 1; "asc" === e ? r < s.length : r >= 0; "asc" === e ? r++ : r--)
                        if (-1 !== s[r]) {
                            a = s[r];
                            break
                        }
                return a
            }
        }, {
            key: "getBarSeriesIndices",
            value: function() {
                return this.w.globals.comboCharts ? this.w.config.series.map(function(e, t) {
                    return "bar" === e.type || "column" === e.type ? t : -1
                }).filter(function(e) {
                    return -1 !== e
                }) : this.w.config.series.map(function(e, t) {
                    return t
                })
            }
        }, {
            key: "getPreviousPaths",
            value: function() {
                var e = this.w;
                function t(r, n, o) {
                    for (var h = r[n].childNodes, d = {
                        type: o,
                        paths: [],
                        realIndex: r[n].getAttribute("data:realIndex")
                    }, u = 0; u < h.length; u++)
                        if (h[u].hasAttribute("pathTo")) {
                            var p = h[u].getAttribute("pathTo");
                            d.paths.push({
                                d: p
                            })
                        }
                    e.globals.previousPaths.push(d)
                }
                e.globals.previousPaths = [],
                ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(r) {
                    for (var o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(r, "-series .apexcharts-series")), h = 0; h < o.length; h++)
                        t(o, h, r)
                }),
                this.handlePrevBubbleScatterPaths("bubble"),
                this.handlePrevBubbleScatterPaths("scatter");
                var i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series"));
                if (i.length > 0)
                    for (var a = function(r) {
                        for (var n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(r, "'] rect")), o = [], h = function(u) {
                            var p = function(b) {
                                return n[u].getAttribute(b)
                            }
                              , x = {
                                x: parseFloat(p("x")),
                                y: parseFloat(p("y")),
                                width: parseFloat(p("width")),
                                height: parseFloat(p("height"))
                            };
                            o.push({
                                rect: x,
                                color: n[u].getAttribute("color")
                            })
                        }, d = 0; d < n.length; d++)
                            h(d);
                        e.globals.previousPaths.push(o)
                    }, s = 0; s < i.length; s++)
                        a(s);
                e.globals.axisCharts || (e.globals.previousPaths = e.globals.series)
            }
        }, {
            key: "handlePrevBubbleScatterPaths",
            value: function(e) {
                var t = this.w
                  , i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series"));
                if (i.length > 0)
                    for (var a = 0; a < i.length; a++) {
                        for (var s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series[data\\:realIndex='").concat(a, "'] circle")), r = [], n = 0; n < s.length; n++)
                            r.push({
                                x: s[n].getAttribute("cx"),
                                y: s[n].getAttribute("cy"),
                                r: s[n].getAttribute("r")
                            });
                        t.globals.previousPaths.push(r)
                    }
            }
        }, {
            key: "clearPreviousPaths",
            value: function() {
                var e = this.w;
                e.globals.previousPaths = [],
                e.globals.allSeriesCollapsed = !1
            }
        }, {
            key: "handleNoData",
            value: function() {
                var e = this.w
                  , t = e.config.noData
                  , i = new U(this.ctx)
                  , a = e.globals.svgWidth / 2
                  , s = e.globals.svgHeight / 2
                  , r = "middle";
                if (e.globals.noData = !0,
                e.globals.animationEnded = !0,
                "left" === t.align ? (a = 10,
                r = "start") : "right" === t.align && (a = e.globals.svgWidth - 10,
                r = "end"),
                "top" === t.verticalAlign ? s = 50 : "bottom" === t.verticalAlign && (s = e.globals.svgHeight - 50),
                a += t.offsetX,
                s = s + parseInt(t.style.fontSize, 10) + 2 + t.offsetY,
                void 0 !== t.text && "" !== t.text) {
                    var n = i.drawText({
                        x: a,
                        y: s,
                        text: t.text,
                        textAnchor: r,
                        fontSize: t.style.fontSize,
                        fontFamily: t.style.fontFamily,
                        foreColor: t.style.color,
                        opacity: 1,
                        class: "apexcharts-text-nodata"
                    });
                    e.globals.dom.Paper.add(n)
                }
            }
        }, {
            key: "setNullSeriesToZeroValues",
            value: function(e) {
                for (var t = this.w, i = 0; i < e.length; i++)
                    if (0 === e[i].length)
                        for (var a = 0; a < e[t.globals.maxValsInArrayIndex].length; a++)
                            e[i].push(0);
                return e
            }
        }, {
            key: "hasAllSeriesEqualX",
            value: function() {
                for (var e = !0, t = this.w, i = this.filteredSeriesX(), a = 0; a < i.length - 1; a++)
                    if (i[a][0] !== i[a + 1][0]) {
                        e = !1;
                        break
                    }
                return t.globals.allSeriesHasEqualX = e,
                e
            }
        }, {
            key: "filteredSeriesX",
            value: function() {
                return this.w.globals.seriesX.map(function(t) {
                    return t.length > 0 ? t : []
                })
            }
        }]),
        C
    }()
      , Ct = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.twoDSeries = [],
            this.threeDSeries = [],
            this.twoDSeriesX = [],
            this.seriesGoals = [],
            this.coreUtils = new ae(this.ctx)
        }
        return Te(C, [{
            key: "isMultiFormat",
            value: function() {
                return this.isFormatXY() || this.isFormat2DArray()
            }
        }, {
            key: "isFormatXY",
            value: function() {
                var e = this.w.config.series.slice()
                  , t = new Lt(this.ctx);
                if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(),
                void 0 !== e[this.activeSeriesIndex].data && e[this.activeSeriesIndex].data.length > 0 && null !== e[this.activeSeriesIndex].data[0] && void 0 !== e[this.activeSeriesIndex].data[0].x && null !== e[this.activeSeriesIndex].data[0])
                    return !0
            }
        }, {
            key: "isFormat2DArray",
            value: function() {
                var e = this.w.config.series.slice()
                  , t = new Lt(this.ctx);
                if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(),
                void 0 !== e[this.activeSeriesIndex].data && e[this.activeSeriesIndex].data.length > 0 && null != e[this.activeSeriesIndex].data[0] && e[this.activeSeriesIndex].data[0].constructor === Array)
                    return !0
            }
        }, {
            key: "handleFormat2DArray",
            value: function(e, t) {
                for (var i = this.w.config, a = this.w.globals, s = "boxPlot" === i.chart.type || "boxPlot" === i.series[t].type, r = 0; r < e[t].data.length; r++)
                    if (void 0 !== e[t].data[r][1] && (Array.isArray(e[t].data[r][1]) && 4 === e[t].data[r][1].length && !s ? this.twoDSeries.push(D.parseNumber(e[t].data[r][1][3])) : this.twoDSeries.push(D.parseNumber(e[t].data[r].length >= 5 ? e[t].data[r][4] : e[t].data[r][1])),
                    a.dataFormatXNumeric = !0),
                    "datetime" === i.xaxis.type) {
                        var n = new Date(e[t].data[r][0]);
                        n = new Date(n).getTime(),
                        this.twoDSeriesX.push(n)
                    } else
                        this.twoDSeriesX.push(e[t].data[r][0]);
                for (var o = 0; o < e[t].data.length; o++)
                    void 0 !== e[t].data[o][2] && (this.threeDSeries.push(e[t].data[o][2]),
                    a.isDataXYZ = !0)
            }
        }, {
            key: "handleFormatXY",
            value: function(e, t) {
                var i = this.w.config
                  , a = this.w.globals
                  , s = new We(this.ctx)
                  , r = t;
                a.collapsedSeriesIndices.indexOf(t) > -1 && (r = this.activeSeriesIndex);
                for (var n = 0; n < e[t].data.length; n++)
                    void 0 !== e[t].data[n].y && (Array.isArray(e[t].data[n].y) ? this.twoDSeries.push(D.parseNumber(e[t].data[n].y[e[t].data[n].y.length - 1])) : this.twoDSeries.push(D.parseNumber(e[t].data[n].y))),
                    void 0 !== e[t].data[n].goals && Array.isArray(e[t].data[n].goals) ? (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []),
                    this.seriesGoals[t].push(e[t].data[n].goals)) : (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []),
                    this.seriesGoals[t].push(null));
                for (var o = 0; o < e[r].data.length; o++) {
                    var h = "string" == typeof e[r].data[o].x
                      , d = Array.isArray(e[r].data[o].x)
                      , u = !d && !!s.isValidDate(e[r].data[o].x.toString());
                    h || u ? h || i.xaxis.convertedCatToNumeric ? "datetime" !== i.xaxis.type || a.isBarHorizontal && a.isRangeData ? (this.fallbackToCategory = !0,
                    this.twoDSeriesX.push(e[r].data[o].x),
                    isNaN(e[r].data[o].x) || "category" === this.w.config.xaxis.type || "string" == typeof e[r].data[o].x || (a.isXNumeric = !0)) : this.twoDSeriesX.push(s.parseDate(e[r].data[o].x)) : "datetime" === i.xaxis.type ? this.twoDSeriesX.push(s.parseDate(e[r].data[o].x.toString())) : (a.dataFormatXNumeric = !0,
                    a.isXNumeric = !0,
                    this.twoDSeriesX.push(parseFloat(e[r].data[o].x))) : d ? (this.fallbackToCategory = !0,
                    this.twoDSeriesX.push(e[r].data[o].x)) : (a.isXNumeric = !0,
                    a.dataFormatXNumeric = !0,
                    this.twoDSeriesX.push(e[r].data[o].x))
                }
                if (e[t].data[0] && void 0 !== e[t].data[0].z) {
                    for (var x = 0; x < e[t].data.length; x++)
                        this.threeDSeries.push(e[t].data[x].z);
                    a.isDataXYZ = !0
                }
            }
        }, {
            key: "handleRangeData",
            value: function(e, t) {
                var i = this.w.globals
                  , a = {};
                return this.isFormat2DArray() ? a = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (a = this.handleRangeDataFormat("xy", e, t)),
                i.seriesRangeStart.push(a.start),
                i.seriesRangeEnd.push(a.end),
                i.seriesRange.push(a.rangeUniques),
                i.seriesRange.forEach(function(s, r) {
                    s && s.forEach(function(n, o) {
                        n.y.forEach(function(h, d) {
                            for (var u = 0; u < n.y.length; u++)
                                d !== u && h.y1 <= n.y[u].y2 && n.y[u].y1 <= h.y2 && (n.overlaps.indexOf(h.rangeName) < 0 && n.overlaps.push(h.rangeName),
                                n.overlaps.indexOf(n.y[u].rangeName) < 0 && n.overlaps.push(n.y[u].rangeName))
                        })
                    })
                }),
                a
            }
        }, {
            key: "handleCandleStickBoxData",
            value: function(e, t) {
                var i = this.w.globals
                  , a = {};
                return this.isFormat2DArray() ? a = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (a = this.handleCandleStickBoxDataFormat("xy", e, t)),
                i.seriesCandleO[t] = a.o,
                i.seriesCandleH[t] = a.h,
                i.seriesCandleM[t] = a.m,
                i.seriesCandleL[t] = a.l,
                i.seriesCandleC[t] = a.c,
                a
            }
        }, {
            key: "handleRangeDataFormat",
            value: function(e, t, i) {
                var a = []
                  , s = []
                  , r = t[i].data.filter(function(d, u, p) {
                    return u === p.findIndex(function(x) {
                        return x.x === d.x
                    })
                }).map(function(d, u) {
                    return {
                        x: d.x,
                        overlaps: [],
                        y: []
                    }
                });
                if ("array" === e)
                    for (var n = 0; n < t[i].data.length; n++)
                        Array.isArray(t[i].data[n]) ? (a.push(t[i].data[n][1][0]),
                        s.push(t[i].data[n][1][1])) : (a.push(t[i].data[n]),
                        s.push(t[i].data[n]));
                else if ("xy" === e)
                    for (var o = function(d) {
                        var u = Array.isArray(t[i].data[d].y)
                          , p = D.randomId()
                          , x = t[i].data[d].x
                          , b = {
                            y1: u ? t[i].data[d].y[0] : t[i].data[d].y,
                            y2: u ? t[i].data[d].y[1] : t[i].data[d].y,
                            rangeName: p
                        };
                        t[i].data[d].rangeName = p;
                        var k = r.findIndex(function(S) {
                            return S.x === x
                        });
                        r[k].y.push(b),
                        a.push(b.y1),
                        s.push(b.y2)
                    }, h = 0; h < t[i].data.length; h++)
                        o(h);
                return {
                    start: a,
                    end: s,
                    rangeUniques: r
                }
            }
        }, {
            key: "handleCandleStickBoxDataFormat",
            value: function(e, t, i) {
                var a = this.w
                  , s = "boxPlot" === a.config.chart.type || "boxPlot" === a.config.series[i].type
                  , r = []
                  , n = []
                  , o = []
                  , h = []
                  , d = [];
                if ("array" === e)
                    if (s && 6 === t[i].data[0].length || !s && 5 === t[i].data[0].length)
                        for (var u = 0; u < t[i].data.length; u++)
                            r.push(t[i].data[u][1]),
                            n.push(t[i].data[u][2]),
                            s ? (o.push(t[i].data[u][3]),
                            h.push(t[i].data[u][4]),
                            d.push(t[i].data[u][5])) : (h.push(t[i].data[u][3]),
                            d.push(t[i].data[u][4]));
                    else
                        for (var p = 0; p < t[i].data.length; p++)
                            Array.isArray(t[i].data[p][1]) && (r.push(t[i].data[p][1][0]),
                            n.push(t[i].data[p][1][1]),
                            s ? (o.push(t[i].data[p][1][2]),
                            h.push(t[i].data[p][1][3]),
                            d.push(t[i].data[p][1][4])) : (h.push(t[i].data[p][1][2]),
                            d.push(t[i].data[p][1][3])));
                else if ("xy" === e)
                    for (var x = 0; x < t[i].data.length; x++)
                        Array.isArray(t[i].data[x].y) && (r.push(t[i].data[x].y[0]),
                        n.push(t[i].data[x].y[1]),
                        s ? (o.push(t[i].data[x].y[2]),
                        h.push(t[i].data[x].y[3]),
                        d.push(t[i].data[x].y[4])) : (h.push(t[i].data[x].y[2]),
                        d.push(t[i].data[x].y[3])));
                return {
                    o: r,
                    h: n,
                    m: o,
                    l: h,
                    c: d
                }
            }
        }, {
            key: "parseDataAxisCharts",
            value: function(e) {
                var t, i = this, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, s = this.w.config, r = this.w.globals, n = new We(a), o = s.labels.length > 0 ? s.labels.slice() : s.xaxis.categories.slice();
                if (r.isRangeBar = "rangeBar" === s.chart.type && r.isBarHorizontal,
                r.hasXaxisGroups = "category" === s.xaxis.type && s.xaxis.group.groups.length > 0,
                r.hasXaxisGroups && (r.groups = s.xaxis.group.groups),
                r.hasSeriesGroups = null === (t = e[0]) || void 0 === t ? void 0 : t.group,
                r.hasSeriesGroups) {
                    var h = []
                      , d = J(new Set(e.map(function(b) {
                        return b.group
                    })));
                    e.forEach(function(b, k) {
                        var S = d.indexOf(b.group);
                        h[S] || (h[S] = []),
                        h[S].push(b.name)
                    }),
                    r.seriesGroups = h
                }
                for (var u = function() {
                    for (var b = 0; b < o.length; b++)
                        if ("string" == typeof o[b]) {
                            if (!n.isValidDate(o[b]))
                                throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                            i.twoDSeriesX.push(n.parseDate(o[b]))
                        } else
                            i.twoDSeriesX.push(o[b])
                }, p = 0; p < e.length; p++) {
                    if (this.twoDSeries = [],
                    this.twoDSeriesX = [],
                    this.threeDSeries = [],
                    void 0 === e[p].data)
                        return void console.error("It is a possibility that you may have not included 'data' property in series.");
                    if ("rangeBar" !== s.chart.type && "rangeArea" !== s.chart.type && "rangeBar" !== e[p].type && "rangeArea" !== e[p].type || (r.isRangeData = !0,
                    r.isComboCharts ? "rangeBar" !== e[p].type && "rangeArea" !== e[p].type || this.handleRangeData(e, p) : "rangeBar" !== s.chart.type && "rangeArea" !== s.chart.type || this.handleRangeData(e, p)),
                    this.isMultiFormat())
                        this.isFormat2DArray() ? this.handleFormat2DArray(e, p) : this.isFormatXY() && this.handleFormatXY(e, p),
                        "candlestick" !== s.chart.type && "candlestick" !== e[p].type && "boxPlot" !== s.chart.type && "boxPlot" !== e[p].type || this.handleCandleStickBoxData(e, p),
                        r.series.push(this.twoDSeries),
                        r.labels.push(this.twoDSeriesX),
                        r.seriesX.push(this.twoDSeriesX),
                        r.seriesGoals = this.seriesGoals,
                        p !== this.activeSeriesIndex || this.fallbackToCategory || (r.isXNumeric = !0);
                    else {
                        "datetime" === s.xaxis.type ? (r.isXNumeric = !0,
                        u(),
                        r.seriesX.push(this.twoDSeriesX)) : "numeric" === s.xaxis.type && (r.isXNumeric = !0,
                        o.length > 0 && (this.twoDSeriesX = o,
                        r.seriesX.push(this.twoDSeriesX))),
                        r.labels.push(this.twoDSeriesX);
                        var x = e[p].data.map(function(b) {
                            return D.parseNumber(b)
                        });
                        r.series.push(x)
                    }
                    r.seriesZ.push(this.threeDSeries),
                    r.seriesNames.push(void 0 !== e[p].name ? e[p].name : "series-" + parseInt(p + 1, 10)),
                    r.seriesColors.push(void 0 !== e[p].color ? e[p].color : void 0)
                }
                return this.w
            }
        }, {
            key: "parseDataNonAxisCharts",
            value: function(e) {
                var t = this.w.globals
                  , i = this.w.config;
                t.series = e.slice(),
                t.seriesNames = i.labels.slice();
                for (var a = 0; a < t.series.length; a++)
                    void 0 === t.seriesNames[a] && t.seriesNames.push("series-" + (a + 1));
                return this.w
            }
        }, {
            key: "handleExternalLabelsData",
            value: function(e) {
                var t = this.w.config
                  , i = this.w.globals;
                t.xaxis.categories.length > 0 ? i.labels = t.xaxis.categories : t.labels.length > 0 ? i.labels = t.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0],
                i.seriesRange.length && (i.seriesRange.map(function(a) {
                    a.forEach(function(s) {
                        i.labels.indexOf(s.x) < 0 && s.x && i.labels.push(s.x)
                    })
                }),
                i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)),
                t.xaxis.convertedCatToNumeric && (new xt(t).convertCatToNumericXaxis(t, this.ctx, i.seriesX[0]),
                this._generateExternalLabels(e))) : this._generateExternalLabels(e)
            }
        }, {
            key: "_generateExternalLabels",
            value: function(e) {
                var t = this.w.globals
                  , i = this.w.config
                  , a = [];
                if (t.axisCharts) {
                    if (t.series.length > 0)
                        if (this.isFormatXY())
                            for (var s = i.series.map(function(u, p) {
                                return u.data.filter(function(x, b, k) {
                                    return k.findIndex(function(S) {
                                        return S.x === x.x
                                    }) === b
                                })
                            }), r = s.reduce(function(u, p, x, b) {
                                return b[u].length > p.length ? u : x
                            }, 0), n = 0; n < s[r].length; n++)
                                a.push(n + 1);
                        else
                            for (var o = 0; o < t.series[t.maxValsInArrayIndex].length; o++)
                                a.push(o + 1);
                    t.seriesX = [];
                    for (var h = 0; h < e.length; h++)
                        t.seriesX.push(a);
                    this.w.globals.isBarHorizontal || (t.isXNumeric = !0)
                }
                if (0 === a.length) {
                    a = t.axisCharts ? [] : t.series.map(function(u, p) {
                        return p + 1
                    });
                    for (var d = 0; d < e.length; d++)
                        t.seriesX.push(a)
                }
                t.labels = a,
                i.xaxis.convertedCatToNumeric && (t.categoryLabels = a.map(function(u) {
                    return i.xaxis.labels.formatter(u)
                })),
                t.noLabelsProvided = !0
            }
        }, {
            key: "parseData",
            value: function(e) {
                var t = this.w
                  , i = t.config
                  , a = t.globals;
                if (this.excludeCollapsedSeriesInYAxis(),
                this.fallbackToCategory = !1,
                this.ctx.core.resetGlobals(),
                this.ctx.core.isMultipleY(),
                a.axisCharts ? (this.parseDataAxisCharts(e),
                this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e),
                i.chart.stacked) {
                    var s = new Lt(this.ctx);
                    a.series = s.setNullSeriesToZeroValues(a.series)
                }
                this.coreUtils.getSeriesTotals(),
                a.axisCharts && (a.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals()),
                this.coreUtils.getPercentSeries(),
                a.dataFormatXNumeric || a.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(e);
                for (var r = this.coreUtils.getCategoryLabels(a.labels), n = 0; n < r.length; n++)
                    if (Array.isArray(r[n])) {
                        a.isMultiLineX = !0;
                        break
                    }
            }
        }, {
            key: "excludeCollapsedSeriesInYAxis",
            value: function() {
                var e = this
                  , t = this.w;
                t.globals.ignoreYAxisIndexes = t.globals.collapsedSeries.map(function(i, a) {
                    if (e.w.globals.isMultipleYAxis && !t.config.chart.stacked)
                        return i.index
                })
            }
        }]),
        C
    }()
      , Mt = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "getLabel",
            value: function(e, t, i, a) {
                var S, E, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", n = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], o = this.w, h = void 0 === e[a] ? "" : e[a], d = h, u = o.globals.xLabelFormatter, p = o.config.xaxis.labels.formatter, x = !1, b = new At(this.ctx), k = h;
                n && (d = b.xLabelFormat(u, h, k, {
                    i: a,
                    dateFormatter: new We(this.ctx).formatDate,
                    w: o
                }),
                void 0 !== p && (d = p(h, e[a], {
                    i: a,
                    dateFormatter: new We(this.ctx).formatDate,
                    w: o
                }))),
                t.length > 0 ? (S = t[a].unit,
                E = null,
                t.forEach(function(w) {
                    "month" === w.unit ? E = "year" : "day" === w.unit ? E = "month" : "hour" === w.unit ? E = "day" : "minute" === w.unit && (E = "hour")
                }),
                x = E === S,
                i = t[a].position,
                d = t[a].value) : "datetime" === o.config.xaxis.type && void 0 === p && (d = ""),
                void 0 === d && (d = ""),
                d = Array.isArray(d) ? d : d.toString();
                var M = new U(this.ctx)
                  , l = {};
                l = o.globals.rotateXLabels && n ? M.getTextRects(d, parseInt(r, 10), null, "rotate(".concat(o.config.xaxis.labels.rotate, " 0 0)"), !1) : M.getTextRects(d, parseInt(r, 10));
                var f = !o.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                return !Array.isArray(d) && (0 === d.indexOf("NaN") || 0 === d.toLowerCase().indexOf("invalid") || d.toLowerCase().indexOf("infinity") >= 0 || s.indexOf(d) >= 0 && f) && (d = ""),
                {
                    x: i,
                    text: d,
                    textRect: l,
                    isBold: x
                }
            }
        }, {
            key: "checkLabelBasedOnTickamount",
            value: function(e, t, i) {
                var a = this.w
                  , s = a.config.xaxis.tickAmount;
                return "dataPoints" === s && (s = Math.round(a.globals.gridWidth / 120)),
                s > i || e % Math.round(i / (s + 1)) == 0 || (t.text = ""),
                t
            }
        }, {
            key: "checkForOverflowingLabels",
            value: function(e, t, i, a, s) {
                var r = this.w;
                if (0 === e && r.globals.skipFirstTimelinelabel && (t.text = ""),
                e === i - 1 && r.globals.skipLastTimelinelabel && (t.text = ""),
                r.config.xaxis.labels.hideOverlappingLabels && a.length > 0) {
                    var n = s[s.length - 1];
                    t.x < n.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + n.x && (t.text = "")
                }
                return t
            }
        }, {
            key: "checkForReversedLabels",
            value: function(e, t) {
                var i = this.w;
                return i.config.yaxis[e] && i.config.yaxis[e].reversed && t.reverse(),
                t
            }
        }, {
            key: "isYAxisHidden",
            value: function(e) {
                var t = this.w
                  , i = new ae(this.ctx);
                return !t.config.yaxis[e].show || !t.config.yaxis[e].showForNullSeries && i.isSeriesNull(e) && -1 === t.globals.collapsedSeriesIndices.indexOf(e)
            }
        }, {
            key: "getYAxisForeColor",
            value: function(e, t) {
                var i = this.w;
                return Array.isArray(e) && i.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(e, i.globals.yAxisScale[t].result.length, !1),
                e
            }
        }, {
            key: "drawYAxisTicks",
            value: function(e, t, i, a, s, r, n) {
                var o = this.w
                  , h = new U(this.ctx)
                  , d = o.globals.translateY;
                if (a.show && t > 0) {
                    !0 === o.config.yaxis[s].opposite && (e += a.width);
                    for (var u = t; u >= 0; u--) {
                        var p = d + t / 10 + o.config.yaxis[s].labels.offsetY - 1;
                        o.globals.isBarHorizontal && (p = r * u),
                        "heatmap" === o.config.chart.type && (p += r / 2);
                        var x = h.drawLine(e + i.offsetX - a.width + a.offsetX, p + a.offsetY, e + i.offsetX + a.offsetX, p + a.offsetY, a.color);
                        n.add(x),
                        d += r
                    }
                }
            }
        }]),
        C
    }()
      , Ft = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "scaleSvgNode",
            value: function(e, t) {
                var i = parseFloat(e.getAttributeNS(null, "width"))
                  , a = parseFloat(e.getAttributeNS(null, "height"));
                e.setAttributeNS(null, "width", i * t),
                e.setAttributeNS(null, "height", a * t),
                e.setAttributeNS(null, "viewBox", "0 0 " + i + " " + a)
            }
        }, {
            key: "fixSvgStringForIe11",
            value: function(e) {
                if (!D.isIE11())
                    return e.replace(/&nbsp;/g, "&#160;");
                var t = 0
                  , i = e.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(a) {
                    return 2 == ++t ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : a
                });
                return (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
            }
        }, {
            key: "getSvgString",
            value: function(e) {
                null == e && (e = 1);
                var t = this.w.globals.dom.Paper.svg();
                if (1 !== e) {
                    var i = this.w.globals.dom.Paper.node.cloneNode(!0);
                    this.scaleSvgNode(i, e),
                    t = (new XMLSerializer).serializeToString(i)
                }
                return this.fixSvgStringForIe11(t)
            }
        }, {
            key: "cleanup",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs")
                  , i = e.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs")
                  , a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                Array.prototype.forEach.call(a, function(s) {
                    s.setAttribute("width", 0)
                }),
                t && t[0] && (t[0].setAttribute("x", -500),
                t[0].setAttribute("x1", -500),
                t[0].setAttribute("x2", -500)),
                i && i[0] && (i[0].setAttribute("y", -100),
                i[0].setAttribute("y1", -100),
                i[0].setAttribute("y2", -100))
            }
        }, {
            key: "svgUrl",
            value: function() {
                this.cleanup();
                var e = this.getSvgString()
                  , t = new Blob([e],{
                    type: "image/svg+xml;charset=utf-8"
                });
                return URL.createObjectURL(t)
            }
        }, {
            key: "dataURI",
            value: function(e) {
                var t = this;
                return new Promise(function(i) {
                    var a = t.w
                      , s = e ? e.scale || e.width / a.globals.svgWidth : 1;
                    t.cleanup();
                    var r = document.createElement("canvas");
                    r.width = a.globals.svgWidth * s,
                    r.height = parseInt(a.globals.dom.elWrap.style.height, 10) * s;
                    var n = "transparent" === a.config.chart.background ? "#fff" : a.config.chart.background
                      , o = r.getContext("2d");
                    o.fillStyle = n,
                    o.fillRect(0, 0, r.width * s, r.height * s);
                    var h = t.getSvgString(s);
                    if (window.canvg && D.isIE11()) {
                        var d = window.canvg.Canvg.fromString(o, h, {
                            ignoreClear: !0,
                            ignoreDimensions: !0
                        });
                        d.start();
                        var u = r.msToBlob();
                        d.stop(),
                        i({
                            blob: u
                        })
                    } else {
                        var p = "data:image/svg+xml," + encodeURIComponent(h)
                          , x = new Image;
                        x.crossOrigin = "anonymous",
                        x.onload = function() {
                            if (o.drawImage(x, 0, 0),
                            r.msToBlob) {
                                var b = r.msToBlob();
                                i({
                                    blob: b
                                })
                            } else {
                                var k = r.toDataURL("image/png");
                                i({
                                    imgURI: k
                                })
                            }
                        }
                        ,
                        x.src = p
                    }
                }
                )
            }
        }, {
            key: "exportToSVG",
            value: function() {
                this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg")
            }
        }, {
            key: "exportToPng",
            value: function() {
                var e = this;
                this.dataURI().then(function(t) {
                    var i = t.imgURI
                      , a = t.blob;
                    a ? navigator.msSaveOrOpenBlob(a, e.w.globals.chartID + ".png") : e.triggerDownload(i, e.w.config.chart.toolbar.export.png.filename, ".png")
                })
            }
        }, {
            key: "exportToCSV",
            value: function(e) {
                var t = this
                  , i = e.series
                  , a = e.fileName
                  , s = e.columnDelimiter
                  , r = void 0 === s ? "," : s
                  , n = e.lineDelimiter
                  , o = void 0 === n ? "\n" : n
                  , h = this.w;
                i || (i = h.config.series);
                var d = []
                  , u = []
                  , p = ""
                  , x = h.globals.series.map(function(l, f) {
                    return -1 === h.globals.collapsedSeriesIndices.indexOf(f) ? l : []
                })
                  , b = Math.max.apply(Math, J(i.map(function(l) {
                    return l.data ? l.data.length : 0
                })))
                  , k = new Ct(this.ctx)
                  , S = new Mt(this.ctx)
                  , E = function(l) {
                    var f = "";
                    if (h.globals.axisCharts) {
                        if ("category" === h.config.xaxis.type || h.config.xaxis.convertedCatToNumeric)
                            if (h.globals.isBarHorizontal) {
                                var w = h.globals.yLabelFormatters[0]
                                  , _ = new Lt(t.ctx).getActiveConfigSeriesIndex();
                                f = w(h.globals.labels[l], {
                                    seriesIndex: _,
                                    dataPointIndex: l,
                                    w: h
                                })
                            } else
                                f = S.getLabel(h.globals.labels, h.globals.timescaleLabels, 0, l).text;
                        "datetime" === h.config.xaxis.type && (h.config.xaxis.categories.length ? f = h.config.xaxis.categories[l] : h.config.labels.length && (f = h.config.labels[l]))
                    } else
                        f = h.config.labels[l];
                    return Array.isArray(f) && (f = f.join(" ")),
                    D.isNumber(f) ? f : f.split(r).join("")
                };
                d.push(h.config.chart.toolbar.export.csv.headerCategory),
                "boxPlot" === h.config.chart.type ? (d.push("minimum"),
                d.push("q1"),
                d.push("median"),
                d.push("q3"),
                d.push("maximum")) : "candlestick" === h.config.chart.type ? (d.push("open"),
                d.push("high"),
                d.push("low"),
                d.push("close")) : "rangeBar" === h.config.chart.type ? (d.push("minimum"),
                d.push("maximum")) : i.map(function(l, f) {
                    var w = (l.name ? l.name : "series-".concat(f)) + "";
                    h.globals.axisCharts && d.push(w.split(r).join("") ? w.split(r).join("") : "series-".concat(f))
                }),
                h.globals.axisCharts || (d.push(h.config.chart.toolbar.export.csv.headerValue),
                u.push(d.join(r))),
                i.map(function(l, f) {
                    h.globals.axisCharts ? function(l, f) {
                        if (d.length && 0 === f && u.push(d.join(r)),
                        l.data) {
                            l.data = l.data.length && l.data || J(Array(b)).map(function() {
                                return ""
                            });
                            for (var w = 0; w < l.data.length; w++) {
                                d = [];
                                var _ = E(w);
                                if (_ || (k.isFormatXY() ? _ = i[f].data[w].x : k.isFormat2DArray() && (_ = i[f].data[w] ? i[f].data[w][0] : "")),
                                0 === f) {
                                    d.push("datetime" === h.config.xaxis.type && String(_).length >= 10 ? h.config.chart.toolbar.export.csv.dateFormatter(_) : D.isNumber(_) ? _ : _.split(r).join(""));
                                    for (var R = 0; R < h.globals.series.length; R++) {
                                        var H;
                                        k.isFormatXY() ? d.push(null === (H = i[R].data[w]) || void 0 === H ? void 0 : H.y) : d.push(x[R][w])
                                    }
                                }
                                ("candlestick" === h.config.chart.type || l.type && "candlestick" === l.type) && (d.pop(),
                                d.push(h.globals.seriesCandleO[f][w]),
                                d.push(h.globals.seriesCandleH[f][w]),
                                d.push(h.globals.seriesCandleL[f][w]),
                                d.push(h.globals.seriesCandleC[f][w])),
                                ("boxPlot" === h.config.chart.type || l.type && "boxPlot" === l.type) && (d.pop(),
                                d.push(h.globals.seriesCandleO[f][w]),
                                d.push(h.globals.seriesCandleH[f][w]),
                                d.push(h.globals.seriesCandleM[f][w]),
                                d.push(h.globals.seriesCandleL[f][w]),
                                d.push(h.globals.seriesCandleC[f][w])),
                                "rangeBar" === h.config.chart.type && (d.pop(),
                                d.push(h.globals.seriesRangeStart[f][w]),
                                d.push(h.globals.seriesRangeEnd[f][w])),
                                d.length && u.push(d.join(r))
                            }
                        }
                    }(l, f) : ((d = []).push(h.globals.labels[f].split(r).join("")),
                    d.push(x[f]),
                    u.push(d.join(r)))
                }),
                p += u.join(o),
                this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + p), a || h.config.chart.toolbar.export.csv.filename, ".csv")
            }
        }, {
            key: "triggerDownload",
            value: function(e, t, i) {
                var a = document.createElement("a");
                a.href = e,
                a.download = (t || this.w.globals.chartID) + i,
                document.body.appendChild(a),
                a.click(),
                document.body.removeChild(a)
            }
        }]),
        C
    }()
      , Ot = function() {
        function C(e, t) {
            Q(this, C),
            this.ctx = e,
            this.elgrid = t,
            this.w = e.w;
            var i = this.w;
            this.axesUtils = new Mt(e),
            this.xaxisLabels = i.globals.labels.slice(),
            i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()),
            i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories),
            this.drawnLabels = [],
            this.drawnLabelsRects = [],
            this.offY = "top" === i.config.xaxis.position ? 0 : i.globals.gridHeight + 1,
            this.offY = this.offY + i.config.xaxis.axisBorder.offsetY,
            this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal,
            this.xaxisFontSize = i.config.xaxis.labels.style.fontSize,
            this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily,
            this.xaxisForeColors = i.config.xaxis.labels.style.colors,
            this.xaxisBorderWidth = i.config.xaxis.axisBorder.width,
            this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()),
            this.xaxisBorderWidth = this.xaxisBorderWidth.indexOf("%") > -1 ? i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : parseInt(this.xaxisBorderWidth, 10),
            this.xaxisBorderHeight = i.config.xaxis.axisBorder.height,
            this.yaxis = i.config.yaxis[0]
        }
        return Te(C, [{
            key: "drawXaxis",
            value: function() {
                var e = this.w
                  , t = new U(this.ctx)
                  , i = t.group({
                    class: "apexcharts-xaxis",
                    transform: "translate(".concat(e.config.xaxis.offsetX, ", ").concat(e.config.xaxis.offsetY, ")")
                })
                  , a = t.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
                });
                i.add(a);
                for (var s = [], r = 0; r < this.xaxisLabels.length; r++)
                    s.push(this.xaxisLabels[r]);
                if (this.drawXAxisLabelAndGroup(!0, t, a, s, e.globals.isXNumeric, function(b, k) {
                    return k
                }),
                e.globals.hasXaxisGroups) {
                    var n = e.globals.groups;
                    s = [];
                    for (var o = 0; o < n.length; o++)
                        s.push(n[o].title);
                    var h = {};
                    e.config.xaxis.group.style && (h.xaxisFontSize = e.config.xaxis.group.style.fontSize,
                    h.xaxisFontFamily = e.config.xaxis.group.style.fontFamily,
                    h.xaxisForeColors = e.config.xaxis.group.style.colors,
                    h.fontWeight = e.config.xaxis.group.style.fontWeight,
                    h.cssClass = e.config.xaxis.group.style.cssClass),
                    this.drawXAxisLabelAndGroup(!1, t, a, s, !1, function(b, k) {
                        return n[b].cols * k
                    }, h)
                }
                if (void 0 !== e.config.xaxis.title.text) {
                    var d = t.group({
                        class: "apexcharts-xaxis-title"
                    })
                      , u = t.drawText({
                        x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                        y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === e.config.xaxis.position ? e.globals.xAxisLabelsHeight : -e.globals.xAxisLabelsHeight - 10) + e.config.xaxis.title.offsetY,
                        text: e.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: e.config.xaxis.title.style.fontSize,
                        fontFamily: e.config.xaxis.title.style.fontFamily,
                        fontWeight: e.config.xaxis.title.style.fontWeight,
                        foreColor: e.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
                    });
                    d.add(u),
                    i.add(d)
                }
                if (e.config.xaxis.axisBorder.show) {
                    var p = e.globals.barPadForNumericAxis
                      , x = t.drawLine(e.globals.padHorizontal + e.config.xaxis.axisBorder.offsetX - p, this.offY, this.xaxisBorderWidth + p, this.offY, e.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                    this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders.add(x) : i.add(x)
                }
                return i
            }
        }, {
            key: "drawXAxisLabelAndGroup",
            value: function(e, t, i, a, s, r) {
                var n, o = this, h = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, d = [], u = [], p = this.w, x = h.xaxisFontSize || this.xaxisFontSize, b = h.xaxisFontFamily || this.xaxisFontFamily, k = h.xaxisForeColors || this.xaxisForeColors, S = h.fontWeight || p.config.xaxis.labels.style.fontWeight, E = h.cssClass || p.config.xaxis.labels.style.cssClass, M = p.globals.padHorizontal, l = a.length, f = "category" === p.config.xaxis.type ? p.globals.dataPoints : l;
                if (0 === f && l > f && (f = l),
                s) {
                    var w = f > 1 ? f - 1 : f;
                    n = p.globals.gridWidth / Math.min(w, l - 1),
                    M = M + r(0, n) / 2 + p.config.xaxis.labels.offsetX
                } else
                    M = M + r(0, n = p.globals.gridWidth / f) + p.config.xaxis.labels.offsetX;
                for (var _ = function(H) {
                    var B = M - r(H, n) / 2 + p.config.xaxis.labels.offsetX;
                    0 === H && 1 === l && n / 2 === M && 1 === f && (B = p.globals.gridWidth / 2);
                    var j = o.axesUtils.getLabel(a, p.globals.timescaleLabels, B, H, d, x, e)
                      , ce = 28;
                    if (p.globals.rotateXLabels && e && (ce = 22),
                    p.config.xaxis.title.text && "top" === p.config.xaxis.position && (ce += parseFloat(p.config.xaxis.title.style.fontSize) + 2),
                    e || (ce = ce + parseFloat(x) + (p.globals.xAxisLabelsHeight - p.globals.xAxisGroupLabelsHeight) + (p.globals.rotateXLabels ? 10 : 0)),
                    j = void 0 !== p.config.xaxis.tickAmount && "dataPoints" !== p.config.xaxis.tickAmount && "datetime" !== p.config.xaxis.type ? o.axesUtils.checkLabelBasedOnTickamount(H, j, l) : o.axesUtils.checkForOverflowingLabels(H, j, l, d, u),
                    p.config.xaxis.labels.show) {
                        var me = t.drawText({
                            x: j.x,
                            y: o.offY + p.config.xaxis.labels.offsetY + ce - ("top" === p.config.xaxis.position ? p.globals.xAxisHeight + p.config.xaxis.axisTicks.height - 2 : 0),
                            text: j.text,
                            textAnchor: "middle",
                            fontWeight: j.isBold ? 600 : S,
                            fontSize: x,
                            fontFamily: b,
                            foreColor: Array.isArray(k) ? e && p.config.xaxis.convertedCatToNumeric ? k[p.globals.minX + H - 1] : k[H] : k,
                            isPlainText: !1,
                            cssClass: (e ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + E
                        });
                        if (i.add(me),
                        me.on("click", function(Ee) {
                            if ("function" == typeof p.config.chart.events.xAxisLabelClick) {
                                var Ie = Object.assign({}, p, {
                                    labelIndex: H
                                });
                                p.config.chart.events.xAxisLabelClick(Ee, o.ctx, Ie)
                            }
                        }),
                        e) {
                            var ue = document.createElementNS(p.globals.SVGNS, "title");
                            ue.textContent = Array.isArray(j.text) ? j.text.join(" ") : j.text,
                            me.node.appendChild(ue),
                            "" !== j.text && (d.push(j.text),
                            u.push(j))
                        }
                    }
                    H < l - 1 && (M += r(H + 1, n))
                }, R = 0; R <= l - 1; R++)
                    _(R)
            }
        }, {
            key: "drawXaxisInversed",
            value: function(e) {
                var t, i, a = this, s = this.w, r = new U(this.ctx), n = s.config.yaxis[0].opposite ? s.globals.translateYAxisX[e] : 0, o = r.group({
                    class: "apexcharts-yaxis apexcharts-xaxis-inversed",
                    rel: e
                }), h = r.group({
                    class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                    transform: "translate(" + n + ", 0)"
                });
                o.add(h);
                var d = [];
                if (s.config.yaxis[e].show)
                    for (var u = 0; u < this.xaxisLabels.length; u++)
                        d.push(this.xaxisLabels[u]);
                i = -(t = s.globals.gridHeight / d.length) / 2.2;
                var p = s.globals.yLabelFormatters[0]
                  , x = s.config.yaxis[0].labels;
                if (x.show)
                    for (var b = function(w) {
                        var _ = void 0 === d[w] ? "" : d[w];
                        _ = p(_, {
                            seriesIndex: e,
                            dataPointIndex: w,
                            w: s
                        });
                        var R = a.axesUtils.getYAxisForeColor(x.style.colors, e)
                          , H = 0;
                        Array.isArray(_) && (H = _.length / 2 * parseInt(x.style.fontSize, 10));
                        var B = x.offsetX - 15
                          , j = "end";
                        a.yaxis.opposite && (j = "start"),
                        "left" === s.config.yaxis[0].labels.align ? (B = x.offsetX,
                        j = "start") : "center" === s.config.yaxis[0].labels.align ? (B = x.offsetX,
                        j = "middle") : "right" === s.config.yaxis[0].labels.align && (j = "end");
                        var ce = r.drawText({
                            x: B,
                            y: i + t + x.offsetY - H,
                            text: _,
                            textAnchor: j,
                            foreColor: Array.isArray(R) ? R[w] : R,
                            fontSize: x.style.fontSize,
                            fontFamily: x.style.fontFamily,
                            fontWeight: x.style.fontWeight,
                            isPlainText: !1,
                            cssClass: "apexcharts-yaxis-label " + x.style.cssClass,
                            maxWidth: x.maxWidth
                        });
                        h.add(ce),
                        ce.on("click", function(Ee) {
                            if ("function" == typeof s.config.chart.events.xAxisLabelClick) {
                                var Ie = Object.assign({}, s, {
                                    labelIndex: w
                                });
                                s.config.chart.events.xAxisLabelClick(Ee, a.ctx, Ie)
                            }
                        });
                        var me = document.createElementNS(s.globals.SVGNS, "title");
                        if (me.textContent = Array.isArray(_) ? _.join(" ") : _,
                        ce.node.appendChild(me),
                        0 !== s.config.yaxis[e].labels.rotate) {
                            var ue = r.rotateAroundCenter(ce.node);
                            ce.node.setAttribute("transform", "rotate(".concat(s.config.yaxis[e].labels.rotate, " 0 ").concat(ue.y, ")"))
                        }
                        i += t
                    }, k = 0; k <= d.length - 1; k++)
                        b(k);
                if (void 0 !== s.config.yaxis[0].title.text) {
                    var S = r.group({
                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                        transform: "translate(" + n + ", 0)"
                    })
                      , E = r.drawText({
                        x: s.config.yaxis[0].title.offsetX,
                        y: s.globals.gridHeight / 2 + s.config.yaxis[0].title.offsetY,
                        text: s.config.yaxis[0].title.text,
                        textAnchor: "middle",
                        foreColor: s.config.yaxis[0].title.style.color,
                        fontSize: s.config.yaxis[0].title.style.fontSize,
                        fontWeight: s.config.yaxis[0].title.style.fontWeight,
                        fontFamily: s.config.yaxis[0].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + s.config.yaxis[0].title.style.cssClass
                    });
                    S.add(E),
                    o.add(S)
                }
                var M = 0;
                this.isCategoryBarHorizontal && s.config.yaxis[0].opposite && (M = s.globals.gridWidth);
                var l = s.config.xaxis.axisBorder;
                if (l.show) {
                    var f = r.drawLine(s.globals.padHorizontal + l.offsetX + M, 1 + l.offsetY, s.globals.padHorizontal + l.offsetX + M, s.globals.gridHeight + l.offsetY, l.color, 0);
                    this.elgrid && this.elgrid.elGridBorders && s.config.grid.show ? this.elgrid.elGridBorders.add(f) : o.add(f)
                }
                return s.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(M, d.length, s.config.yaxis[0].axisBorder, s.config.yaxis[0].axisTicks, 0, t, o),
                o
            }
        }, {
            key: "drawXaxisTicks",
            value: function(e, t, i) {
                var a = this.w
                  , s = e;
                if (!(e < 0 || e - 2 > a.globals.gridWidth)) {
                    var r = this.offY + a.config.xaxis.axisTicks.offsetY;
                    if (t = t + r + a.config.xaxis.axisTicks.height,
                    "top" === a.config.xaxis.position && (t = r - a.config.xaxis.axisTicks.height),
                    a.config.xaxis.axisTicks.show) {
                        var n = new U(this.ctx).drawLine(e + a.config.xaxis.axisTicks.offsetX, r + a.config.xaxis.offsetY, s + a.config.xaxis.axisTicks.offsetX, t + a.config.xaxis.offsetY, a.config.xaxis.axisTicks.color);
                        i.add(n),
                        n.node.classList.add("apexcharts-xaxis-tick")
                    }
                }
            }
        }, {
            key: "getXAxisTicksPositions",
            value: function() {
                var e = this.w
                  , t = []
                  , i = this.xaxisLabels.length
                  , a = e.globals.padHorizontal;
                if (e.globals.timescaleLabels.length > 0)
                    for (var s = 0; s < i; s++)
                        t.push(a = this.xaxisLabels[s].position);
                else
                    for (var r = i, n = 0; n < r; n++) {
                        var o = r;
                        e.globals.isXNumeric && "bar" !== e.config.chart.type && (o -= 1),
                        t.push(a += e.globals.gridWidth / o)
                    }
                return t
            }
        }, {
            key: "xAxisLabelCorrections",
            value: function() {
                var e = this.w
                  , t = new U(this.ctx)
                  , i = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g")
                  , a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)")
                  , s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text")
                  , r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                if (e.globals.rotateXLabels || e.config.xaxis.labels.rotateAlways)
                    for (var n = 0; n < a.length; n++) {
                        var o = t.rotateAroundCenter(a[n]);
                        o.y = o.y - 1,
                        o.x = o.x + 1,
                        a[n].setAttribute("transform", "rotate(".concat(e.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")),
                        a[n].setAttribute("text-anchor", "end"),
                        i.setAttribute("transform", "translate(0, ".concat(-10, ")")),
                        e.config.xaxis.labels.trim && Array.prototype.forEach.call(a[n].childNodes, function(x) {
                            t.placeTextWithEllipsis(x, x.textContent, e.globals.xAxisLabelsHeight - ("bottom" === e.config.legend.position ? 20 : 10))
                        })
                    }
                else
                    !function() {
                        for (var x = e.globals.gridWidth / (e.globals.labels.length + 1), b = 0; b < a.length; b++)
                            e.config.xaxis.labels.trim && "datetime" !== e.config.xaxis.type && Array.prototype.forEach.call(a[b].childNodes, function(S) {
                                t.placeTextWithEllipsis(S, S.textContent, x)
                            })
                    }();
                if (s.length > 0) {
                    var d = s[s.length - 1].getBBox()
                      , u = s[0].getBBox();
                    d.x < -20 && s[s.length - 1].parentNode.removeChild(s[s.length - 1]),
                    u.x + u.width > e.globals.gridWidth && !e.globals.isBarHorizontal && s[0].parentNode.removeChild(s[0]);
                    for (var p = 0; p < r.length; p++)
                        t.placeTextWithEllipsis(r[p], r[p].textContent, e.config.yaxis[0].labels.maxWidth - (e.config.yaxis[0].title.text ? 2 * parseFloat(e.config.yaxis[0].title.style.fontSize) : 0) - 15)
                }
            }
        }]),
        C
    }()
      , Be = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.xaxisLabels = t.globals.labels.slice(),
            this.axesUtils = new Mt(e),
            this.isRangeBar = t.globals.seriesRange.length && t.globals.isBarHorizontal,
            t.globals.timescaleLabels.length > 0 && (this.xaxisLabels = t.globals.timescaleLabels.slice())
        }
        return Te(C, [{
            key: "drawGridArea",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = this.w
                  , i = new U(this.ctx);
                null === e && (e = i.group({
                    class: "apexcharts-grid"
                }));
                var a = i.drawLine(t.globals.padHorizontal, 1, t.globals.padHorizontal, t.globals.gridHeight, "transparent")
                  , s = i.drawLine(t.globals.padHorizontal, t.globals.gridHeight, t.globals.gridWidth, t.globals.gridHeight, "transparent");
                return e.add(s),
                e.add(a),
                e
            }
        }, {
            key: "drawGrid",
            value: function() {
                var e = null;
                return this.w.globals.axisCharts && (e = this.renderGrid(),
                this.drawGridArea(e.el)),
                e
            }
        }, {
            key: "createGridMask",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = new U(this.ctx)
                  , a = Array.isArray(e.config.stroke.width) ? 0 : e.config.stroke.width;
                if (Array.isArray(e.config.stroke.width)) {
                    var s = 0;
                    e.config.stroke.width.forEach(function(u) {
                        s = Math.max(s, u)
                    }),
                    a = s
                }
                t.dom.elGridRectMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(t.cuid)),
                t.dom.elGridRectMarkerMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(t.cuid)),
                t.dom.elForecastMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elForecastMask.setAttribute("id", "forecastMask".concat(t.cuid)),
                t.dom.elNonForecastMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(t.cuid));
                var r = e.config.chart.type
                  , n = 0
                  , o = 0;
                ("bar" === r || "rangeBar" === r || "candlestick" === r || "boxPlot" === r || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && (o = e.config.grid.padding.right,
                t.barPadForNumericAxis > (n = e.config.grid.padding.left) && (n = t.barPadForNumericAxis,
                o = t.barPadForNumericAxis)),
                t.dom.elGridRect = i.drawRect(-a / 2 - n - 2, -a / 2, t.gridWidth + a + o + n + 4, t.gridHeight + a, 0, "#fff");
                var h = e.globals.markers.largestSize + 1;
                t.dom.elGridRectMarker = i.drawRect(2 * -h, 2 * -h, t.gridWidth + 4 * h, t.gridHeight + 4 * h, 0, "#fff"),
                t.dom.elGridRectMask.appendChild(t.dom.elGridRect.node),
                t.dom.elGridRectMarkerMask.appendChild(t.dom.elGridRectMarker.node);
                var d = t.dom.baseEl.querySelector("defs");
                d.appendChild(t.dom.elGridRectMask),
                d.appendChild(t.dom.elForecastMask),
                d.appendChild(t.dom.elNonForecastMask),
                d.appendChild(t.dom.elGridRectMarkerMask)
            }
        }, {
            key: "_drawGridLines",
            value: function(e) {
                var t = e.i
                  , i = e.x1
                  , n = e.xCount
                  , h = this.w;
                if (!(0 === t && h.globals.skipFirstTimelinelabel || t === n - 1 && h.globals.skipLastTimelinelabel && !h.config.xaxis.labels.formatter || "radar" === h.config.chart.type)) {
                    h.config.grid.xaxis.lines.show && this._drawGridLine({
                        i: t,
                        x1: i,
                        y1: e.y1,
                        x2: e.x2,
                        y2: e.y2,
                        xCount: n,
                        parent: e.parent
                    });
                    var d = 0;
                    if (h.globals.hasXaxisGroups && "between" === h.config.xaxis.tickPlacement) {
                        var u = h.globals.groups;
                        if (u) {
                            for (var p = 0, x = 0; p < t && x < u.length; x++)
                                p += u[x].cols;
                            p === t && (d = .6 * h.globals.xAxisLabelsHeight)
                        }
                    }
                    new Ot(this.ctx).drawXaxisTicks(i, d, h.globals.dom.elGraphical)
                }
            }
        }, {
            key: "_drawGridLine",
            value: function(e) {
                var t = e.i
                  , i = e.x1
                  , a = e.y1
                  , s = e.x2
                  , r = e.y2
                  , n = e.xCount
                  , o = e.parent
                  , h = this.w
                  , d = !1
                  , u = o.node.classList.contains("apexcharts-gridlines-horizontal")
                  , p = h.config.grid.strokeDashArray
                  , x = h.globals.barPadForNumericAxis;
                (0 === a && 0 === r || 0 === i && 0 === s) && (d = !0),
                a === h.globals.gridHeight && r === h.globals.gridHeight && (d = !0),
                !h.globals.isBarHorizontal || 0 !== t && t !== n - 1 || (d = !0);
                var b = new U(this).drawLine(i - (u ? x : 0), a, s + (u ? x : 0), r, h.config.grid.borderColor, p);
                b.node.classList.add("apexcharts-gridline"),
                d && h.config.grid.show ? this.elGridBorders.add(b) : o.add(b)
            }
        }, {
            key: "_drawGridBandRect",
            value: function(e) {
                var t = e.c
                  , i = e.x1
                  , a = e.y1
                  , s = e.x2
                  , r = e.y2
                  , n = e.type
                  , o = this.w
                  , h = new U(this.ctx)
                  , d = o.globals.barPadForNumericAxis;
                if ("column" !== n || "datetime" !== o.config.xaxis.type) {
                    var p = h.drawRect(i - ("row" === n ? d : 0), a, s + ("row" === n ? 2 * d : 0), r, 0, o.config.grid[n].colors[t], o.config.grid[n].opacity);
                    this.elg.add(p),
                    p.attr("clip-path", "url(#gridRectMask".concat(o.globals.cuid, ")")),
                    p.node.classList.add("apexcharts-grid-".concat(n))
                }
            }
        }, {
            key: "_drawXYLines",
            value: function(e) {
                var t = this
                  , i = e.xCount
                  , a = e.tickAmount
                  , s = this.w;
                if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show) {
                    var r, n = s.globals.padHorizontal, o = s.globals.gridHeight;
                    s.globals.timescaleLabels.length ? function(b) {
                        for (var k = b.xC, E = b.y1, l = b.y2, f = 0; f < k; f++)
                            t._drawGridLines({
                                i: f,
                                x1: t.xaxisLabels[f].position,
                                y1: E,
                                x2: t.xaxisLabels[f].position,
                                y2: l,
                                xCount: i,
                                parent: t.elgridLinesV
                            })
                    }({
                        xC: i,
                        x1: n,
                        y1: 0,
                        x2: r,
                        y2: o
                    }) : (s.globals.isXNumeric && (i = s.globals.xAxisScale.result.length),
                    function(b) {
                        for (var k = b.xC, S = b.x1, E = b.y1, M = b.x2, l = b.y2, f = 0; f < k + (s.globals.isXNumeric ? 0 : 1); f++)
                            0 === f && 1 === k && 1 === s.globals.dataPoints && (M = S = s.globals.gridWidth / 2),
                            t._drawGridLines({
                                i: f,
                                x1: S,
                                y1: E,
                                x2: M,
                                y2: l,
                                xCount: i,
                                parent: t.elgridLinesV
                            }),
                            M = S += s.globals.gridWidth / (s.globals.isXNumeric ? k - 1 : k)
                    }({
                        xC: i,
                        x1: n,
                        y1: 0,
                        x2: r,
                        y2: o
                    }))
                }
                if (s.config.grid.yaxis.lines.show) {
                    var h = 0
                      , d = 0
                      , u = s.globals.gridWidth
                      , p = a + 1;
                    this.isRangeBar && (p = s.globals.labels.length);
                    for (var x = 0; x < p + (this.isRangeBar ? 1 : 0); x++)
                        this._drawGridLine({
                            i: x,
                            xCount: p + (this.isRangeBar ? 1 : 0),
                            x1: 0,
                            y1: h,
                            x2: u,
                            y2: d,
                            parent: this.elgridLinesH
                        }),
                        d = h += s.globals.gridHeight / (this.isRangeBar ? p : a)
                }
            }
        }, {
            key: "_drawInvertedXYLines",
            value: function(e) {
                var t = e.xCount
                  , i = this.w;
                if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
                    for (var a, s = i.globals.padHorizontal, r = i.globals.gridHeight, n = 0; n < t + 1; n++)
                        i.config.grid.xaxis.lines.show && this._drawGridLine({
                            i: n,
                            xCount: t + 1,
                            x1: s,
                            y1: 0,
                            x2: a,
                            y2: r,
                            parent: this.elgridLinesV
                        }),
                        new Ot(this.ctx).drawXaxisTicks(s, 0, i.globals.dom.elGraphical),
                        a = s = s + i.globals.gridWidth / t + .3;
                if (i.config.grid.yaxis.lines.show)
                    for (var o = 0, h = 0, d = i.globals.gridWidth, u = 0; u < i.globals.dataPoints + 1; u++)
                        this._drawGridLine({
                            i: u,
                            xCount: i.globals.dataPoints + 1,
                            x1: 0,
                            y1: o,
                            x2: d,
                            y2: h,
                            parent: this.elgridLinesH
                        }),
                        h = o += i.globals.gridHeight / i.globals.dataPoints
            }
        }, {
            key: "renderGrid",
            value: function() {
                var e = this.w
                  , t = new U(this.ctx);
                this.elg = t.group({
                    class: "apexcharts-grid"
                }),
                this.elgridLinesH = t.group({
                    class: "apexcharts-gridlines-horizontal"
                }),
                this.elgridLinesV = t.group({
                    class: "apexcharts-gridlines-vertical"
                }),
                this.elGridBorders = t.group({
                    class: "apexcharts-grid-borders"
                }),
                this.elg.add(this.elgridLinesH),
                this.elg.add(this.elgridLinesV),
                e.config.grid.show || (this.elgridLinesV.hide(),
                this.elgridLinesH.hide(),
                this.elGridBorders.hide());
                for (var i, a = e.globals.yAxisScale.length ? e.globals.yAxisScale[0].result.length - 1 : 5, s = 0; s < e.globals.series.length && (void 0 !== e.globals.yAxisScale[s] && (a = e.globals.yAxisScale[s].result.length - 1),
                !(a > 2)); s++)
                    ;
                return !e.globals.isBarHorizontal || this.isRangeBar ? (i = this.xaxisLabels.length,
                this.isRangeBar && (i--,
                a = e.globals.labels.length,
                e.config.xaxis.tickAmount && e.config.xaxis.labels.formatter && (i = e.config.xaxis.tickAmount)),
                this._drawXYLines({
                    xCount: i,
                    tickAmount: a
                })) : this._drawInvertedXYLines({
                    xCount: i = a,
                    tickAmount: a = e.globals.xTickAmount
                }),
                this.drawGridBands(i, a),
                {
                    el: this.elg,
                    elGridBorders: this.elGridBorders,
                    xAxisTickWidth: e.globals.gridWidth / i
                }
            }
        }, {
            key: "drawGridBands",
            value: function(e, t) {
                var i = this.w;
                if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0)
                    for (var a = 0, s = i.globals.gridHeight / t, r = i.globals.gridWidth, n = 0, o = 0; n < t; n++,
                    o++)
                        o >= i.config.grid.row.colors.length && (o = 0),
                        this._drawGridBandRect({
                            c: o,
                            x1: 0,
                            y1: a,
                            x2: r,
                            y2: s,
                            type: "row"
                        }),
                        a += i.globals.gridHeight / t;
                if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0)
                    for (var h = i.globals.isBarHorizontal || "on" !== i.config.xaxis.tickPlacement || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? e : e - 1, d = i.globals.padHorizontal, u = i.globals.padHorizontal + i.globals.gridWidth / h, p = i.globals.gridHeight, x = 0, b = 0; x < e; x++,
                    b++)
                        b >= i.config.grid.column.colors.length && (b = 0),
                        this._drawGridBandRect({
                            c: b,
                            x1: d,
                            y1: 0,
                            x2: u,
                            y2: p,
                            type: "column"
                        }),
                        d += i.globals.gridWidth / h
            }
        }]),
        C
    }()
      , Jt = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "niceScale",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , s = arguments.length > 4 ? arguments[4] : void 0
                  , r = this.w
                  , n = Math.abs(t - e);
                if ("dataPoints" === (i = this._adjustTicksForSmallRange(i, a, n)) && (i = r.globals.dataPoints - 1),
                e === Number.MIN_VALUE && 0 === t || !D.isNumber(e) && !D.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE)
                    return this.linearScale(e = 0, t = i, i);
                e > t ? (console.warn("axis.min cannot be greater than axis.max"),
                t = e + .1) : e === t && (e = 0 === e ? 0 : e - .5,
                t = 0 === t ? 2 : t + .5);
                var o = [];
                n < 1 && s && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[a].type || "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[a].type || r.globals.isRangeData) && (t *= 1.01);
                var h = i + 1;
                h < 2 ? h = 2 : h > 2 && (h -= 2);
                var d = n / h
                  , u = Math.floor(D.log10(d))
                  , p = Math.pow(10, u)
                  , x = Math.round(d / p);
                x < 1 && (x = 1);
                var b = x * p
                  , k = b * Math.floor(e / b)
                  , S = b * Math.ceil(t / b)
                  , E = k;
                if (s && n > 2) {
                    for (; o.push(D.stripNumber(E, 7)),
                    !((E += b) > S); )
                        ;
                    return {
                        result: o,
                        niceMin: o[0],
                        niceMax: o[o.length - 1]
                    }
                }
                var M = e;
                (o = []).push(D.stripNumber(M, 7));
                for (var l = Math.abs(t - e) / i, f = 0; f <= i; f++)
                    o.push(M += l);
                return o[o.length - 2] >= t && o.pop(),
                {
                    result: o,
                    niceMin: o[0],
                    niceMax: o[o.length - 1]
                }
            }
        }, {
            key: "linearScale",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10
                  , a = arguments.length > 3 ? arguments[3] : void 0
                  , s = Math.abs(t - e);
                "dataPoints" === (i = this._adjustTicksForSmallRange(i, a, s)) && (i = this.w.globals.dataPoints - 1);
                var r = s / i;
                i === Number.MAX_VALUE && (i = 10,
                r = 1);
                for (var n = [], o = e; i >= 0; )
                    n.push(o),
                    o += r,
                    i -= 1;
                return {
                    result: n,
                    niceMin: n[0],
                    niceMax: n[n.length - 1]
                }
            }
        }, {
            key: "logarithmicScaleNice",
            value: function(e, t, i) {
                t <= 0 && (t = Math.max(e, i)),
                e <= 0 && (e = Math.min(t, i));
                for (var a = [], s = Math.ceil(Math.log(t) / Math.log(i) + 1), r = Math.floor(Math.log(e) / Math.log(i)); r < s; r++)
                    a.push(Math.pow(i, r));
                return {
                    result: a,
                    niceMin: a[0],
                    niceMax: a[a.length - 1]
                }
            }
        }, {
            key: "logarithmicScale",
            value: function(e, t, i) {
                t <= 0 && (t = Math.max(e, i)),
                e <= 0 && (e = Math.min(t, i));
                for (var a = [], s = Math.log(t) / Math.log(i), r = Math.log(e) / Math.log(i), n = s - r, o = Math.round(n), h = n / o, d = 0, u = r; d < o; d++,
                u += h)
                    a.push(Math.pow(i, u));
                return a.push(Math.pow(i, s)),
                {
                    result: a,
                    niceMin: e,
                    niceMax: t
                }
            }
        }, {
            key: "_adjustTicksForSmallRange",
            value: function(e, t, i) {
                var a = e;
                if (void 0 !== t && this.w.config.yaxis[t].labels.formatter && void 0 === this.w.config.yaxis[t].tickAmount) {
                    var s = Number(this.w.config.yaxis[t].labels.formatter(1));
                    D.isNumber(s) && 0 === this.w.globals.yValueDecimal && (a = Math.ceil(i))
                }
                return a < e ? a : e
            }
        }, {
            key: "setYScaleForIndex",
            value: function(e, t, i) {
                var a = this.w.globals
                  , s = this.w.config
                  , r = a.isBarHorizontal ? s.xaxis : s.yaxis[e];
                void 0 === a.yAxisScale[e] && (a.yAxisScale[e] = []);
                var n = Math.abs(i - t);
                r.logarithmic && n <= 5 && (a.invalidLogScale = !0),
                r.logarithmic && n > 5 ? (a.allSeriesCollapsed = !1,
                a.yAxisScale[e] = this.logarithmicScale(t, i, r.logBase),
                a.yAxisScale[e] = r.forceNiceScale ? this.logarithmicScaleNice(t, i, r.logBase) : this.logarithmicScale(t, i, r.logBase)) : i !== -Number.MAX_VALUE && D.isNumber(i) ? (a.allSeriesCollapsed = !1,
                a.yAxisScale[e] = void 0 === r.min && void 0 === r.max || r.forceNiceScale ? this.niceScale(t, i, r.tickAmount ? r.tickAmount : n < 5 && n > 1 ? n + 1 : 5, e, void 0 === s.yaxis[e].max && void 0 === s.yaxis[e].min || s.yaxis[e].forceNiceScale) : this.linearScale(t, i, r.tickAmount, e)) : a.yAxisScale[e] = this.linearScale(0, 5, 5)
            }
        }, {
            key: "setXScale",
            value: function(e, t) {
                var i = this.w
                  , a = i.globals
                  , s = i.config.xaxis
                  , r = Math.abs(t - e);
                return a.xAxisScale = t !== -Number.MAX_VALUE && D.isNumber(t) ? this.linearScale(e, t, s.tickAmount ? s.tickAmount : r < 5 && r > 1 ? r + 1 : 5, 0) : this.linearScale(0, 5, 5),
                a.xAxisScale
            }
        }, {
            key: "setMultipleYScales",
            value: function() {
                var e = this
                  , t = this.w.globals
                  , i = this.w.config
                  , a = t.minYArr.concat([])
                  , s = t.maxYArr.concat([])
                  , r = [];
                i.yaxis.forEach(function(n, o) {
                    var h = o;
                    i.series.forEach(function(p, x) {
                        p.name === n.seriesName && (h = x,
                        r.push(o !== x ? {
                            index: x,
                            similarIndex: o,
                            alreadyExists: !0
                        } : {
                            index: x
                        }))
                    }),
                    e.setYScaleForIndex(o, a[h], s[h])
                }),
                this.sameScaleInMultipleAxes(a, s, r)
            }
        }, {
            key: "sameScaleInMultipleAxes",
            value: function(e, t, i) {
                var a = this
                  , s = this.w.config
                  , r = this.w.globals
                  , n = [];
                i.forEach(function(k) {
                    k.alreadyExists && (void 0 === n[k.index] && (n[k.index] = []),
                    n[k.index].push(k.index),
                    n[k.index].push(k.similarIndex))
                }),
                r.yAxisSameScaleIndices = n,
                n.forEach(function(k, S) {
                    n.forEach(function(E, M) {
                        var l, f;
                        S !== M && (l = k,
                        f = E,
                        l.filter(function(w) {
                            return -1 !== f.indexOf(w)
                        })).length > 0 && (n[S] = n[S].concat(n[M]))
                    })
                });
                var o = n.map(function(k) {
                    return k.filter(function(S, E) {
                        return k.indexOf(S) === E
                    })
                }).map(function(k) {
                    return k.sort()
                });
                n = n.filter(function(k) {
                    return !!k
                });
                var h = o.slice()
                  , d = h.map(function(k) {
                    return JSON.stringify(k)
                });
                h = h.filter(function(k, S) {
                    return d.indexOf(JSON.stringify(k)) === S
                });
                var u = []
                  , p = [];
                e.forEach(function(k, S) {
                    h.forEach(function(E, M) {
                        E.indexOf(S) > -1 && (void 0 === u[M] && (u[M] = [],
                        p[M] = []),
                        u[M].push({
                            key: S,
                            value: k
                        }),
                        p[M].push({
                            key: S,
                            value: t[S]
                        }))
                    })
                });
                var x = Array.apply(null, Array(h.length)).map(Number.prototype.valueOf, Number.MIN_VALUE)
                  , b = Array.apply(null, Array(h.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                u.forEach(function(k, S) {
                    k.forEach(function(E, M) {
                        x[S] = Math.min(E.value, x[S])
                    })
                }),
                p.forEach(function(k, S) {
                    k.forEach(function(E, M) {
                        b[S] = Math.max(E.value, b[S])
                    })
                }),
                e.forEach(function(k, S) {
                    p.forEach(function(E, M) {
                        var l = x[M]
                          , f = b[M];
                        s.chart.stacked && (f = 0,
                        E.forEach(function(w, _) {
                            w.value !== -Number.MAX_VALUE && (f += w.value),
                            l !== Number.MIN_VALUE && (l += u[M][_].value)
                        })),
                        E.forEach(function(w, _) {
                            E[_].key === S && (void 0 !== s.yaxis[S].min && (l = "function" == typeof s.yaxis[S].min ? s.yaxis[S].min(r.minY) : s.yaxis[S].min),
                            void 0 !== s.yaxis[S].max && (f = "function" == typeof s.yaxis[S].max ? s.yaxis[S].max(r.maxY) : s.yaxis[S].max),
                            a.setYScaleForIndex(S, l, f))
                        })
                    })
                })
            }
        }, {
            key: "autoScaleY",
            value: function(e, t, i) {
                e || (e = this);
                var a = e.w;
                if (a.globals.isMultipleYAxis || a.globals.collapsedSeries.length)
                    return console.warn("autoScaleYaxis not supported in a multi-yaxis chart."),
                    t;
                var s = a.globals.seriesX[0]
                  , r = a.config.chart.stacked;
                return t.forEach(function(n, o) {
                    for (var h = 0, d = 0; d < s.length; d++)
                        if (s[d] >= i.xaxis.min) {
                            h = d;
                            break
                        }
                    var u, p, x = a.globals.minYArr[o], b = a.globals.maxYArr[o], k = a.globals.stackedSeriesTotals;
                    a.globals.series.forEach(function(S, E) {
                        var M = S[h];
                        r ? (u = p = M = k[h],
                        k.forEach(function(l, f) {
                            s[f] <= i.xaxis.max && s[f] >= i.xaxis.min && (l > p && null !== l && (p = l),
                            S[f] < u && null !== S[f] && (u = S[f]))
                        })) : (u = p = M,
                        S.forEach(function(l, f) {
                            if (s[f] <= i.xaxis.max && s[f] >= i.xaxis.min) {
                                var w = l
                                  , _ = l;
                                a.globals.series.forEach(function(R, H) {
                                    null !== l && (w = Math.min(R[f], w),
                                    _ = Math.max(R[f], _))
                                }),
                                _ > p && null !== _ && (p = _),
                                w < u && null !== w && (u = w)
                            }
                        })),
                        void 0 === u && void 0 === p && (u = x,
                        p = b),
                        p *= p < 0 ? .9 : 1.1,
                        0 == (u *= u < 0 ? 1.1 : .9) && 0 === p && (u = -1,
                        p = 1),
                        p < 0 && p < b && (p = b),
                        u < 0 && u > x && (u = x),
                        t.length > 1 ? (t[E].min = void 0 === n.min ? u : n.min,
                        t[E].max = void 0 === n.max ? p : n.max) : (t[0].min = void 0 === n.min ? u : n.min,
                        t[0].max = void 0 === n.max ? p : n.max)
                    })
                }),
                t
            }
        }]),
        C
    }()
      , Di = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.scales = new Jt(e)
        }
        return Te(C, [{
            key: "init",
            value: function() {
                this.setYRange(),
                this.setXRange(),
                this.setZRange()
            }
        }, {
            key: "getMinYMaxY",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , s = this.w.config
                  , r = this.w.globals
                  , n = -Number.MAX_VALUE
                  , o = Number.MIN_VALUE;
                null === a && (a = e + 1);
                var h = r.series
                  , d = h
                  , u = h;
                "candlestick" === s.chart.type ? (d = r.seriesCandleL,
                u = r.seriesCandleH) : "boxPlot" === s.chart.type ? (d = r.seriesCandleO,
                u = r.seriesCandleC) : r.isRangeData && (d = r.seriesRangeStart,
                u = r.seriesRangeEnd);
                for (var p = e; p < a; p++) {
                    r.dataPoints = Math.max(r.dataPoints, h[p].length),
                    r.categoryLabels.length && (r.dataPoints = r.categoryLabels.filter(function(k) {
                        return void 0 !== k
                    }).length),
                    r.labels.length && "datetime" !== s.xaxis.type && 0 !== r.series.reduce(function(k, S) {
                        return k + S.length
                    }, 0) && (r.dataPoints = Math.max(r.dataPoints, r.labels.length));
                    for (var x = 0; x < r.series[p].length; x++) {
                        var b = h[p][x];
                        null !== b && D.isNumber(b) ? (void 0 !== u[p][x] && (n = Math.max(n, u[p][x]),
                        t = Math.min(t, u[p][x])),
                        void 0 !== d[p][x] && (t = Math.min(t, d[p][x]),
                        i = Math.max(i, d[p][x])),
                        "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type && "rangeArea" === this.w.config.chart.type && "rangeBar" === this.w.config.chart.type || ("candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || void 0 !== r.seriesCandleC[p][x] && (n = Math.max(n, r.seriesCandleO[p][x]),
                        n = Math.max(n, r.seriesCandleH[p][x]),
                        n = Math.max(n, r.seriesCandleL[p][x]),
                        n = Math.max(n, r.seriesCandleC[p][x]),
                        "boxPlot" === this.w.config.chart.type && (n = Math.max(n, r.seriesCandleM[p][x]))),
                        !s.series[p].type || "candlestick" === s.series[p].type && "boxPlot" === s.series[p].type && "rangeArea" === s.series[p].type && "rangeBar" === s.series[p].type || (n = Math.max(n, r.series[p][x]),
                        t = Math.min(t, r.series[p][x])),
                        i = n),
                        r.seriesGoals[p] && r.seriesGoals[p][x] && Array.isArray(r.seriesGoals[p][x]) && r.seriesGoals[p][x].forEach(function(k) {
                            o !== Number.MIN_VALUE && (o = Math.min(o, k.value),
                            t = o),
                            n = Math.max(n, k.value),
                            i = n
                        }),
                        D.isFloat(b) && (b = D.noExponents(b),
                        r.yValueDecimal = Math.max(r.yValueDecimal, b.toString().split(".")[1].length)),
                        o > d[p][x] && d[p][x] < 0 && (o = d[p][x])) : r.hasNullValues = !0
                    }
                }
                return "rangeBar" === s.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && (o = t),
                "bar" === s.chart.type && (o < 0 && n < 0 && (n = 0),
                o === Number.MIN_VALUE && (o = 0)),
                {
                    minY: o,
                    maxY: n,
                    lowestY: t,
                    highestY: i
                }
            }
        }, {
            key: "setYRange",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                e.maxY = -Number.MAX_VALUE,
                e.minY = Number.MIN_VALUE;
                var i = Number.MAX_VALUE;
                if (e.isMultipleYAxis)
                    for (var a = 0; a < e.series.length; a++) {
                        var s = this.getMinYMaxY(a, i, null, a + 1);
                        e.minYArr.push(s.minY),
                        e.maxYArr.push(s.maxY),
                        i = s.lowestY
                    }
                var r = this.getMinYMaxY(0, i, null, e.series.length);
                if (e.minY = r.minY,
                e.maxY = r.maxY,
                i = r.lowestY,
                t.chart.stacked && this._setStackedMinMax(),
                ("line" === t.chart.type || "area" === t.chart.type || "candlestick" === t.chart.type || "boxPlot" === t.chart.type || "rangeBar" === t.chart.type && !e.isBarHorizontal) && e.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== e.maxY) {
                    var n = e.maxY - i;
                    (i >= 0 && i <= 10 || void 0 !== t.yaxis[0].min || void 0 !== t.yaxis[0].max) && (n = 0),
                    e.minY = i - 5 * n / 100,
                    i > 0 && e.minY < 0 && (e.minY = 0),
                    e.maxY = e.maxY + 5 * n / 100
                }
                return t.yaxis.forEach(function(o, h) {
                    void 0 !== o.max && ("number" == typeof o.max ? e.maxYArr[h] = o.max : "function" == typeof o.max && (e.maxYArr[h] = o.max(e.isMultipleYAxis ? e.maxYArr[h] : e.maxY)),
                    e.maxY = e.maxYArr[h]),
                    void 0 !== o.min && ("number" == typeof o.min ? e.minYArr[h] = o.min : "function" == typeof o.min && (e.minYArr[h] = o.min(e.isMultipleYAxis ? e.minYArr[h] === Number.MIN_VALUE ? 0 : e.minYArr[h] : e.minY)),
                    e.minY = e.minYArr[h])
                }),
                e.isBarHorizontal && ["min", "max"].forEach(function(o) {
                    void 0 !== t.xaxis[o] && "number" == typeof t.xaxis[o] && ("min" === o ? e.minY = t.xaxis[o] : e.maxY = t.xaxis[o])
                }),
                e.isMultipleYAxis ? (this.scales.setMultipleYScales(),
                e.minY = i,
                e.yAxisScale.forEach(function(o, h) {
                    e.minYArr[h] = o.niceMin,
                    e.maxYArr[h] = o.niceMax
                })) : (this.scales.setYScaleForIndex(0, e.minY, e.maxY),
                e.minY = e.yAxisScale[0].niceMin,
                e.maxY = e.yAxisScale[0].niceMax,
                e.minYArr[0] = e.yAxisScale[0].niceMin,
                e.maxYArr[0] = e.yAxisScale[0].niceMax),
                {
                    minY: e.minY,
                    maxY: e.maxY,
                    minYArr: e.minYArr,
                    maxYArr: e.maxYArr,
                    yAxisScale: e.yAxisScale
                }
            }
        }, {
            key: "setXRange",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config
                  , i = "numeric" === t.xaxis.type || "datetime" === t.xaxis.type || "category" === t.xaxis.type && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
                if (e.isXNumeric && function() {
                    for (var n = 0; n < e.series.length; n++)
                        if (e.labels[n])
                            for (var o = 0; o < e.labels[n].length; o++)
                                null !== e.labels[n][o] && D.isNumber(e.labels[n][o]) && (e.maxX = Math.max(e.maxX, e.labels[n][o]),
                                e.initialMaxX = Math.max(e.maxX, e.labels[n][o]),
                                e.minX = Math.min(e.minX, e.labels[n][o]),
                                e.initialMinX = Math.min(e.minX, e.labels[n][o]))
                }(),
                e.noLabelsProvided && 0 === t.xaxis.categories.length && (e.maxX = e.labels[e.labels.length - 1],
                e.initialMaxX = e.labels[e.labels.length - 1],
                e.minX = 1,
                e.initialMinX = 1),
                e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
                    var a;
                    if (void 0 === t.xaxis.tickAmount ? (a = Math.round(e.svgWidth / 150),
                    "numeric" === t.xaxis.type && e.dataPoints < 30 && (a = e.dataPoints - 1),
                    a > e.dataPoints && 0 !== e.dataPoints && (a = e.dataPoints - 1)) : "dataPoints" === t.xaxis.tickAmount ? (e.series.length > 1 && (a = e.series[e.maxValsInArrayIndex].length - 1),
                    e.isXNumeric && (a = e.maxX - e.minX - 1)) : a = t.xaxis.tickAmount,
                    e.xTickAmount = a,
                    void 0 !== t.xaxis.max && "number" == typeof t.xaxis.max && (e.maxX = t.xaxis.max),
                    void 0 !== t.xaxis.min && "number" == typeof t.xaxis.min && (e.minX = t.xaxis.min),
                    void 0 !== t.xaxis.range && (e.minX = e.maxX - t.xaxis.range),
                    e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE)
                        if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
                            for (var s = [], r = e.minX - 1; r < e.maxX; r++)
                                s.push(r + 1);
                            e.xAxisScale = {
                                result: s,
                                niceMin: s[0],
                                niceMax: s[s.length - 1]
                            }
                        } else
                            e.xAxisScale = this.scales.setXScale(e.minX, e.maxX);
                    else
                        e.xAxisScale = this.scales.linearScale(0, a, a),
                        e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, a - 1),
                        e.seriesX = e.labels.slice());
                    i && (e.labels = e.xAxisScale.result.slice())
                }
                return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length),
                this._handleSingleDataPoint(),
                this._getMinXDiff(),
                {
                    minX: e.minX,
                    maxX: e.maxX
                }
            }
        }, {
            key: "setZRange",
            value: function() {
                var e = this.w.globals;
                if (e.isDataXYZ)
                    for (var t = 0; t < e.series.length; t++)
                        if (void 0 !== e.seriesZ[t])
                            for (var i = 0; i < e.seriesZ[t].length; i++)
                                null !== e.seriesZ[t][i] && D.isNumber(e.seriesZ[t][i]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][i]),
                                e.minZ = Math.min(e.minZ, e.seriesZ[t][i]))
            }
        }, {
            key: "_handleSingleDataPoint",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                if (e.minX === e.maxX) {
                    var i = new We(this.ctx);
                    if ("datetime" === t.xaxis.type) {
                        var a = i.getDate(e.minX);
                        t.xaxis.labels.datetimeUTC ? a.setUTCDate(a.getUTCDate() - 2) : a.setDate(a.getDate() - 2),
                        e.minX = new Date(a).getTime();
                        var s = i.getDate(e.maxX);
                        t.xaxis.labels.datetimeUTC ? s.setUTCDate(s.getUTCDate() + 2) : s.setDate(s.getDate() + 2),
                        e.maxX = new Date(s).getTime()
                    } else
                        ("numeric" === t.xaxis.type || "category" === t.xaxis.type && !e.noLabelsProvided) && (e.minX = e.minX - 2,
                        e.initialMinX = e.minX,
                        e.maxX = e.maxX + 2,
                        e.initialMaxX = e.maxX)
                }
            }
        }, {
            key: "_getMinXDiff",
            value: function() {
                var e = this.w.globals;
                e.isXNumeric && e.seriesX.forEach(function(t, i) {
                    1 === t.length && t.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]);
                    var a = t.slice();
                    a.sort(function(s, r) {
                        return s - r
                    }),
                    a.forEach(function(s, r) {
                        if (r > 0) {
                            var n = s - a[r - 1];
                            n > 0 && (e.minXDiff = Math.min(n, e.minXDiff))
                        }
                    }),
                    1 !== e.dataPoints && e.minXDiff !== Number.MAX_VALUE || (e.minXDiff = .5)
                })
            }
        }, {
            key: "_setStackedMinMax",
            value: function() {
                var e = this
                  , t = this.w.globals;
                if (t.series.length) {
                    var i = t.seriesGroups;
                    i.length || (i = [this.w.config.series.map(function(r) {
                        return r.name
                    })]);
                    var a = {}
                      , s = {};
                    i.forEach(function(r) {
                        a[r] = [],
                        s[r] = [],
                        e.w.config.series.map(function(n, o) {
                            return r.indexOf(n.name) > -1 ? o : null
                        }).filter(function(n) {
                            return null !== n
                        }).forEach(function(n) {
                            for (var o = 0; o < t.series[t.maxValsInArrayIndex].length; o++)
                                void 0 === a[r][o] && (a[r][o] = 0,
                                s[r][o] = 0),
                                null !== t.series[n][o] && D.isNumber(t.series[n][o]) && (t.series[n][o] > 0 ? a[r][o] += parseFloat(t.series[n][o]) + 1e-4 : s[r][o] += parseFloat(t.series[n][o]))
                        })
                    }),
                    Object.entries(a).forEach(function(r) {
                        var n = F(r, 1)[0];
                        a[n].forEach(function(o, h) {
                            t.maxY = Math.max(t.maxY, a[n][h]),
                            t.minY = Math.min(t.minY, s[n][h])
                        })
                    })
                }
            }
        }]),
        C
    }()
      , ia = function() {
        function C(e, t) {
            Q(this, C),
            this.ctx = e,
            this.elgrid = t,
            this.w = e.w;
            var i = this.w;
            this.xaxisFontSize = i.config.xaxis.labels.style.fontSize,
            this.axisFontFamily = i.config.xaxis.labels.style.fontFamily,
            this.xaxisForeColors = i.config.xaxis.labels.style.colors,
            this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal,
            this.xAxisoffX = 0,
            "bottom" === i.config.xaxis.position && (this.xAxisoffX = i.globals.gridHeight),
            this.drawnLabels = [],
            this.axesUtils = new Mt(e)
        }
        return Te(C, [{
            key: "drawYaxis",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = new U(this.ctx)
                  , s = i.config.yaxis[e].labels.style
                  , r = s.fontSize
                  , n = s.fontFamily
                  , o = s.fontWeight
                  , h = a.group({
                    class: "apexcharts-yaxis",
                    rel: e,
                    transform: "translate(" + i.globals.translateYAxisX[e] + ", 0)"
                });
                if (this.axesUtils.isYAxisHidden(e))
                    return h;
                var d = a.group({
                    class: "apexcharts-yaxis-texts-g"
                });
                h.add(d);
                var u = i.globals.yAxisScale[e].result.length - 1
                  , p = i.globals.gridHeight / u
                  , x = i.globals.translateY
                  , b = i.globals.yLabelFormatters[e]
                  , k = i.globals.yAxisScale[e].result.slice();
                k = this.axesUtils.checkForReversedLabels(e, k);
                var S = "";
                if (i.config.yaxis[e].labels.show)
                    for (var E = function(B) {
                        var j = k[B];
                        j = b(j, B, i);
                        var ce = i.config.yaxis[e].labels.padding;
                        i.config.yaxis[e].opposite && 0 !== i.config.yaxis.length && (ce *= -1);
                        var me = "end";
                        i.config.yaxis[e].opposite && (me = "start"),
                        "left" === i.config.yaxis[e].labels.align ? me = "start" : "center" === i.config.yaxis[e].labels.align ? me = "middle" : "right" === i.config.yaxis[e].labels.align && (me = "end");
                        var ue = t.axesUtils.getYAxisForeColor(s.colors, e)
                          , Ee = i.config.yaxis[e].labels.offsetY;
                        "heatmap" === i.config.chart.type && (Ee -= (i.globals.gridHeight / i.globals.series.length - 1) / 2);
                        var Ie = a.drawText({
                            x: ce,
                            y: x + u / 10 + Ee + 1,
                            text: j,
                            textAnchor: me,
                            fontSize: r,
                            fontFamily: n,
                            fontWeight: o,
                            maxWidth: i.config.yaxis[e].labels.maxWidth,
                            foreColor: Array.isArray(ue) ? ue[B] : ue,
                            isPlainText: !1,
                            cssClass: "apexcharts-yaxis-label " + s.cssClass
                        });
                        B === u && (S = Ie),
                        d.add(Ie);
                        var rt = document.createElementNS(i.globals.SVGNS, "title");
                        if (rt.textContent = Array.isArray(j) ? j.join(" ") : j,
                        Ie.node.appendChild(rt),
                        0 !== i.config.yaxis[e].labels.rotate) {
                            var nt = a.rotateAroundCenter(S.node)
                              , ht = a.rotateAroundCenter(Ie.node);
                            Ie.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[e].labels.rotate, " ").concat(nt.x, " ").concat(ht.y, ")"))
                        }
                        x += p
                    }, M = u; M >= 0; M--)
                        E(M);
                if (void 0 !== i.config.yaxis[e].title.text) {
                    var l = a.group({
                        class: "apexcharts-yaxis-title"
                    })
                      , f = 0;
                    i.config.yaxis[e].opposite && (f = i.globals.translateYAxisX[e]);
                    var w = a.drawText({
                        x: f,
                        y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[e].title.offsetY,
                        text: i.config.yaxis[e].title.text,
                        textAnchor: "end",
                        foreColor: i.config.yaxis[e].title.style.color,
                        fontSize: i.config.yaxis[e].title.style.fontSize,
                        fontWeight: i.config.yaxis[e].title.style.fontWeight,
                        fontFamily: i.config.yaxis[e].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[e].title.style.cssClass
                    });
                    l.add(w),
                    h.add(l)
                }
                var _ = i.config.yaxis[e].axisBorder
                  , R = 31 + _.offsetX;
                if (i.config.yaxis[e].opposite && (R = -31 - _.offsetX),
                _.show) {
                    var H = a.drawLine(R, i.globals.translateY + _.offsetY - 2, R, i.globals.gridHeight + i.globals.translateY + _.offsetY + 2, _.color, 0, _.width);
                    h.add(H)
                }
                return i.config.yaxis[e].axisTicks.show && this.axesUtils.drawYAxisTicks(R, u, _, i.config.yaxis[e].axisTicks, e, p, h),
                h
            }
        }, {
            key: "drawYaxisInversed",
            value: function(e) {
                var t = this.w
                  , i = new U(this.ctx)
                  , a = i.group({
                    class: "apexcharts-xaxis apexcharts-yaxis-inversed"
                })
                  , s = i.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")")
                });
                a.add(s);
                var r = t.globals.yAxisScale[e].result.length - 1
                  , n = t.globals.gridWidth / r + .1
                  , o = n + t.config.xaxis.labels.offsetX
                  , h = t.globals.xLabelFormatter
                  , d = t.globals.yAxisScale[e].result.slice()
                  , u = t.globals.timescaleLabels;
                u.length > 0 && (this.xaxisLabels = u.slice(),
                r = (d = u.slice()).length),
                d = this.axesUtils.checkForReversedLabels(e, d);
                var p = u.length;
                if (t.config.xaxis.labels.show)
                    for (var x = p ? 0 : r; p ? x < p : x >= 0; p ? x++ : x--) {
                        var b = d[x];
                        b = h(b, x, t);
                        var k = t.globals.gridWidth + t.globals.padHorizontal - (o - n + t.config.xaxis.labels.offsetX);
                        if (u.length) {
                            var S = this.axesUtils.getLabel(d, u, k, x, this.drawnLabels, this.xaxisFontSize);
                            k = S.x,
                            b = S.text,
                            this.drawnLabels.push(S.text),
                            0 === x && t.globals.skipFirstTimelinelabel && (b = ""),
                            x === d.length - 1 && t.globals.skipLastTimelinelabel && (b = "")
                        }
                        var E = i.drawText({
                            x: k,
                            y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - ("top" === t.config.xaxis.position ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0),
                            text: b,
                            textAnchor: "middle",
                            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors,
                            fontSize: this.xaxisFontSize,
                            fontFamily: this.xaxisFontFamily,
                            fontWeight: t.config.xaxis.labels.style.fontWeight,
                            isPlainText: !1,
                            cssClass: "apexcharts-xaxis-label " + t.config.xaxis.labels.style.cssClass
                        });
                        s.add(E),
                        E.tspan(b);
                        var M = document.createElementNS(t.globals.SVGNS, "title");
                        M.textContent = b,
                        E.node.appendChild(M),
                        o += n
                    }
                return this.inversedYAxisTitleText(a),
                this.inversedYAxisBorder(a),
                a
            }
        }, {
            key: "inversedYAxisBorder",
            value: function(e) {
                var t = this.w
                  , i = new U(this.ctx)
                  , a = t.config.xaxis.axisBorder;
                if (a.show) {
                    var s = 0;
                    "bar" === t.config.chart.type && t.globals.isXNumeric && (s -= 15);
                    var r = i.drawLine(t.globals.padHorizontal + s + a.offsetX, this.xAxisoffX, t.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height);
                    this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(r) : e.add(r)
                }
            }
        }, {
            key: "inversedYAxisTitleText",
            value: function(e) {
                var t = this.w
                  , i = new U(this.ctx);
                if (void 0 !== t.config.xaxis.title.text) {
                    var a = i.group({
                        class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
                    })
                      , s = i.drawText({
                        x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX,
                        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t.config.xaxis.title.style.fontSize) + t.config.xaxis.title.offsetY + 20,
                        text: t.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: t.config.xaxis.title.style.fontSize,
                        fontFamily: t.config.xaxis.title.style.fontFamily,
                        fontWeight: t.config.xaxis.title.style.fontWeight,
                        foreColor: t.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass
                    });
                    a.add(s),
                    e.add(a)
                }
            }
        }, {
            key: "yAxisTitleRotate",
            value: function(e, t) {
                var i = this.w
                  , a = new U(this.ctx)
                  , s = {
                    width: 0,
                    height: 0
                }
                  , r = {
                    width: 0,
                    height: 0
                }
                  , n = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-texts-g"));
                null !== n && (s = n.getBoundingClientRect());
                var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-title text"));
                if (null !== o && (r = o.getBoundingClientRect()),
                null !== o) {
                    var h = this.xPaddingForYAxisTitle(e, s, r, t);
                    o.setAttribute("x", h.xPos - (t ? 10 : 0))
                }
                if (null !== o) {
                    var d = a.rotateAroundCenter(o);
                    o.setAttribute("transform", "rotate(".concat(t ? -1 * i.config.yaxis[e].title.rotate : i.config.yaxis[e].title.rotate, " ").concat(d.x, " ").concat(d.y, ")"))
                }
            }
        }, {
            key: "xPaddingForYAxisTitle",
            value: function(e, t, i, a) {
                var s = this.w
                  , r = 0
                  , n = 0
                  , o = 10;
                return void 0 === s.config.yaxis[e].title.text || e < 0 ? {
                    xPos: n,
                    padd: 0
                } : (a ? (n = t.width + s.config.yaxis[e].title.offsetX + i.width / 2 + o / 2,
                0 === (r += 1) && (n -= o / 2)) : (n = -1 * t.width + s.config.yaxis[e].title.offsetX + o / 2 + i.width / 2,
                s.globals.isBarHorizontal && (n = -1 * t.width - s.config.yaxis[e].title.offsetX - (o = 25))),
                {
                    xPos: n,
                    padd: o
                })
            }
        }, {
            key: "setYAxisXPosition",
            value: function(e, t) {
                var i = this.w
                  , a = 0
                  , s = 0
                  , r = 18
                  , n = 1;
                i.config.yaxis.length > 1 && (this.multipleYs = !0),
                i.config.yaxis.map(function(o, h) {
                    var d = i.globals.ignoreYAxisIndexes.indexOf(h) > -1 || !o.show || o.floating || 0 === e[h].width
                      , u = e[h].width + t[h].width;
                    o.opposite ? i.globals.isBarHorizontal ? i.globals.translateYAxisX[h] = (s = i.globals.gridWidth + i.globals.translateX - 1) - o.labels.offsetX : (s = i.globals.gridWidth + i.globals.translateX + n,
                    d || (n = n + u + 20),
                    i.globals.translateYAxisX[h] = s - o.labels.offsetX + 20) : (a = i.globals.translateX - r,
                    d || (r = r + u + 20),
                    i.globals.translateYAxisX[h] = a + o.labels.offsetX)
                })
            }
        }, {
            key: "setYAxisTextAlignments",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                (t = D.listToArray(t)).forEach(function(i, a) {
                    var s = e.config.yaxis[a];
                    if (s && !s.floating && void 0 !== s.labels.align) {
                        var r = e.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(a, "'] .apexcharts-yaxis-texts-g"))
                          , n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(a, "'] .apexcharts-yaxis-label"));
                        n = D.listToArray(n);
                        var o = r.getBoundingClientRect();
                        "left" === s.labels.align ? (n.forEach(function(h, d) {
                            h.setAttribute("text-anchor", "start")
                        }),
                        s.opposite || r.setAttribute("transform", "translate(-".concat(o.width, ", 0)"))) : "center" === s.labels.align ? (n.forEach(function(h, d) {
                            h.setAttribute("text-anchor", "middle")
                        }),
                        r.setAttribute("transform", "translate(".concat(o.width / 2 * (s.opposite ? 1 : -1), ", 0)"))) : "right" === s.labels.align && (n.forEach(function(h, d) {
                            h.setAttribute("text-anchor", "end")
                        }),
                        s.opposite && r.setAttribute("transform", "translate(".concat(o.width, ", 0)")))
                    }
                })
            }
        }]),
        C
    }()
      , aa = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.documentEvent = D.bind(this.documentEvent, this)
        }
        return Te(C, [{
            key: "addEventListener",
            value: function(e, t) {
                var i = this.w;
                i.globals.events.hasOwnProperty(e) ? i.globals.events[e].push(t) : i.globals.events[e] = [t]
            }
        }, {
            key: "removeEventListener",
            value: function(e, t) {
                var i = this.w;
                if (i.globals.events.hasOwnProperty(e)) {
                    var a = i.globals.events[e].indexOf(t);
                    -1 !== a && i.globals.events[e].splice(a, 1)
                }
            }
        }, {
            key: "fireEvent",
            value: function(e, t) {
                var i = this.w;
                if (i.globals.events.hasOwnProperty(e)) {
                    t && t.length || (t = []);
                    for (var a = i.globals.events[e], s = a.length, r = 0; r < s; r++)
                        a[r].apply(null, t)
                }
            }
        }, {
            key: "setupEventHandlers",
            value: function() {
                var e = this
                  , t = this.w
                  , i = this.ctx
                  , a = t.globals.dom.baseEl.querySelector(t.globals.chartClass);
                this.ctx.eventList.forEach(function(s) {
                    a.addEventListener(s, function(r) {
                        var n = Object.assign({}, t, {
                            seriesIndex: t.globals.capturedSeriesIndex,
                            dataPointIndex: t.globals.capturedDataPointIndex
                        });
                        "mousemove" === r.type || "touchmove" === r.type ? "function" == typeof t.config.chart.events.mouseMove && t.config.chart.events.mouseMove(r, i, n) : "mouseleave" === r.type || "touchleave" === r.type ? "function" == typeof t.config.chart.events.mouseLeave && t.config.chart.events.mouseLeave(r, i, n) : ("mouseup" === r.type && 1 === r.which || "touchend" === r.type) && ("function" == typeof t.config.chart.events.click && t.config.chart.events.click(r, i, n),
                        i.ctx.events.fireEvent("click", [r, i, n]))
                    }, {
                        capture: !1,
                        passive: !0
                    })
                }),
                this.ctx.eventList.forEach(function(s) {
                    t.globals.dom.baseEl.addEventListener(s, e.documentEvent, {
                        passive: !0
                    })
                }),
                this.ctx.core.setupBrushHandler()
            }
        }, {
            key: "documentEvent",
            value: function(e) {
                var t = this.w
                  , i = e.target.className;
                if ("click" === e.type) {
                    var a = t.globals.dom.baseEl.querySelector(".apexcharts-menu");
                    a && a.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && a.classList.remove("apexcharts-menu-open")
                }
                t.globals.clientX = "touchmove" === e.type ? e.touches[0].clientX : e.clientX,
                t.globals.clientY = "touchmove" === e.type ? e.touches[0].clientY : e.clientY
            }
        }]),
        C
    }()
      , Ai = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "setCurrentLocaleValues",
            value: function(e) {
                var t = this.w.config.chart.locales;
                window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                var i = t.filter(function(s) {
                    return s.name === e
                })[0];
                if (!i)
                    throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                var a = D.extend(gt, i);
                this.w.globals.locale = a.options
            }
        }]),
        C
    }()
      , ni = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "drawAxis",
            value: function(e, t) {
                var i, a, s = this, r = this.w.globals, n = this.w.config, o = new Ot(this.ctx,t), h = new ia(this.ctx,t);
                r.axisCharts && "radar" !== e && (r.isBarHorizontal ? (a = h.drawYaxisInversed(0),
                i = o.drawXaxisInversed(0),
                r.dom.elGraphical.add(i),
                r.dom.elGraphical.add(a)) : (i = o.drawXaxis(),
                r.dom.elGraphical.add(i),
                n.yaxis.map(function(d, u) {
                    if (-1 === r.ignoreYAxisIndexes.indexOf(u) && (a = h.drawYaxis(u),
                    r.dom.Paper.add(a),
                    "back" === s.w.config.grid.position)) {
                        var p = r.dom.Paper.children()[1];
                        p.remove(),
                        r.dom.Paper.add(p)
                    }
                })))
            }
        }]),
        C
    }()
      , fi = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "drawXCrosshairs",
            value: function() {
                var e = this.w
                  , t = new U(this.ctx)
                  , i = new _e(this.ctx)
                  , a = e.config.xaxis.crosshairs.fill.gradient
                  , s = e.config.xaxis.crosshairs.dropShadow
                  , p = s.enabled
                  , x = s.left
                  , b = s.top
                  , k = s.blur
                  , S = s.color
                  , E = s.opacity
                  , M = e.config.xaxis.crosshairs.fill.color;
                if (e.config.xaxis.crosshairs.show) {
                    "gradient" === e.config.xaxis.crosshairs.fill.type && (M = t.drawGradient("vertical", a.colorFrom, a.colorTo, a.opacityFrom, a.opacityTo, null, a.stops, null));
                    var l = t.drawRect();
                    1 === e.config.xaxis.crosshairs.width && (l = t.drawLine());
                    var f = e.globals.gridHeight;
                    (!D.isNumber(f) || f < 0) && (f = 0);
                    var w = e.config.xaxis.crosshairs.width;
                    (!D.isNumber(w) || w < 0) && (w = 0),
                    l.attr({
                        class: "apexcharts-xcrosshairs",
                        x: 0,
                        y: 0,
                        y2: f,
                        width: w,
                        height: f,
                        fill: M,
                        filter: "none",
                        "fill-opacity": e.config.xaxis.crosshairs.opacity,
                        stroke: e.config.xaxis.crosshairs.stroke.color,
                        "stroke-width": e.config.xaxis.crosshairs.stroke.width,
                        "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray
                    }),
                    p && (l = i.dropShadow(l, {
                        left: x,
                        top: b,
                        blur: k,
                        color: S,
                        opacity: E
                    })),
                    e.globals.dom.elGraphical.add(l)
                }
            }
        }, {
            key: "drawYCrosshairs",
            value: function() {
                var e = this.w
                  , t = new U(this.ctx)
                  , i = e.config.yaxis[0].crosshairs
                  , a = e.globals.barPadForNumericAxis;
                if (e.config.yaxis[0].crosshairs.show) {
                    var s = t.drawLine(-a, 0, e.globals.gridWidth + a, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
                    s.attr({
                        class: "apexcharts-ycrosshairs"
                    }),
                    e.globals.dom.elGraphical.add(s)
                }
                var r = t.drawLine(-a, 0, e.globals.gridWidth + a, 0, i.stroke.color, 0, 0);
                r.attr({
                    class: "apexcharts-ycrosshairs-hidden"
                }),
                e.globals.dom.elGraphical.add(r)
            }
        }]),
        C
    }()
      , _i = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "checkResponsiveConfig",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = i.config;
                if (0 !== a.responsive.length) {
                    var s = a.responsive.slice();
                    s.sort(function(h, d) {
                        return h.breakpoint > d.breakpoint ? 1 : d.breakpoint > h.breakpoint ? -1 : 0
                    }).reverse();
                    var r = new St({})
                      , n = function() {
                        var h = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                          , d = s[0].breakpoint
                          , u = window.innerWidth > 0 ? window.innerWidth : screen.width;
                        if (u > d) {
                            var p = ae.extendArrayProps(r, i.globals.initialConfig, i);
                            h = D.extend(p, h),
                            h = D.extend(i.config, h),
                            t.overrideResponsiveOptions(h)
                        } else
                            for (var x = 0; x < s.length; x++)
                                u < s[x].breakpoint && (h = ae.extendArrayProps(r, s[x].options, i),
                                h = D.extend(i.config, h),
                                t.overrideResponsiveOptions(h))
                    };
                    if (e) {
                        var o = ae.extendArrayProps(r, e, i);
                        o = D.extend(i.config, o),
                        n(o = D.extend(o, e))
                    } else
                        n({})
                }
            }
        }, {
            key: "overrideResponsiveOptions",
            value: function(e) {
                var t = new St(e).init({
                    responsiveOverride: !0
                });
                this.w.config = t
            }
        }]),
        C
    }()
      , pi = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.colors = [],
            this.w = e.w;
            var t = this.w;
            this.isColorFn = !1,
            this.isHeatmapDistributed = "treemap" === t.config.chart.type && t.config.plotOptions.treemap.distributed || "heatmap" === t.config.chart.type && t.config.plotOptions.heatmap.distributed,
            this.isBarDistributed = t.config.plotOptions.bar.distributed && ("bar" === t.config.chart.type || "rangeBar" === t.config.chart.type)
        }
        return Te(C, [{
            key: "init",
            value: function() {
                this.setDefaultColors()
            }
        }, {
            key: "setDefaultColors",
            value: function() {
                var e, t = this, i = this.w, a = new D;
                if (i.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i.config.theme.mode)),
                void 0 === i.config.colors || 0 === (null === (e = i.config.colors) || void 0 === e ? void 0 : e.length) ? i.globals.colors = this.predefined() : (i.globals.colors = i.config.colors,
                Array.isArray(i.config.colors) && i.config.colors.length > 0 && "function" == typeof i.config.colors[0] && (i.globals.colors = i.config.series.map(function(b, k) {
                    var S = i.config.colors[k];
                    return S || (S = i.config.colors[0]),
                    "function" == typeof S ? (t.isColorFn = !0,
                    S({
                        value: i.globals.axisCharts ? i.globals.series[k][0] ? i.globals.series[k][0] : 0 : i.globals.series[k],
                        seriesIndex: k,
                        dataPointIndex: k,
                        w: i
                    })) : S
                }))),
                i.globals.seriesColors.map(function(b, k) {
                    b && (i.globals.colors[k] = b)
                }),
                i.config.theme.monochrome.enabled) {
                    var s = []
                      , r = i.globals.series.length;
                    (this.isBarDistributed || this.isHeatmapDistributed) && (r = i.globals.series[0].length * i.globals.series.length);
                    for (var n = i.config.theme.monochrome.color, o = 1 / (r / i.config.theme.monochrome.shadeIntensity), h = i.config.theme.monochrome.shadeTo, d = 0, u = 0; u < r; u++) {
                        var p = void 0;
                        "dark" === h ? (p = a.shadeColor(-1 * d, n),
                        d += o) : (p = a.shadeColor(d, n),
                        d += o),
                        s.push(p)
                    }
                    i.globals.colors = s.slice()
                }
                var x = i.globals.colors.slice();
                this.pushExtraColors(i.globals.colors),
                ["fill", "stroke"].forEach(function(b) {
                    i.globals[b].colors = void 0 === i.config[b].colors ? t.isColorFn ? i.config.colors : x : i.config[b].colors.slice(),
                    t.pushExtraColors(i.globals[b].colors)
                }),
                i.globals.dataLabels.style.colors = void 0 === i.config.dataLabels.style.colors ? x : i.config.dataLabels.style.colors.slice(),
                this.pushExtraColors(i.globals.dataLabels.style.colors, 50),
                i.globals.radarPolygons.fill.colors = void 0 === i.config.plotOptions.radar.polygons.fill.colors ? ["dark" === i.config.theme.mode ? "#424242" : "none"] : i.config.plotOptions.radar.polygons.fill.colors.slice(),
                this.pushExtraColors(i.globals.radarPolygons.fill.colors, 20),
                i.globals.markers.colors = void 0 === i.config.markers.colors ? x : i.config.markers.colors.slice(),
                this.pushExtraColors(i.globals.markers.colors)
            }
        }, {
            key: "pushExtraColors",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , a = this.w
                  , s = t || a.globals.series.length;
                if (null === i && (i = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a.config.chart.type && a.config.plotOptions.heatmap.colorScale.inverse),
                i && a.globals.series.length && (s = a.globals.series[a.globals.maxValsInArrayIndex].length * a.globals.series.length),
                e.length < s)
                    for (var r = s - e.length, n = 0; n < r; n++)
                        e.push(e[n])
            }
        }, {
            key: "updateThemeOptions",
            value: function(e) {
                e.chart = e.chart || {},
                e.tooltip = e.tooltip || {};
                var t = e.theme.mode || "light"
                  , i = e.theme.palette ? e.theme.palette : "dark" === t ? "palette4" : "palette1"
                  , a = e.chart.foreColor ? e.chart.foreColor : "dark" === t ? "#f6f7f8" : "#373d3f";
                return e.tooltip.theme = t,
                e.chart.foreColor = a,
                e.theme.palette = i,
                e
            }
        }, {
            key: "predefined",
            value: function() {
                switch (this.w.config.theme.palette) {
                case "palette1":
                default:
                    this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                    break;
                case "palette2":
                    this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                    break;
                case "palette3":
                    this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                    break;
                case "palette4":
                    this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                    break;
                case "palette5":
                    this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                    break;
                case "palette6":
                    this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                    break;
                case "palette7":
                    this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                    break;
                case "palette8":
                    this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                    break;
                case "palette9":
                    this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                    break;
                case "palette10":
                    this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"]
                }
                return this.colors
            }
        }]),
        C
    }()
      , Gt = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "draw",
            value: function() {
                this.drawTitleSubtitle("title"),
                this.drawTitleSubtitle("subtitle")
            }
        }, {
            key: "drawTitleSubtitle",
            value: function(e) {
                var t = this.w
                  , i = "title" === e ? t.config.title : t.config.subtitle
                  , a = t.globals.svgWidth / 2
                  , s = i.offsetY
                  , r = "middle";
                if ("left" === i.align ? (a = 10,
                r = "start") : "right" === i.align && (a = t.globals.svgWidth - 10,
                r = "end"),
                a += i.offsetX,
                s = s + parseInt(i.style.fontSize, 10) + i.margin / 2,
                void 0 !== i.text) {
                    var n = new U(this.ctx).drawText({
                        x: a,
                        y: s,
                        text: i.text,
                        textAnchor: r,
                        fontSize: i.style.fontSize,
                        fontFamily: i.style.fontFamily,
                        fontWeight: i.style.fontWeight,
                        foreColor: i.style.color,
                        opacity: 1
                    });
                    n.node.setAttribute("class", "apexcharts-".concat(e, "-text")),
                    t.globals.dom.Paper.add(n)
                }
            }
        }]),
        C
    }()
      , Bi = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.dCtx = e
        }
        return Te(C, [{
            key: "getTitleSubtitleCoords",
            value: function(e) {
                var t = this.w
                  , i = 0
                  , a = 0
                  , s = "title" === e ? t.config.title.floating : t.config.subtitle.floating
                  , r = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(e, "-text"));
                if (null !== r && !s) {
                    var n = r.getBoundingClientRect();
                    i = n.width,
                    a = t.globals.axisCharts ? n.height + 5 : n.height
                }
                return {
                    width: i,
                    height: a
                }
            }
        }, {
            key: "getLegendsRect",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.elLegendWrap;
                e.config.legend.height || "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || (t.style.maxHeight = e.globals.svgHeight / 2 + "px");
                var i = Object.assign({}, D.getBoundingClientRect(t));
                return this.dCtx.lgRect = null !== t && !e.config.legend.floating && e.config.legend.show ? {
                    x: i.x,
                    y: i.y,
                    height: i.height,
                    width: 0 === i.height ? 0 : i.width
                } : {
                    x: 0,
                    y: 0,
                    height: 0,
                    width: 0
                },
                "left" !== e.config.legend.position && "right" !== e.config.legend.position || 1.5 * this.dCtx.lgRect.width > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5),
                this.dCtx.lgRect
            }
        }, {
            key: "getLargestStringFromMultiArr",
            value: function(e, t) {
                var i = e;
                if (this.w.globals.isMultiLineX) {
                    var a = t.map(function(r, n) {
                        return Array.isArray(r) ? r.length : 1
                    })
                      , s = Math.max.apply(Math, J(a));
                    i = t[a.indexOf(s)]
                }
                return i
            }
        }]),
        C
    }()
      , ji = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.dCtx = e
        }
        return Te(C, [{
            key: "getxAxisLabelsCoords",
            value: function() {
                var e, t = this.w, i = t.globals.labels.slice();
                if (t.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = t.globals.categoryLabels),
                t.globals.timescaleLabels.length > 0) {
                    var a = this.getxAxisTimeScaleLabelsCoords();
                    e = {
                        width: a.width,
                        height: a.height
                    },
                    t.globals.rotateXLabels = !1
                } else {
                    this.dCtx.lgWidthForSideLegends = "left" !== t.config.legend.position && "right" !== t.config.legend.position || t.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                    var s = t.globals.xLabelFormatter
                      , r = D.getLargestStringFromArr(i)
                      , n = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, i);
                    t.globals.isBarHorizontal && (n = r = t.globals.yAxisScale[0].result.reduce(function(b, k) {
                        return b.length > k.length ? b : k
                    }, 0));
                    var o = new At(this.dCtx.ctx)
                      , h = r;
                    r = o.xLabelFormat(s, r, h, {
                        i: void 0,
                        dateFormatter: new We(this.dCtx.ctx).formatDate,
                        w: t
                    }),
                    n = o.xLabelFormat(s, n, h, {
                        i: void 0,
                        dateFormatter: new We(this.dCtx.ctx).formatDate,
                        w: t
                    }),
                    (t.config.xaxis.convertedCatToNumeric && void 0 === r || "" === String(r).trim()) && (n = r = "1");
                    var d = new U(this.dCtx.ctx)
                      , u = d.getTextRects(r, t.config.xaxis.labels.style.fontSize)
                      , p = u;
                    if (r !== n && (p = d.getTextRects(n, t.config.xaxis.labels.style.fontSize)),
                    (e = {
                        width: u.width >= p.width ? u.width : p.width,
                        height: u.height >= p.height ? u.height : p.height
                    }).width * i.length > t.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== t.config.xaxis.labels.rotate || t.config.xaxis.labels.rotateAlways) {
                        if (!t.globals.isBarHorizontal) {
                            t.globals.rotateXLabels = !0;
                            var x = function(b) {
                                return d.getTextRects(b, t.config.xaxis.labels.style.fontSize, t.config.xaxis.labels.style.fontFamily, "rotate(".concat(t.config.xaxis.labels.rotate, " 0 0)"), !1)
                            };
                            u = x(r),
                            r !== n && (p = x(n)),
                            e.height = (u.height > p.height ? u.height : p.height) / 1.5,
                            e.width = u.width > p.width ? u.width : p.width
                        }
                    } else
                        t.globals.rotateXLabels = !1
                }
                return t.config.xaxis.labels.show || (e = {
                    width: 0,
                    height: 0
                }),
                {
                    width: e.width,
                    height: e.height
                }
            }
        }, {
            key: "getxAxisGroupLabelsCoords",
            value: function() {
                var e, t = this.w;
                if (!t.globals.hasXaxisGroups)
                    return {
                        width: 0,
                        height: 0
                    };
                var i, a = (null === (e = t.config.xaxis.group.style) || void 0 === e ? void 0 : e.fontSize) || t.config.xaxis.labels.style.fontSize, s = t.globals.groups.map(function(u) {
                    return u.title
                }), r = D.getLargestStringFromArr(s), n = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, s), o = new U(this.dCtx.ctx), h = o.getTextRects(r, a), d = h;
                return r !== n && (d = o.getTextRects(n, a)),
                i = {
                    width: h.width >= d.width ? h.width : d.width,
                    height: h.height >= d.height ? h.height : d.height
                },
                t.config.xaxis.labels.show || (i = {
                    width: 0,
                    height: 0
                }),
                {
                    width: i.width,
                    height: i.height
                }
            }
        }, {
            key: "getxAxisTitleCoords",
            value: function() {
                var e = this.w
                  , t = 0
                  , i = 0;
                if (void 0 !== e.config.xaxis.title.text) {
                    var a = new U(this.dCtx.ctx).getTextRects(e.config.xaxis.title.text, e.config.xaxis.title.style.fontSize);
                    t = a.width,
                    i = a.height
                }
                return {
                    width: t,
                    height: i
                }
            }
        }, {
            key: "getxAxisTimeScaleLabelsCoords",
            value: function() {
                var e, t = this.w;
                this.dCtx.timescaleLabels = t.globals.timescaleLabels.slice();
                var i = this.dCtx.timescaleLabels.map(function(s) {
                    return s.value
                })
                  , a = i.reduce(function(s, r) {
                    return void 0 === s ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"),
                    0) : s.length > r.length ? s : r
                }, 0);
                return 1.05 * (e = new U(this.dCtx.ctx).getTextRects(a, t.config.xaxis.labels.style.fontSize)).width * i.length > t.globals.gridWidth && 0 !== t.config.xaxis.labels.rotate && (t.globals.overlappingXLabels = !0),
                e
            }
        }, {
            key: "additionalPaddingXLabels",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = i.globals
                  , s = i.config
                  , r = s.xaxis.type
                  , n = e.width;
                a.skipLastTimelinelabel = !1,
                a.skipFirstTimelinelabel = !1;
                var o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal;
                s.yaxis.forEach(function(d, u) {
                    o ? (t.dCtx.gridPad.left < n && (t.dCtx.xPadLeft = n / 2 + 1),
                    t.dCtx.xPadRight = n / 2 + 1) : function(d, u) {
                        s.yaxis.length > 1 && -1 !== a.collapsedSeriesIndices.indexOf(u) || function(p) {
                            if (t.dCtx.timescaleLabels && t.dCtx.timescaleLabels.length) {
                                var k = t.dCtx.timescaleLabels[0].position - n / 1.75 + t.dCtx.yAxisWidthLeft;
                                t.dCtx.timescaleLabels[t.dCtx.timescaleLabels.length - 1].position + n / 1.75 - t.dCtx.yAxisWidthRight > a.svgWidth - a.translateX - ("right" === i.config.legend.position && t.dCtx.lgRect.width > 0 ? t.dCtx.lgRect.width : 0) && (a.skipLastTimelinelabel = !0),
                                k < -(p.show && !p.floating || "bar" !== s.chart.type && "candlestick" !== s.chart.type && "rangeBar" !== s.chart.type && "boxPlot" !== s.chart.type ? 10 : n / 1.75) && (a.skipFirstTimelinelabel = !0)
                            } else
                                "datetime" === r ? t.dCtx.gridPad.right < n && !a.rotateXLabels && (a.skipLastTimelinelabel = !0) : "datetime" !== r && t.dCtx.gridPad.right < n / 2 - t.dCtx.yAxisWidthRight && !a.rotateXLabels && !i.config.xaxis.labels.trim && ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) && (t.dCtx.xPadRight = n / 2 + 1)
                        }(d)
                    }(d, u)
                })
            }
        }]),
        C
    }()
      , Ge = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.dCtx = e
        }
        return Te(C, [{
            key: "getyAxisLabelsCoords",
            value: function() {
                var e = this
                  , t = this.w
                  , i = []
                  , a = 10
                  , s = new Mt(this.dCtx.ctx);
                return t.config.yaxis.map(function(r, n) {
                    var o = {
                        seriesIndex: n,
                        dataPointIndex: -1,
                        w: t
                    }
                      , h = t.globals.yAxisScale[n]
                      , d = 0;
                    if (!s.isYAxisHidden(n) && r.labels.show && void 0 !== r.labels.minWidth && (d = r.labels.minWidth),
                    !s.isYAxisHidden(n) && r.labels.show && h.result.length) {
                        var u = t.globals.yLabelFormatters[n]
                          , x = h.result.reduce(function(f, w) {
                            var _, R;
                            return (null === (_ = String(u(f, o))) || void 0 === _ ? void 0 : _.length) > (null === (R = String(u(w, o))) || void 0 === R ? void 0 : R.length) ? f : w
                        }, h.niceMin === Number.MIN_VALUE ? 0 : h.niceMin)
                          , b = x = u(x, o);
                        if (void 0 !== x && 0 !== x.length || (x = h.niceMax),
                        t.globals.isBarHorizontal) {
                            a = 0;
                            var k = t.globals.labels.slice();
                            x = D.getLargestStringFromArr(k),
                            x = u(x, {
                                seriesIndex: n,
                                dataPointIndex: -1,
                                w: t
                            }),
                            b = e.dCtx.dimHelpers.getLargestStringFromMultiArr(x, k)
                        }
                        var S = new U(e.dCtx.ctx)
                          , E = "rotate(".concat(r.labels.rotate, " 0 0)")
                          , M = S.getTextRects(x, r.labels.style.fontSize, r.labels.style.fontFamily, E, !1)
                          , l = M;
                        x !== b && (l = S.getTextRects(b, r.labels.style.fontSize, r.labels.style.fontFamily, E, !1)),
                        i.push({
                            width: (d > l.width || d > M.width ? d : l.width > M.width ? l.width : M.width) + a,
                            height: l.height > M.height ? l.height : M.height
                        })
                    } else
                        i.push({
                            width: 0,
                            height: 0
                        })
                }),
                i
            }
        }, {
            key: "getyAxisTitleCoords",
            value: function() {
                var e = this
                  , i = [];
                return this.w.config.yaxis.map(function(a, s) {
                    if (a.show && void 0 !== a.title.text) {
                        var r = new U(e.dCtx.ctx)
                          , n = "rotate(".concat(a.title.rotate, " 0 0)")
                          , o = r.getTextRects(a.title.text, a.title.style.fontSize, a.title.style.fontFamily, n, !1);
                        i.push({
                            width: o.width,
                            height: o.height
                        })
                    } else
                        i.push({
                            width: 0,
                            height: 0
                        })
                }),
                i
            }
        }, {
            key: "getTotalYAxisWidth",
            value: function() {
                var e = this.w
                  , t = 0
                  , i = 0
                  , a = 0
                  , s = e.globals.yAxisScale.length > 1 ? 10 : 0
                  , r = new Mt(this.dCtx.ctx)
                  , n = function(o, h) {
                    var d = e.config.yaxis[h].floating
                      , u = 0;
                    o.width > 0 && !d ? (u = o.width + s,
                    e.globals.ignoreYAxisIndexes.indexOf(h) > -1 && (u = u - o.width - s)) : u = d || r.isYAxisHidden(h) ? 0 : 5,
                    e.config.yaxis[h].opposite ? a += u : i += u,
                    t += u
                };
                return e.globals.yLabelsCoords.map(function(o, h) {
                    n(o, h)
                }),
                e.globals.yTitleCoords.map(function(o, h) {
                    n(o, h)
                }),
                e.globals.isBarHorizontal && !e.config.yaxis[0].floating && (t = e.globals.yLabelsCoords[0].width + e.globals.yTitleCoords[0].width + 15),
                this.dCtx.yAxisWidthLeft = i,
                this.dCtx.yAxisWidthRight = a,
                t
            }
        }]),
        C
    }()
      , Wt = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.dCtx = e
        }
        return Te(C, [{
            key: "gridPadForColumnsInNumericAxis",
            value: function(e) {
                var t = this.w;
                if (t.globals.noData || t.globals.allSeriesCollapsed)
                    return 0;
                var i = function(d) {
                    return "bar" === d || "rangeBar" === d || "candlestick" === d || "boxPlot" === d
                }
                  , a = t.config.chart.type
                  , s = 0
                  , r = i(a) ? t.config.series.length : 1;
                if (t.globals.comboBarCount > 0 && (r = t.globals.comboBarCount),
                t.globals.collapsedSeries.forEach(function(d) {
                    i(d.type) && (r -= 1)
                }),
                t.config.chart.stacked && (r = 1),
                (i(a) || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && r > 0) {
                    var n, o, h = Math.abs(t.globals.initialMaxX - t.globals.initialMinX);
                    h <= 3 && (h = t.globals.dataPoints),
                    n = h / e,
                    t.globals.minXDiff && t.globals.minXDiff / n > 0 && (o = t.globals.minXDiff / n),
                    o > e / 2 && (o /= 2),
                    (s = o / r * parseInt(t.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s = 1),
                    t.globals.barPadForNumericAxis = s = s / (r > 1 ? 1 : 1.5) + 5
                }
                return s
            }
        }, {
            key: "gridPadFortitleSubtitle",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.globals
                  , a = this.dCtx.isSparkline || !t.globals.axisCharts ? 0 : 10;
                ["title", "subtitle"].forEach(function(n) {
                    a += void 0 !== t.config[n].text ? t.config[n].margin : e.dCtx.isSparkline || !t.globals.axisCharts ? 0 : 5
                }),
                !t.config.legend.show || "bottom" !== t.config.legend.position || t.config.legend.floating || t.globals.axisCharts || (a += 10);
                var s = this.dCtx.dimHelpers.getTitleSubtitleCoords("title")
                  , r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                i.gridHeight = i.gridHeight - s.height - r.height - a,
                i.translateY = i.translateY + s.height + r.height + a
            }
        }, {
            key: "setGridXPosForDualYAxis",
            value: function(e, t) {
                var i = this.w
                  , a = new Mt(this.dCtx.ctx);
                i.config.yaxis.map(function(s, r) {
                    -1 !== i.globals.ignoreYAxisIndexes.indexOf(r) || s.floating || a.isYAxisHidden(r) || (s.opposite && (i.globals.translateX = i.globals.translateX - (t[r].width + e[r].width) - parseInt(i.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12),
                    i.globals.translateX < 2 && (i.globals.translateX = 2))
                })
            }
        }]),
        C
    }()
      , Gi = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.lgRect = {},
            this.yAxisWidth = 0,
            this.yAxisWidthLeft = 0,
            this.yAxisWidthRight = 0,
            this.xAxisHeight = 0,
            this.isSparkline = this.w.config.chart.sparkline.enabled,
            this.dimHelpers = new Bi(this),
            this.dimYAxis = new Ge(this),
            this.dimXAxis = new ji(this),
            this.dimGrid = new Wt(this),
            this.lgWidthForSideLegends = 0,
            this.gridPad = this.w.config.grid.padding,
            this.xPadRight = 0,
            this.xPadLeft = 0
        }
        return Te(C, [{
            key: "plotCoords",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.globals;
                this.lgRect = this.dimHelpers.getLegendsRect(),
                this.isSparkline && (t.config.markers.discrete.length > 0 || t.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(s) {
                    var r = F(s, 2);
                    e.gridPad[r[0]] = Math.max(r[1], e.w.globals.markers.largestSize / 1.5)
                }),
                i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(),
                this.dimGrid.gridPadFortitleSubtitle(),
                i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom,
                i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                var a = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
                i.gridWidth = i.gridWidth - 2 * a,
                i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (a > 0 ? a + 4 : 0),
                i.translateY = i.translateY + this.gridPad.top
            }
        }, {
            key: "setDimensionsForAxisCharts",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.globals
                  , a = this.dimYAxis.getyAxisLabelsCoords()
                  , s = this.dimYAxis.getyAxisTitleCoords();
                t.globals.yLabelsCoords = [],
                t.globals.yTitleCoords = [],
                t.config.yaxis.map(function(x, b) {
                    t.globals.yLabelsCoords.push({
                        width: a[b].width,
                        index: b
                    }),
                    t.globals.yTitleCoords.push({
                        width: s[b].width,
                        index: b
                    })
                }),
                this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                var r = this.dimXAxis.getxAxisLabelsCoords()
                  , n = this.dimXAxis.getxAxisGroupLabelsCoords()
                  , o = this.dimXAxis.getxAxisTitleCoords();
                this.conditionalChecksForAxisCoords(r, o, n),
                i.translateXAxisY = t.globals.rotateXLabels ? this.xAxisHeight / 8 : -4,
                i.translateXAxisX = t.globals.rotateXLabels && t.globals.isXNumeric && t.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0,
                t.globals.isBarHorizontal && (i.rotateXLabels = !1,
                i.translateXAxisY = parseInt(t.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1),
                i.translateXAxisY = i.translateXAxisY + t.config.xaxis.labels.offsetY,
                i.translateXAxisX = i.translateXAxisX + t.config.xaxis.labels.offsetX;
                var h = this.yAxisWidth
                  , d = this.xAxisHeight;
                i.xAxisLabelsHeight = this.xAxisHeight - o.height,
                i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - r.height,
                i.xAxisLabelsWidth = this.xAxisWidth,
                i.xAxisHeight = this.xAxisHeight;
                var u = 10;
                ("radar" === t.config.chart.type || this.isSparkline) && (h = 0,
                d = i.goldenPadding),
                this.isSparkline && (this.lgRect = {
                    height: 0,
                    width: 0
                }),
                (this.isSparkline || "treemap" === t.config.chart.type) && (h = 0,
                d = 0,
                u = 0),
                this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r);
                var p = function() {
                    i.translateX = h,
                    i.gridHeight = i.svgHeight - e.lgRect.height - d - (e.isSparkline || "treemap" === t.config.chart.type ? 0 : t.globals.rotateXLabels ? 10 : 15),
                    i.gridWidth = i.svgWidth - h
                };
                switch ("top" === t.config.xaxis.position && (u = i.xAxisHeight - t.config.xaxis.axisTicks.height - 5),
                t.config.legend.position) {
                case "bottom":
                    i.translateY = u,
                    p();
                    break;
                case "top":
                    i.translateY = this.lgRect.height + u,
                    p();
                    break;
                case "left":
                    i.translateY = u,
                    i.translateX = this.lgRect.width + h,
                    i.gridHeight = i.svgHeight - d - 12,
                    i.gridWidth = i.svgWidth - this.lgRect.width - h;
                    break;
                case "right":
                    i.translateY = u,
                    i.translateX = h,
                    i.gridHeight = i.svgHeight - d - 12,
                    i.gridWidth = i.svgWidth - this.lgRect.width - h - 5;
                    break;
                default:
                    throw new Error("Legend position not supported")
                }
                this.dimGrid.setGridXPosForDualYAxis(s, a),
                new ia(this.ctx).setYAxisXPosition(a, s)
            }
        }, {
            key: "setDimensionsForNonAxisCharts",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = e.config
                  , a = 0;
                e.config.legend.show && !e.config.legend.floating && (a = 20);
                var s = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar"
                  , r = i.plotOptions[s].offsetY
                  , n = i.plotOptions[s].offsetX;
                if (!i.legend.show || i.legend.floating)
                    return t.gridHeight = t.svgHeight - i.grid.padding.left + i.grid.padding.right,
                    t.gridWidth = t.gridHeight,
                    t.translateY = r,
                    void (t.translateX = n + (t.svgWidth - t.gridWidth) / 2);
                switch (i.legend.position) {
                case "bottom":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding,
                    t.gridWidth = t.svgWidth,
                    t.translateY = r - 10,
                    t.translateX = n + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case "top":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding,
                    t.gridWidth = t.svgWidth,
                    t.translateY = this.lgRect.height + r + 10,
                    t.translateX = n + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case "left":
                    t.gridWidth = t.svgWidth - this.lgRect.width - a,
                    t.gridHeight = "auto" !== i.chart.height ? t.svgHeight : t.gridWidth,
                    t.translateY = r,
                    t.translateX = n + this.lgRect.width + a;
                    break;
                case "right":
                    t.gridWidth = t.svgWidth - this.lgRect.width - a - 5,
                    t.gridHeight = "auto" !== i.chart.height ? t.svgHeight : t.gridWidth,
                    t.translateY = r,
                    t.translateX = n + 10;
                    break;
                default:
                    throw new Error("Legend position not supported")
                }
            }
        }, {
            key: "conditionalChecksForAxisCoords",
            value: function(e, t, i) {
                var a = this.w;
                this.xAxisHeight = (i.height + e.height + t.height) * (a.globals.isMultiLineX ? 1.2 : a.globals.LINE_HEIGHT_RATIO) + (a.globals.hasXaxisGroups ? 2 : 1) * (a.globals.rotateXLabels ? 22 : 10) + (a.globals.rotateXLabels && "bottom" === a.config.legend.position ? 10 : 0),
                this.xAxisWidth = e.width,
                this.xAxisHeight - t.height > a.config.xaxis.labels.maxHeight && (this.xAxisHeight = a.config.xaxis.labels.maxHeight),
                a.config.xaxis.labels.minHeight && this.xAxisHeight < a.config.xaxis.labels.minHeight && (this.xAxisHeight = a.config.xaxis.labels.minHeight),
                a.config.xaxis.floating && (this.xAxisHeight = 0);
                var d = 0
                  , u = 0;
                a.config.yaxis.forEach(function(p) {
                    d += p.labels.minWidth,
                    u += p.labels.maxWidth
                }),
                this.yAxisWidth < d && (this.yAxisWidth = d),
                this.yAxisWidth > u && (this.yAxisWidth = u)
            }
        }]),
        C
    }()
      , Ki = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.lgCtx = e
        }
        return Te(C, [{
            key: "getLegendStyles",
            value: function() {
                var e = document.createElement("style");
                e.setAttribute("type", "text/css");
                var t = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
                return e.appendChild(t),
                e
            }
        }, {
            key: "getLegendBBox",
            value: function() {
                var e = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect();
                return {
                    clwh: e.height,
                    clww: e.width
                }
            }
        }, {
            key: "appendToForeignObject",
            value: function() {
                this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles())
            }
        }, {
            key: "toggleDataSeries",
            value: function(e, t) {
                var i = this
                  , a = this.w;
                if (a.globals.axisCharts || "radialBar" === a.config.chart.type) {
                    a.globals.resized = !0;
                    var s = null
                      , r = null;
                    a.globals.risingSeries = [],
                    a.globals.axisCharts ? (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")),
                    r = parseInt(s.getAttribute("data:realIndex"), 10)) : (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")),
                    r = parseInt(s.getAttribute("rel"), 10) - 1),
                    t ? [{
                        cs: a.globals.collapsedSeries,
                        csi: a.globals.collapsedSeriesIndices
                    }, {
                        cs: a.globals.ancillaryCollapsedSeries,
                        csi: a.globals.ancillaryCollapsedSeriesIndices
                    }].forEach(function(d) {
                        i.riseCollapsedSeries(d.cs, d.csi, r)
                    }) : this.hideSeries({
                        seriesEl: s,
                        realIndex: r
                    })
                } else {
                    var n = a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(e + 1, "'] path"))
                      , o = a.config.chart.type;
                    if ("pie" === o || "polarArea" === o || "donut" === o) {
                        var h = a.config.plotOptions.pie.donut.labels;
                        new U(this.lgCtx.ctx).pathMouseDown(n.members[0], null),
                        this.lgCtx.ctx.pie.printDataLabelsInner(n.members[0].node, h)
                    }
                    n.fire("click")
                }
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                var t = e.seriesEl
                  , i = e.realIndex
                  , a = this.w
                  , s = D.clone(a.config.series);
                if (a.globals.axisCharts) {
                    var r = !1;
                    if (a.config.yaxis[i] && a.config.yaxis[i].show && a.config.yaxis[i].showAlways && (r = !0,
                    a.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (a.globals.ancillaryCollapsedSeries.push({
                        index: i,
                        data: s[i].data.slice(),
                        type: t.parentNode.className.baseVal.split("-")[1]
                    }),
                    a.globals.ancillaryCollapsedSeriesIndices.push(i))),
                    !r) {
                        a.globals.collapsedSeries.push({
                            index: i,
                            data: s[i].data.slice(),
                            type: t.parentNode.className.baseVal.split("-")[1]
                        }),
                        a.globals.collapsedSeriesIndices.push(i);
                        var n = a.globals.risingSeries.indexOf(i);
                        a.globals.risingSeries.splice(n, 1)
                    }
                } else
                    a.globals.collapsedSeries.push({
                        index: i,
                        data: s[i]
                    }),
                    a.globals.collapsedSeriesIndices.push(i);
                for (var o = t.childNodes, h = 0; h < o.length; h++)
                    o[h].classList.contains("apexcharts-series-markers-wrap") && (o[h].classList.contains("apexcharts-hide") ? o[h].classList.remove("apexcharts-hide") : o[h].classList.add("apexcharts-hide"));
                a.globals.allSeriesCollapsed = a.globals.collapsedSeries.length === a.config.series.length,
                s = this._getSeriesBasedOnCollapsedState(s),
                this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled)
            }
        }, {
            key: "riseCollapsedSeries",
            value: function(e, t, i) {
                var a = this.w
                  , s = D.clone(a.config.series);
                if (e.length > 0) {
                    for (var r = 0; r < e.length; r++)
                        e[r].index === i && (a.globals.axisCharts ? (s[i].data = e[r].data.slice(),
                        e.splice(r, 1),
                        t.splice(r, 1),
                        a.globals.risingSeries.push(i)) : (s[i] = e[r].data,
                        e.splice(r, 1),
                        t.splice(r, 1),
                        a.globals.risingSeries.push(i)));
                    s = this._getSeriesBasedOnCollapsedState(s),
                    this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled)
                }
            }
        }, {
            key: "_getSeriesBasedOnCollapsedState",
            value: function(e) {
                var t = this.w;
                return e.forEach(t.globals.axisCharts ? function(i, a) {
                    t.globals.collapsedSeriesIndices.indexOf(a) > -1 && (e[a].data = [])
                }
                : function(i, a) {
                    t.globals.collapsedSeriesIndices.indexOf(a) > -1 && (e[a] = 0)
                }
                ),
                e
            }
        }]),
        C
    }()
      , ci = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.onLegendClick = this.onLegendClick.bind(this),
            this.onLegendHovered = this.onLegendHovered.bind(this),
            this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length,
            this.legendHelpers = new Ki(this)
        }
        return Te(C, [{
            key: "init",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = e.config;
                if ((i.legend.showForSingleSeries && 1 === t.series.length || this.isBarsDistributed || t.series.length > 1 || !t.axisCharts) && i.legend.show) {
                    for (; t.dom.elLegendWrap.firstChild; )
                        t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
                    this.drawLegends(),
                    D.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(),
                    "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical()
                }
            }
        }, {
            key: "drawLegends",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.config.legend.fontFamily
                  , a = t.globals.seriesNames
                  , s = t.globals.colors.slice();
                if ("heatmap" === t.config.chart.type) {
                    var r = t.config.plotOptions.heatmap.colorScale.ranges;
                    a = r.map(function(ue) {
                        return ue.name ? ue.name : ue.from + " - " + ue.to
                    }),
                    s = r.map(function(ue) {
                        return ue.color
                    })
                } else
                    this.isBarsDistributed && (a = t.globals.labels.slice());
                t.config.legend.customLegendItems.length && (a = t.config.legend.customLegendItems);
                for (var n = t.globals.legendFormatter, o = t.config.legend.inverseOrder, h = o ? a.length - 1 : 0; o ? h >= 0 : h <= a.length - 1; o ? h-- : h++) {
                    var d, u = n(a[h], {
                        seriesIndex: h,
                        w: t
                    }), p = !1, x = !1;
                    if (t.globals.collapsedSeries.length > 0)
                        for (var b = 0; b < t.globals.collapsedSeries.length; b++)
                            t.globals.collapsedSeries[b].index === h && (p = !0);
                    if (t.globals.ancillaryCollapsedSeriesIndices.length > 0)
                        for (var k = 0; k < t.globals.ancillaryCollapsedSeriesIndices.length; k++)
                            t.globals.ancillaryCollapsedSeriesIndices[k] === h && (x = !0);
                    var S = document.createElement("span");
                    S.classList.add("apexcharts-legend-marker");
                    var E = t.config.legend.markers.offsetX
                      , M = t.config.legend.markers.offsetY
                      , l = t.config.legend.markers.height
                      , f = t.config.legend.markers.width
                      , w = t.config.legend.markers.strokeWidth
                      , _ = t.config.legend.markers.strokeColor
                      , R = t.config.legend.markers.radius
                      , H = S.style;
                    H.background = s[h],
                    H.color = s[h],
                    H.setProperty("background", s[h], "important"),
                    t.config.legend.markers.fillColors && t.config.legend.markers.fillColors[h] && (H.background = t.config.legend.markers.fillColors[h]),
                    void 0 !== t.globals.seriesColors[h] && (H.background = t.globals.seriesColors[h],
                    H.color = t.globals.seriesColors[h]),
                    H.height = Array.isArray(l) ? parseFloat(l[h]) + "px" : parseFloat(l) + "px",
                    H.width = Array.isArray(f) ? parseFloat(f[h]) + "px" : parseFloat(f) + "px",
                    H.left = (Array.isArray(E) ? parseFloat(E[h]) : parseFloat(E)) + "px",
                    H.top = (Array.isArray(M) ? parseFloat(M[h]) : parseFloat(M)) + "px",
                    H.borderWidth = Array.isArray(w) ? w[h] : w,
                    H.borderColor = Array.isArray(_) ? _[h] : _,
                    H.borderRadius = Array.isArray(R) ? parseFloat(R[h]) + "px" : parseFloat(R) + "px",
                    t.config.legend.markers.customHTML && (Array.isArray(t.config.legend.markers.customHTML) ? t.config.legend.markers.customHTML[h] && (S.innerHTML = t.config.legend.markers.customHTML[h]()) : S.innerHTML = t.config.legend.markers.customHTML()),
                    U.setAttrs(S, {
                        rel: h + 1,
                        "data:collapsed": p || x
                    }),
                    (p || x) && S.classList.add("apexcharts-inactive-legend");
                    var B = document.createElement("div")
                      , j = document.createElement("span");
                    j.classList.add("apexcharts-legend-text"),
                    j.innerHTML = Array.isArray(u) ? u.join(" ") : u;
                    var ce = t.config.legend.labels.useSeriesColors ? t.globals.colors[h] : Array.isArray(t.config.legend.labels.colors) ? null === (d = t.config.legend.labels.colors) || void 0 === d ? void 0 : d[h] : t.config.legend.labels.colors;
                    ce || (ce = t.config.chart.foreColor),
                    j.style.color = ce,
                    j.style.fontSize = parseFloat(t.config.legend.fontSize) + "px",
                    j.style.fontWeight = t.config.legend.fontWeight,
                    j.style.fontFamily = i || t.config.chart.fontFamily,
                    U.setAttrs(j, {
                        rel: h + 1,
                        i: h,
                        "data:default-text": encodeURIComponent(u),
                        "data:collapsed": p || x
                    }),
                    B.appendChild(S),
                    B.appendChild(j);
                    var me = new ae(this.ctx);
                    t.config.legend.showForZeroSeries || 0 === me.getSeriesTotalByIndex(h) && me.seriesHaveSameValues(h) && !me.isSeriesNull(h) && -1 === t.globals.collapsedSeriesIndices.indexOf(h) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(h) && B.classList.add("apexcharts-hidden-zero-series"),
                    t.config.legend.showForNullSeries || me.isSeriesNull(h) && -1 === t.globals.collapsedSeriesIndices.indexOf(h) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(h) && B.classList.add("apexcharts-hidden-null-series"),
                    t.globals.dom.elLegendWrap.appendChild(B),
                    t.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(t.config.legend.horizontalAlign)),
                    t.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + t.config.legend.position),
                    B.classList.add("apexcharts-legend-series"),
                    B.style.margin = "".concat(t.config.legend.itemMargin.vertical, "px ").concat(t.config.legend.itemMargin.horizontal, "px"),
                    t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? t.config.legend.width + "px" : "",
                    t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? t.config.legend.height + "px" : "",
                    U.setAttrs(B, {
                        rel: h + 1,
                        seriesName: D.escapeString(a[h]),
                        "data:collapsed": p || x
                    }),
                    (p || x) && B.classList.add("apexcharts-inactive-legend"),
                    t.config.legend.onItemClick.toggleDataSeries || B.classList.add("apexcharts-no-click")
                }
                t.globals.dom.elWrap.addEventListener("click", e.onLegendClick, !0),
                t.config.legend.onItemHover.highlightDataSeries && 0 === t.config.legend.customLegendItems.length && (t.globals.dom.elWrap.addEventListener("mousemove", e.onLegendHovered, !0),
                t.globals.dom.elWrap.addEventListener("mouseout", e.onLegendHovered, !0))
            }
        }, {
            key: "setLegendWrapXY",
            value: function(e, t) {
                var i = this.w
                  , a = i.globals.dom.elLegendWrap
                  , s = a.getBoundingClientRect()
                  , r = 0
                  , n = 0;
                if ("bottom" === i.config.legend.position)
                    n += i.globals.svgHeight - s.height / 2;
                else if ("top" === i.config.legend.position) {
                    var o = new Gi(this.ctx)
                      , h = o.dimHelpers.getTitleSubtitleCoords("title").height
                      , d = o.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                    n = n + (h > 0 ? h - 10 : 0) + (d > 0 ? d - 10 : 0)
                }
                a.style.position = "absolute",
                n = n + t + i.config.legend.offsetY,
                a.style.left = (r = r + e + i.config.legend.offsetX) + "px",
                a.style.top = n + "px",
                "bottom" === i.config.legend.position ? (a.style.top = "auto",
                a.style.bottom = 5 - i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (a.style.left = "auto",
                a.style.right = 25 + i.config.legend.offsetX + "px"),
                ["width", "height"].forEach(function(u) {
                    a.style[u] && (a.style[u] = parseInt(i.config.legend[u], 10) + "px")
                })
            }
        }, {
            key: "legendAlignHorizontal",
            value: function() {
                var e = this.w;
                e.globals.dom.elLegendWrap.style.right = 0;
                var t = this.legendHelpers.getLegendBBox()
                  , i = new Gi(this.ctx)
                  , a = i.dimHelpers.getTitleSubtitleCoords("title")
                  , s = i.dimHelpers.getTitleSubtitleCoords("subtitle")
                  , r = 0;
                "bottom" === e.config.legend.position ? r = -t.clwh / 1.8 : "top" === e.config.legend.position && (r = a.height + s.height + e.config.title.margin + e.config.subtitle.margin - 10),
                this.setLegendWrapXY(20, r)
            }
        }, {
            key: "legendAlignVertical",
            value: function() {
                var e = this.w
                  , t = this.legendHelpers.getLegendBBox()
                  , i = 0;
                "left" === e.config.legend.position && (i = 20),
                "right" === e.config.legend.position && (i = e.globals.svgWidth - t.clww - 10),
                this.setLegendWrapXY(i, 20)
            }
        }, {
            key: "onLegendHovered",
            value: function(e) {
                var t = this.w
                  , i = e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
                if ("heatmap" === t.config.chart.type || this.isBarsDistributed) {
                    if (i) {
                        var a = parseInt(e.target.getAttribute("rel"), 10) - 1;
                        this.ctx.events.fireEvent("legendHover", [this.ctx, a, this.w]),
                        new Lt(this.ctx).highlightRangeInSeries(e, e.target)
                    }
                } else
                    !e.target.classList.contains("apexcharts-inactive-legend") && i && new Lt(this.ctx).toggleSeriesOnHover(e, e.target)
            }
        }, {
            key: "onLegendClick",
            value: function(e) {
                var t = this.w;
                if (!t.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker"))) {
                    var i = parseInt(e.target.getAttribute("rel"), 10) - 1
                      , a = "true" === e.target.getAttribute("data:collapsed")
                      , s = this.w.config.chart.events.legendClick;
                    "function" == typeof s && s(this.ctx, i, this.w),
                    this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
                    var r = this.w.config.legend.markers.onClick;
                    "function" == typeof r && e.target.classList.contains("apexcharts-legend-marker") && (r(this.ctx, i, this.w),
                    this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])),
                    "treemap" !== t.config.chart.type && "heatmap" !== t.config.chart.type && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, a)
                }
            }
        }]),
        C
    }()
      , mi = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.ev = this.w.config.chart.events,
            this.selectedClass = "apexcharts-selected",
            this.localeValues = this.w.globals.locale.toolbar,
            this.minX = t.globals.minX,
            this.maxX = t.globals.maxX
        }
        return Te(C, [{
            key: "createToolbar",
            value: function() {
                var e = this
                  , t = this.w
                  , i = function() {
                    return document.createElement("div")
                }
                  , a = i();
                if (a.setAttribute("class", "apexcharts-toolbar"),
                a.style.top = t.config.chart.toolbar.offsetY + "px",
                a.style.right = 3 - t.config.chart.toolbar.offsetX + "px",
                t.globals.dom.elWrap.appendChild(a),
                this.elZoom = i(),
                this.elZoomIn = i(),
                this.elZoomOut = i(),
                this.elPan = i(),
                this.elSelection = i(),
                this.elZoomReset = i(),
                this.elMenuIcon = i(),
                this.elMenu = i(),
                this.elCustomIcons = [],
                this.t = t.config.chart.toolbar.tools,
                Array.isArray(this.t.customIcons))
                    for (var s = 0; s < this.t.customIcons.length; s++)
                        this.elCustomIcons.push(i());
                var r = []
                  , n = function(u, p, x) {
                    var b = u.toLowerCase();
                    e.t[b] && t.config.chart.zoom.enabled && r.push({
                        el: p,
                        icon: "string" == typeof e.t[b] ? e.t[b] : x,
                        title: e.localeValues[u],
                        class: "apexcharts-".concat(b, "-icon")
                    })
                };
                n("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'),
                n("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                var o = function(u) {
                    e.t[u] && t.config.chart[u].enabled && r.push({
                        el: "zoom" === u ? e.elZoom : e.elSelection,
                        icon: "string" == typeof e.t[u] ? e.t[u] : "zoom" === u ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                        title: e.localeValues["zoom" === u ? "selectionZoom" : "selection"],
                        class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(u, "-icon")
                    })
                };
                o("zoom"),
                o("selection"),
                this.t.pan && t.config.chart.zoom.enabled && r.push({
                    el: this.elPan,
                    icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                    title: this.localeValues.pan,
                    class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                }),
                n("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'),
                this.t.download && r.push({
                    el: this.elMenuIcon,
                    icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                    title: this.localeValues.menu,
                    class: "apexcharts-menu-icon"
                });
                for (var h = 0; h < this.elCustomIcons.length; h++)
                    r.push({
                        el: this.elCustomIcons[h],
                        icon: this.t.customIcons[h].icon,
                        title: this.t.customIcons[h].title,
                        index: this.t.customIcons[h].index,
                        class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[h].class
                    });
                r.forEach(function(u, p) {
                    u.index && D.moveIndexInArray(r, p, u.index)
                });
                for (var d = 0; d < r.length; d++)
                    U.setAttrs(r[d].el, {
                        class: r[d].class,
                        title: r[d].title
                    }),
                    r[d].el.innerHTML = r[d].icon,
                    a.appendChild(r[d].el);
                this._createHamburgerMenu(a),
                t.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : t.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : t.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass),
                this.addToolbarEventListeners()
            }
        }, {
            key: "_createHamburgerMenu",
            value: function(e) {
                this.elMenuItems = [],
                e.appendChild(this.elMenu),
                U.setAttrs(this.elMenu, {
                    class: "apexcharts-menu"
                });
                var t = [{
                    name: "exportSVG",
                    title: this.localeValues.exportToSVG
                }, {
                    name: "exportPNG",
                    title: this.localeValues.exportToPNG
                }, {
                    name: "exportCSV",
                    title: this.localeValues.exportToCSV
                }];
                this.w.globals.allSeriesHasEqualX || t.splice(2, 1);
                for (var i = 0; i < t.length; i++)
                    this.elMenuItems.push(document.createElement("div")),
                    this.elMenuItems[i].innerHTML = t[i].title,
                    U.setAttrs(this.elMenuItems[i], {
                        class: "apexcharts-menu-item ".concat(t[i].name),
                        title: t[i].title
                    }),
                    this.elMenu.appendChild(this.elMenuItems[i])
            }
        }, {
            key: "addToolbarEventListeners",
            value: function() {
                var e = this;
                this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)),
                this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")),
                this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")),
                this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)),
                this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)),
                this.elPan.addEventListener("click", this.togglePanning.bind(this)),
                this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)),
                this.elMenuItems.forEach(function(i) {
                    i.classList.contains("exportSVG") ? i.addEventListener("click", e.handleDownload.bind(e, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", e.handleDownload.bind(e, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", e.handleDownload.bind(e, "csv"))
                });
                for (var t = 0; t < this.t.customIcons.length; t++)
                    this.elCustomIcons[t].addEventListener("click", this.t.customIcons[t].click.bind(this, this.ctx, this.ctx.w))
            }
        }, {
            key: "toggleZoomSelection",
            value: function(e) {
                this.ctx.getSyncedCharts().forEach(function(t) {
                    t.ctx.toolbar.toggleOtherControls();
                    var i = "selection" === e ? t.ctx.toolbar.elSelection : t.ctx.toolbar.elZoom
                      , a = "selection" === e ? "selectionEnabled" : "zoomEnabled";
                    t.w.globals[a] = !t.w.globals[a],
                    i.classList.contains(t.ctx.toolbar.selectedClass) ? i.classList.remove(t.ctx.toolbar.selectedClass) : i.classList.add(t.ctx.toolbar.selectedClass)
                })
            }
        }, {
            key: "getToolbarIconsReference",
            value: function() {
                var e = this.w;
                this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")),
                this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")),
                this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
            }
        }, {
            key: "enableZoomPanFromToolbar",
            value: function(e) {
                this.toggleOtherControls(),
                "pan" === e ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                var t = "pan" === e ? this.elPan : this.elZoom
                  , i = "pan" === e ? this.elZoom : this.elPan;
                t && t.classList.add(this.selectedClass),
                i && i.classList.remove(this.selectedClass)
            }
        }, {
            key: "togglePanning",
            value: function() {
                this.ctx.getSyncedCharts().forEach(function(e) {
                    e.ctx.toolbar.toggleOtherControls(),
                    e.w.globals.panEnabled = !e.w.globals.panEnabled,
                    e.ctx.toolbar.elPan.classList.contains(e.ctx.toolbar.selectedClass) ? e.ctx.toolbar.elPan.classList.remove(e.ctx.toolbar.selectedClass) : e.ctx.toolbar.elPan.classList.add(e.ctx.toolbar.selectedClass)
                })
            }
        }, {
            key: "toggleOtherControls",
            value: function() {
                var e = this
                  , t = this.w;
                t.globals.panEnabled = !1,
                t.globals.zoomEnabled = !1,
                t.globals.selectionEnabled = !1,
                this.getToolbarIconsReference(),
                [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
                    i && i.classList.remove(e.selectedClass)
                })
            }
        }, {
            key: "handleZoomIn",
            value: function() {
                var e = this.w;
                e.globals.isRangeBar && (this.minX = e.globals.minY,
                this.maxX = e.globals.maxY);
                var t = (this.minX + this.maxX) / 2
                  , s = this._getNewMinXMaxX((this.minX + t) / 2, (this.maxX + t) / 2);
                e.globals.disableZoomIn || this.zoomUpdateOptions(s.minX, s.maxX)
            }
        }, {
            key: "handleZoomOut",
            value: function() {
                var e = this.w;
                if (e.globals.isRangeBar && (this.minX = e.globals.minY,
                this.maxX = e.globals.maxY),
                !("datetime" === e.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
                    var t = (this.minX + this.maxX) / 2
                      , s = this._getNewMinXMaxX(this.minX - (t - this.minX), this.maxX - (t - this.maxX));
                    e.globals.disableZoomOut || this.zoomUpdateOptions(s.minX, s.maxX)
                }
            }
        }, {
            key: "_getNewMinXMaxX",
            value: function(e, t) {
                var i = this.w.config.xaxis.convertedCatToNumeric;
                return {
                    minX: i ? Math.floor(e) : e,
                    maxX: i ? Math.floor(t) : t
                }
            }
        }, {
            key: "zoomUpdateOptions",
            value: function(e, t) {
                var i = this.w;
                if (void 0 !== e || void 0 !== t) {
                    if (!(i.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1,
                    t = i.globals.dataPoints),
                    t - e < 2))) {
                        var a = {
                            min: e,
                            max: t
                        }
                          , s = this.getBeforeZoomRange(a);
                        s && (a = s.xaxis);
                        var r = {
                            xaxis: a
                        }
                          , n = D.clone(i.globals.initialConfig.yaxis);
                        i.config.chart.zoom.autoScaleYaxis && (n = new Jt(this.ctx).autoScaleY(this.ctx, n, {
                            xaxis: a
                        })),
                        i.config.chart.group || (r.yaxis = n),
                        this.w.globals.zoomed = !0,
                        this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled),
                        this.zoomCallback(a, n)
                    }
                } else
                    this.handleZoomReset()
            }
        }, {
            key: "zoomCallback",
            value: function(e, t) {
                "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
                    xaxis: e,
                    yaxis: t
                })
            }
        }, {
            key: "getBeforeZoomRange",
            value: function(e, t) {
                var i = null;
                return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, {
                    xaxis: e,
                    yaxis: t
                })),
                i
            }
        }, {
            key: "toggleMenu",
            value: function() {
                var e = this;
                window.setTimeout(function() {
                    e.elMenu.classList.contains("apexcharts-menu-open") ? e.elMenu.classList.remove("apexcharts-menu-open") : e.elMenu.classList.add("apexcharts-menu-open")
                }, 0)
            }
        }, {
            key: "handleDownload",
            value: function(e) {
                var t = this.w
                  , i = new Ft(this.ctx);
                switch (e) {
                case "svg":
                    i.exportToSVG(this.ctx);
                    break;
                case "png":
                    i.exportToPng(this.ctx);
                    break;
                case "csv":
                    i.exportToCSV({
                        series: t.config.series,
                        columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter
                    })
                }
            }
        }, {
            key: "handleZoomReset",
            value: function(e) {
                this.ctx.getSyncedCharts().forEach(function(t) {
                    var i = t.w;
                    if (i.globals.lastXAxis.min = i.globals.initialConfig.xaxis.min,
                    i.globals.lastXAxis.max = i.globals.initialConfig.xaxis.max,
                    t.updateHelpers.revertDefaultAxisMinMax(),
                    "function" == typeof i.config.chart.events.beforeResetZoom) {
                        var a = i.config.chart.events.beforeResetZoom(t, i);
                        a && t.updateHelpers.revertDefaultAxisMinMax(a)
                    }
                    "function" == typeof i.config.chart.events.zoomed && t.ctx.toolbar.zoomCallback({
                        min: i.config.xaxis.min,
                        max: i.config.xaxis.max
                    }),
                    i.globals.zoomed = !1;
                    var s = t.ctx.series.emptyCollapsedSeries(D.clone(i.globals.initialSeries));
                    t.updateHelpers._updateSeries(s, i.config.chart.animations.dynamicAnimation.enabled)
                })
            }
        }, {
            key: "destroy",
            value: function() {
                this.elZoom = null,
                this.elZoomIn = null,
                this.elZoomOut = null,
                this.elPan = null,
                this.elSelection = null,
                this.elZoomReset = null,
                this.elMenuIcon = null
            }
        }]),
        C
    }()
      , Pt = function(C) {
        pe(t, C);
        var e = He(t);
        function t(i) {
            var a;
            return Q(this, t),
            (a = e.call(this, i)).ctx = i,
            a.w = i.w,
            a.dragged = !1,
            a.graphics = new U(a.ctx),
            a.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"],
            a.clientX = 0,
            a.clientY = 0,
            a.startX = 0,
            a.endX = 0,
            a.dragX = 0,
            a.startY = 0,
            a.endY = 0,
            a.dragY = 0,
            a.moveDirection = "none",
            a
        }
        return Te(t, [{
            key: "init",
            value: function(i) {
                var a = this
                  , s = i.xyRatios
                  , r = this.w
                  , n = this;
                this.xyRatios = s,
                this.zoomRect = this.graphics.drawRect(0, 0, 0, 0),
                this.selectionRect = this.graphics.drawRect(0, 0, 0, 0),
                this.gridRect = r.globals.dom.baseEl.querySelector(".apexcharts-grid"),
                this.zoomRect.node.classList.add("apexcharts-zoom-rect"),
                this.selectionRect.node.classList.add("apexcharts-selection-rect"),
                r.globals.dom.elGraphical.add(this.zoomRect),
                r.globals.dom.elGraphical.add(this.selectionRect),
                this.slDraggableRect = "x" === r.config.chart.selection.type ? this.selectionRect.draggable({
                    minX: 0,
                    minY: 0,
                    maxX: r.globals.gridWidth,
                    maxY: r.globals.gridHeight
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === r.config.chart.selection.type ? this.selectionRect.draggable({
                    minX: 0,
                    maxX: r.globals.gridWidth
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")),
                this.preselectedSelection(),
                this.hoverArea = r.globals.dom.baseEl.querySelector("".concat(r.globals.chartClass, " .apexcharts-svg")),
                this.hoverArea.classList.add("apexcharts-zoomable"),
                this.eventList.forEach(function(o) {
                    a.hoverArea.addEventListener(o, n.svgMouseEvents.bind(n, s), {
                        capture: !1,
                        passive: !0
                    })
                })
            }
        }, {
            key: "destroy",
            value: function() {
                this.slDraggableRect && (this.slDraggableRect.draggable(!1),
                this.slDraggableRect.off(),
                this.selectionRect.off()),
                this.selectionRect = null,
                this.zoomRect = null,
                this.gridRect = null
            }
        }, {
            key: "svgMouseEvents",
            value: function(i, a) {
                var s = this.w
                  , r = this
                  , n = this.ctx.toolbar
                  , o = s.globals.zoomEnabled ? s.config.chart.zoom.type : s.config.chart.selection.type
                  , h = s.config.chart.toolbar.autoSelected;
                if (a.shiftKey ? (this.shiftWasPressed = !0,
                n.enableZoomPanFromToolbar("pan" === h ? "zoom" : "pan")) : this.shiftWasPressed && (n.enableZoomPanFromToolbar(h),
                this.shiftWasPressed = !1),
                a.target) {
                    var d, u = a.target.classList;
                    if (a.target.parentNode && null !== a.target.parentNode && (d = a.target.parentNode.classList),
                    !(u.contains("apexcharts-selection-rect") || u.contains("apexcharts-legend-marker") || u.contains("apexcharts-legend-text") || d && d.contains("apexcharts-toolbar"))) {
                        if (r.clientX = "touchmove" === a.type || "touchstart" === a.type ? a.touches[0].clientX : "touchend" === a.type ? a.changedTouches[0].clientX : a.clientX,
                        r.clientY = "touchmove" === a.type || "touchstart" === a.type ? a.touches[0].clientY : "touchend" === a.type ? a.changedTouches[0].clientY : a.clientY,
                        "mousedown" === a.type && 1 === a.which) {
                            var p = r.gridRect.getBoundingClientRect();
                            r.startX = r.clientX - p.left,
                            r.startY = r.clientY - p.top,
                            r.dragged = !1,
                            r.w.globals.mousedown = !0
                        }
                        if (("mousemove" === a.type && 1 === a.which || "touchmove" === a.type) && (r.dragged = !0,
                        s.globals.panEnabled ? (s.globals.selection = null,
                        r.w.globals.mousedown && r.panDragging({
                            context: r,
                            zoomtype: o,
                            xyRatios: i
                        })) : (r.w.globals.mousedown && s.globals.zoomEnabled || r.w.globals.mousedown && s.globals.selectionEnabled) && (r.selection = r.selectionDrawing({
                            context: r,
                            zoomtype: o
                        }))),
                        "mouseup" === a.type || "touchend" === a.type || "mouseleave" === a.type) {
                            var x = r.gridRect.getBoundingClientRect();
                            r.w.globals.mousedown && (r.endX = r.clientX - x.left,
                            r.endY = r.clientY - x.top,
                            r.dragX = Math.abs(r.endX - r.startX),
                            r.dragY = Math.abs(r.endY - r.startY),
                            (s.globals.zoomEnabled || s.globals.selectionEnabled) && r.selectionDrawn({
                                context: r,
                                zoomtype: o
                            }),
                            s.globals.panEnabled && s.config.xaxis.convertedCatToNumeric && r.delayedPanScrolled()),
                            s.globals.zoomEnabled && r.hideSelectionRect(this.selectionRect),
                            r.dragged = !1,
                            r.w.globals.mousedown = !1
                        }
                        this.makeSelectionRectDraggable()
                    }
                }
            }
        }, {
            key: "makeSelectionRectDraggable",
            value: function() {
                var i = this.w;
                if (this.selectionRect) {
                    var a = this.selectionRect.node.getBoundingClientRect();
                    a.width > 0 && a.height > 0 && this.slDraggableRect.selectize({
                        points: "l, r",
                        pointSize: 8,
                        pointType: "rect"
                    }).resize({
                        constraint: {
                            minX: 0,
                            minY: 0,
                            maxX: i.globals.gridWidth,
                            maxY: i.globals.gridHeight
                        }
                    }).on("resizing", this.selectionDragging.bind(this, "resizing"))
                }
            }
        }, {
            key: "preselectedSelection",
            value: function() {
                var i = this.w
                  , a = this.xyRatios;
                if (!i.globals.zoomEnabled)
                    if (null != i.globals.selection)
                        this.drawSelectionRect(i.globals.selection);
                    else if (void 0 !== i.config.chart.selection.xaxis.min && void 0 !== i.config.chart.selection.xaxis.max) {
                        var s = (i.config.chart.selection.xaxis.min - i.globals.minX) / a.xRatio;
                        this.drawSelectionRect({
                            x: s,
                            y: 0,
                            width: i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / a.xRatio - s,
                            height: i.globals.gridHeight,
                            translateX: 0,
                            translateY: 0,
                            selectionEnabled: !0
                        }),
                        this.makeSelectionRectDraggable(),
                        "function" == typeof i.config.chart.events.selection && i.config.chart.events.selection(this.ctx, {
                            xaxis: {
                                min: i.config.chart.selection.xaxis.min,
                                max: i.config.chart.selection.xaxis.max
                            },
                            yaxis: {}
                        })
                    }
            }
        }, {
            key: "drawSelectionRect",
            value: function(i) {
                var a = i.x
                  , s = i.y
                  , r = i.width
                  , n = i.height
                  , o = i.translateX
                  , d = i.translateY
                  , p = this.w
                  , x = this.zoomRect
                  , b = this.selectionRect;
                if (this.dragged || null !== p.globals.selection) {
                    var k = {
                        transform: "translate(" + (void 0 === o ? 0 : o) + ", " + (void 0 === d ? 0 : d) + ")"
                    };
                    p.globals.zoomEnabled && this.dragged && (r < 0 && (r = 1),
                    x.attr({
                        x: a,
                        y: s,
                        width: r,
                        height: n,
                        fill: p.config.chart.zoom.zoomedArea.fill.color,
                        "fill-opacity": p.config.chart.zoom.zoomedArea.fill.opacity,
                        stroke: p.config.chart.zoom.zoomedArea.stroke.color,
                        "stroke-width": p.config.chart.zoom.zoomedArea.stroke.width,
                        "stroke-opacity": p.config.chart.zoom.zoomedArea.stroke.opacity
                    }),
                    U.setAttrs(x.node, k)),
                    p.globals.selectionEnabled && (b.attr({
                        x: a,
                        y: s,
                        width: r > 0 ? r : 0,
                        height: n > 0 ? n : 0,
                        fill: p.config.chart.selection.fill.color,
                        "fill-opacity": p.config.chart.selection.fill.opacity,
                        stroke: p.config.chart.selection.stroke.color,
                        "stroke-width": p.config.chart.selection.stroke.width,
                        "stroke-dasharray": p.config.chart.selection.stroke.dashArray,
                        "stroke-opacity": p.config.chart.selection.stroke.opacity
                    }),
                    U.setAttrs(b.node, k))
                }
            }
        }, {
            key: "hideSelectionRect",
            value: function(i) {
                i && i.attr({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                })
            }
        }, {
            key: "selectionDrawing",
            value: function(i) {
                var k, s = i.zoomtype, r = this.w, n = i.context, o = this.gridRect.getBoundingClientRect(), h = n.startX - 1, d = n.startY, u = !1, p = !1, x = n.clientX - o.left - h, b = n.clientY - o.top - d;
                return Math.abs(x + h) > r.globals.gridWidth ? x = r.globals.gridWidth - h : n.clientX - o.left < 0 && (x = h),
                h > n.clientX - o.left && (u = !0,
                x = Math.abs(x)),
                d > n.clientY - o.top && (p = !0,
                b = Math.abs(b)),
                n.drawSelectionRect(k = "x" === s ? {
                    x: u ? h - x : h,
                    y: 0,
                    width: x,
                    height: r.globals.gridHeight
                } : "y" === s ? {
                    x: 0,
                    y: p ? d - b : d,
                    width: r.globals.gridWidth,
                    height: b
                } : {
                    x: u ? h - x : h,
                    y: p ? d - b : d,
                    width: x,
                    height: b
                }),
                n.selectionDragging("resizing"),
                k
            }
        }, {
            key: "selectionDragging",
            value: function(i, a) {
                var s = this
                  , r = this.w
                  , n = this.xyRatios
                  , o = this.selectionRect
                  , h = 0;
                "resizing" === i && (h = 30);
                var d = function(p) {
                    return parseFloat(o.node.getAttribute(p))
                }
                  , u = {
                    x: d("x"),
                    y: d("y"),
                    width: d("width"),
                    height: d("height")
                };
                r.globals.selection = u,
                "function" == typeof r.config.chart.events.selection && r.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer),
                this.w.globals.selectionResizeTimer = window.setTimeout(function() {
                    var p = s.gridRect.getBoundingClientRect()
                      , x = o.node.getBoundingClientRect()
                      , b = {
                        xaxis: {
                            min: r.globals.xAxisScale.niceMin + (x.left - p.left) * n.xRatio,
                            max: r.globals.xAxisScale.niceMin + (x.right - p.left) * n.xRatio
                        },
                        yaxis: {
                            min: r.globals.yAxisScale[0].niceMin + (p.bottom - x.bottom) * n.yRatio[0],
                            max: r.globals.yAxisScale[0].niceMax - (x.top - p.top) * n.yRatio[0]
                        }
                    };
                    r.config.chart.events.selection(s.ctx, b),
                    r.config.chart.brush.enabled && void 0 !== r.config.chart.events.brushScrolled && r.config.chart.events.brushScrolled(s.ctx, b)
                }, h))
            }
        }, {
            key: "selectionDrawn",
            value: function(i) {
                var s = i.zoomtype
                  , r = this.w
                  , n = i.context
                  , o = this.xyRatios
                  , h = this.ctx.toolbar;
                if (n.startX > n.endX) {
                    var d = n.startX;
                    n.startX = n.endX,
                    n.endX = d
                }
                if (n.startY > n.endY) {
                    var u = n.startY;
                    n.startY = n.endY,
                    n.endY = u
                }
                var p = void 0
                  , x = void 0;
                r.globals.isRangeBar ? (p = r.globals.yAxisScale[0].niceMin + n.startX * o.invertedYRatio,
                x = r.globals.yAxisScale[0].niceMin + n.endX * o.invertedYRatio) : (p = r.globals.xAxisScale.niceMin + n.startX * o.xRatio,
                x = r.globals.xAxisScale.niceMin + n.endX * o.xRatio);
                var b = []
                  , k = [];
                if (r.config.yaxis.forEach(function(R, H) {
                    b.push(r.globals.yAxisScale[H].niceMax - o.yRatio[H] * n.startY),
                    k.push(r.globals.yAxisScale[H].niceMax - o.yRatio[H] * n.endY)
                }),
                n.dragged && (n.dragX > 10 || n.dragY > 10) && p !== x)
                    if (r.globals.zoomEnabled) {
                        var S = D.clone(r.globals.initialConfig.yaxis)
                          , E = D.clone(r.globals.initialConfig.xaxis);
                        if (r.globals.zoomed = !0,
                        r.config.xaxis.convertedCatToNumeric && (p = Math.floor(p),
                        x = Math.floor(x),
                        p < 1 && (p = 1,
                        x = r.globals.dataPoints),
                        x - p < 2 && (x = p + 1)),
                        "xy" !== s && "x" !== s || (E = {
                            min: p,
                            max: x
                        }),
                        "xy" !== s && "y" !== s || S.forEach(function(R, H) {
                            S[H].min = k[H],
                            S[H].max = b[H]
                        }),
                        r.config.chart.zoom.autoScaleYaxis) {
                            var M = new Jt(n.ctx);
                            S = M.autoScaleY(n.ctx, S, {
                                xaxis: E
                            })
                        }
                        if (h) {
                            var l = h.getBeforeZoomRange(E, S);
                            l && (E = l.xaxis ? l.xaxis : E,
                            S = l.yaxis ? l.yaxis : S)
                        }
                        var f = {
                            xaxis: E
                        };
                        r.config.chart.group || (f.yaxis = S),
                        n.ctx.updateHelpers._updateOptions(f, !1, n.w.config.chart.animations.dynamicAnimation.enabled),
                        "function" == typeof r.config.chart.events.zoomed && h.zoomCallback(E, S)
                    } else if (r.globals.selectionEnabled) {
                        var w, _ = null;
                        w = {
                            min: p,
                            max: x
                        },
                        "xy" !== s && "y" !== s || (_ = D.clone(r.config.yaxis)).forEach(function(R, H) {
                            _[H].min = k[H],
                            _[H].max = b[H]
                        }),
                        r.globals.selection = n.selection,
                        "function" == typeof r.config.chart.events.selection && r.config.chart.events.selection(n.ctx, {
                            xaxis: w,
                            yaxis: _
                        })
                    }
            }
        }, {
            key: "panDragging",
            value: function(i) {
                var s = this.w
                  , r = i.context;
                if (void 0 !== s.globals.lastClientPosition.x) {
                    var n = s.globals.lastClientPosition.x - r.clientX
                      , o = s.globals.lastClientPosition.y - r.clientY;
                    Math.abs(n) > Math.abs(o) && n > 0 ? this.moveDirection = "left" : Math.abs(n) > Math.abs(o) && n < 0 ? this.moveDirection = "right" : Math.abs(o) > Math.abs(n) && o > 0 ? this.moveDirection = "up" : Math.abs(o) > Math.abs(n) && o < 0 && (this.moveDirection = "down")
                }
                s.globals.lastClientPosition = {
                    x: r.clientX,
                    y: r.clientY
                },
                s.config.xaxis.convertedCatToNumeric || r.panScrolled(s.globals.isRangeBar ? s.globals.minY : s.globals.minX, s.globals.isRangeBar ? s.globals.maxY : s.globals.maxX)
            }
        }, {
            key: "delayedPanScrolled",
            value: function() {
                var i = this.w
                  , a = i.globals.minX
                  , s = i.globals.maxX
                  , r = (i.globals.maxX - i.globals.minX) / 2;
                "left" === this.moveDirection ? (a = i.globals.minX + r,
                s = i.globals.maxX + r) : "right" === this.moveDirection && (a = i.globals.minX - r,
                s = i.globals.maxX - r),
                a = Math.floor(a),
                s = Math.floor(s),
                this.updateScrolledChart({
                    xaxis: {
                        min: a,
                        max: s
                    }
                }, a, s)
            }
        }, {
            key: "panScrolled",
            value: function(i, a) {
                var s = this.w
                  , r = this.xyRatios
                  , n = D.clone(s.globals.initialConfig.yaxis)
                  , o = r.xRatio
                  , h = s.globals.minX
                  , d = s.globals.maxX;
                s.globals.isRangeBar && (o = r.invertedYRatio,
                h = s.globals.minY,
                d = s.globals.maxY),
                "left" === this.moveDirection ? (i = h + s.globals.gridWidth / 15 * o,
                a = d + s.globals.gridWidth / 15 * o) : "right" === this.moveDirection && (i = h - s.globals.gridWidth / 15 * o,
                a = d - s.globals.gridWidth / 15 * o),
                s.globals.isRangeBar || (i < s.globals.initialMinX || a > s.globals.initialMaxX) && (i = h,
                a = d);
                var u = {
                    min: i,
                    max: a
                };
                s.config.chart.zoom.autoScaleYaxis && (n = new Jt(this.ctx).autoScaleY(this.ctx, n, {
                    xaxis: u
                }));
                var p = {
                    xaxis: {
                        min: i,
                        max: a
                    }
                };
                s.config.chart.group || (p.yaxis = n),
                this.updateScrolledChart(p, i, a)
            }
        }, {
            key: "updateScrolledChart",
            value: function(i, a, s) {
                var r = this.w;
                this.ctx.updateHelpers._updateOptions(i, !1, !1),
                "function" == typeof r.config.chart.events.scrolled && r.config.chart.events.scrolled(this.ctx, {
                    xaxis: {
                        min: a,
                        max: s
                    }
                })
            }
        }]),
        t
    }(mi)
      , Bt = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.ttCtx = e,
            this.ctx = e.ctx
        }
        return Te(C, [{
            key: "getNearestValues",
            value: function(e) {
                var t = e.hoverArea
                  , a = e.clientX
                  , s = e.clientY
                  , r = this.w
                  , n = e.elGrid.getBoundingClientRect()
                  , o = n.width
                  , h = n.height
                  , d = o / (r.globals.dataPoints - 1)
                  , u = h / r.globals.dataPoints
                  , p = this.hasBars();
                !r.globals.comboCharts && !p || r.config.xaxis.convertedCatToNumeric || (d = o / r.globals.dataPoints);
                var x = a - n.left - r.globals.barPadForNumericAxis
                  , b = s - n.top;
                x < 0 || b < 0 || x > o || b > h ? (t.classList.remove("hovering-zoom"),
                t.classList.remove("hovering-pan")) : r.globals.zoomEnabled ? (t.classList.remove("hovering-pan"),
                t.classList.add("hovering-zoom")) : r.globals.panEnabled && (t.classList.remove("hovering-zoom"),
                t.classList.add("hovering-pan"));
                var k = Math.round(x / d)
                  , S = Math.floor(b / u);
                p && !r.config.xaxis.convertedCatToNumeric && (k = Math.ceil(x / d),
                k -= 1);
                var E = null
                  , M = null
                  , l = r.globals.seriesXvalues.map(function(H) {
                    return H.filter(function(B) {
                        return D.isNumber(B)
                    })
                })
                  , f = r.globals.seriesYvalues.map(function(H) {
                    return H.filter(function(B) {
                        return D.isNumber(B)
                    })
                });
                if (r.globals.isXNumeric) {
                    var w = this.ttCtx.getElGrid().getBoundingClientRect()
                      , _ = x * (w.width / o);
                    E = (M = this.closestInMultiArray(_, b * (w.height / h), l, f)).index,
                    k = M.j,
                    null !== E && (k = (M = this.closestInArray(_, l = r.globals.seriesXvalues[E])).index)
                }
                return r.globals.capturedSeriesIndex = null === E ? -1 : E,
                (!k || k < 1) && (k = 0),
                r.globals.capturedDataPointIndex = r.globals.isBarHorizontal ? S : k,
                {
                    capturedSeries: E,
                    j: r.globals.isBarHorizontal ? S : k,
                    hoverX: x,
                    hoverY: b
                }
            }
        }, {
            key: "closestInMultiArray",
            value: function(e, t, i, a) {
                var r = 0
                  , n = null
                  , o = -1;
                this.w.globals.series.length > 1 ? r = this.getFirstActiveXArray(i) : n = 0;
                var d = Math.abs(e - i[r][0]);
                if (i.forEach(function(x) {
                    x.forEach(function(b, k) {
                        var S = Math.abs(e - b);
                        S <= d && (d = S,
                        o = k)
                    })
                }),
                -1 !== o) {
                    var p = Math.abs(t - a[r][o]);
                    n = r,
                    a.forEach(function(x, b) {
                        var k = Math.abs(t - x[o]);
                        k <= p && (p = k,
                        n = b)
                    })
                }
                return {
                    index: n,
                    j: o
                }
            }
        }, {
            key: "getFirstActiveXArray",
            value: function(e) {
                for (var t = this.w, i = 0, a = e.map(function(r, n) {
                    return r.length > 0 ? n : -1
                }), s = 0; s < a.length; s++)
                    if (-1 !== a[s] && -1 === t.globals.collapsedSeriesIndices.indexOf(s) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(s)) {
                        i = a[s];
                        break
                    }
                return i
            }
        }, {
            key: "closestInArray",
            value: function(e, t) {
                for (var a = null, s = Math.abs(e - t[0]), r = 0; r < t.length; r++) {
                    var n = Math.abs(e - t[r]);
                    n < s && (s = n,
                    a = r)
                }
                return {
                    index: a
                }
            }
        }, {
            key: "isXoverlap",
            value: function(e) {
                var t = []
                  , i = this.w.globals.seriesX.filter(function(s) {
                    return void 0 !== s[0]
                });
                if (i.length > 0)
                    for (var a = 0; a < i.length - 1; a++)
                        void 0 !== i[a][e] && void 0 !== i[a + 1][e] && i[a][e] !== i[a + 1][e] && t.push("unEqual");
                return 0 === t.length
            }
        }, {
            key: "isInitialSeriesSameLen",
            value: function() {
                for (var e = !0, t = this.w.globals.initialSeries, i = 0; i < t.length - 1; i++)
                    if (t[i].data.length !== t[i + 1].data.length) {
                        e = !1;
                        break
                    }
                return e
            }
        }, {
            key: "getBarsHeight",
            value: function(e) {
                return J(e).reduce(function(t, i) {
                    return t + i.getBBox().height
                }, 0)
            }
        }, {
            key: "getElMarkers",
            value: function(e) {
                return this.w.globals.dom.baseEl.querySelectorAll("number" == typeof e ? ".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers-wrap > *") : ".apexcharts-series-markers-wrap > *")
            }
        }, {
            key: "getAllMarkers",
            value: function() {
                var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                (e = J(e)).sort(function(i, a) {
                    var s = Number(i.getAttribute("data:realIndex"))
                      , r = Number(a.getAttribute("data:realIndex"));
                    return r < s ? 1 : r > s ? -1 : 0
                });
                var t = [];
                return e.forEach(function(i) {
                    t.push(i.querySelector(".apexcharts-marker"))
                }),
                t
            }
        }, {
            key: "hasMarkers",
            value: function(e) {
                return this.getElMarkers(e).length > 0
            }
        }, {
            key: "getElBars",
            value: function() {
                return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
            }
        }, {
            key: "hasBars",
            value: function() {
                return this.getElBars().length > 0
            }
        }, {
            key: "getHoverMarkerSize",
            value: function(e) {
                var t = this.w
                  , i = t.config.markers.hover.size;
                return void 0 === i && (i = t.globals.markers.size[e] + t.config.markers.hover.sizeOffset),
                i
            }
        }, {
            key: "toggleAllTooltipSeriesGroups",
            value: function(e) {
                var t = this.w
                  , i = this.ttCtx;
                0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                for (var a = i.allTooltipSeriesGroups, s = 0; s < a.length; s++)
                    "enable" === e ? (a[s].classList.add("apexcharts-active"),
                    a[s].style.display = t.config.tooltip.items.display) : (a[s].classList.remove("apexcharts-active"),
                    a[s].style.display = "none")
            }
        }]),
        C
    }()
      , Qt = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.ctx = e.ctx,
            this.ttCtx = e,
            this.tooltipUtil = new Bt(e)
        }
        return Te(C, [{
            key: "drawSeriesTexts",
            value: function(e) {
                var t = e.shared
                  , i = void 0 === t || t
                  , a = e.ttItems
                  , s = e.i
                  , r = void 0 === s ? 0 : s
                  , n = e.j
                  , o = void 0 === n ? null : n
                  , u = e.e
                  , p = this.w;
                void 0 !== p.config.tooltip.custom ? this.handleCustomTooltip({
                    i: r,
                    j: o,
                    y1: e.y1,
                    y2: e.y2,
                    w: p
                }) : this.toggleActiveInactiveSeries(i);
                var x = this.getValuesToPrint({
                    i: r,
                    j: o
                });
                this.printLabels({
                    i: r,
                    j: o,
                    values: x,
                    ttItems: a,
                    shared: i,
                    e: u
                });
                var b = this.ttCtx.getElTooltip();
                this.ttCtx.tooltipRect.ttWidth = b.getBoundingClientRect().width,
                this.ttCtx.tooltipRect.ttHeight = b.getBoundingClientRect().height
            }
        }, {
            key: "printLabels",
            value: function(e) {
                var t, i = this, a = e.i, s = e.j, r = e.values, n = e.ttItems, o = e.shared, h = e.e, d = this.w, u = [], p = function(w) {
                    return d.globals.seriesGoals[w] && d.globals.seriesGoals[w][s] && Array.isArray(d.globals.seriesGoals[w][s])
                }, x = r.xVal, b = r.zVal, k = r.xAxisTTVal, S = "", E = d.globals.colors[a];
                null !== s && d.config.plotOptions.bar.distributed && (E = d.globals.colors[s]);
                for (var M = function(w, _) {
                    var R = i.getFormatters(a);
                    S = i.getSeriesName({
                        fn: R.yLbTitleFormatter,
                        index: a,
                        seriesIndex: a,
                        j: s
                    }),
                    "treemap" === d.config.chart.type && (S = R.yLbTitleFormatter(String(d.config.series[a].data[s].x), {
                        series: d.globals.series,
                        seriesIndex: a,
                        dataPointIndex: s,
                        w: d
                    }));
                    var H = d.config.tooltip.inverseOrder ? _ : w;
                    if (d.globals.axisCharts) {
                        var B = function(me) {
                            var ue, Ee, Ie, rt;
                            return d.globals.isRangeData ? R.yLbFormatter(null === (ue = d.globals.seriesRangeStart) || void 0 === ue || null === (Ee = ue[me]) || void 0 === Ee ? void 0 : Ee[s], {
                                series: d.globals.seriesRangeStart,
                                seriesIndex: me,
                                dataPointIndex: s,
                                w: d
                            }) + " - " + R.yLbFormatter(null === (Ie = d.globals.seriesRangeEnd) || void 0 === Ie || null === (rt = Ie[me]) || void 0 === rt ? void 0 : rt[s], {
                                series: d.globals.seriesRangeEnd,
                                seriesIndex: me,
                                dataPointIndex: s,
                                w: d
                            }) : R.yLbFormatter(d.globals.series[me][s], {
                                series: d.globals.series,
                                seriesIndex: me,
                                dataPointIndex: s,
                                w: d
                            })
                        };
                        if (o)
                            R = i.getFormatters(H),
                            S = i.getSeriesName({
                                fn: R.yLbTitleFormatter,
                                index: H,
                                seriesIndex: a,
                                j: s
                            }),
                            E = d.globals.colors[H],
                            t = B(H),
                            p(H) && (u = d.globals.seriesGoals[H][s].map(function(me) {
                                return {
                                    attrs: me,
                                    val: R.yLbFormatter(me.value, {
                                        seriesIndex: H,
                                        dataPointIndex: s,
                                        w: d
                                    })
                                }
                            }));
                        else {
                            var j, ce = null == h || null === (j = h.target) || void 0 === j ? void 0 : j.getAttribute("fill");
                            ce && (E = -1 !== ce.indexOf("url") ? document.querySelector(ce.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : ce),
                            t = B(a),
                            p(a) && Array.isArray(d.globals.seriesGoals[a][s]) && (u = d.globals.seriesGoals[a][s].map(function(me) {
                                return {
                                    attrs: me,
                                    val: R.yLbFormatter(me.value, {
                                        seriesIndex: a,
                                        dataPointIndex: s,
                                        w: d
                                    })
                                }
                            }))
                        }
                    }
                    null === s && (t = R.yLbFormatter(d.globals.series[a], K(K({}, d), {}, {
                        seriesIndex: a,
                        dataPointIndex: a
                    }))),
                    i.DOMHandling({
                        i: a,
                        t: H,
                        j: s,
                        ttItems: n,
                        values: {
                            val: t,
                            goalVals: u,
                            xVal: x,
                            xAxisTTVal: k,
                            zVal: b
                        },
                        seriesName: S,
                        shared: o,
                        pColor: E
                    })
                }, l = 0, f = d.globals.series.length - 1; l < d.globals.series.length; l++,
                f--)
                    M(l, f)
            }
        }, {
            key: "getFormatters",
            value: function(e) {
                var t, i = this.w, a = i.globals.yLabelFormatters[e];
                return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (a = i.globals.ttVal[e] && i.globals.ttVal[e].formatter,
                t = i.globals.ttVal[e] && i.globals.ttVal[e].title && i.globals.ttVal[e].title.formatter) : (a = i.globals.ttVal.formatter,
                "function" == typeof i.globals.ttVal.title.formatter && (t = i.globals.ttVal.title.formatter)) : t = i.config.tooltip.y.title.formatter,
                "function" != typeof a && (a = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(s) {
                    return s
                }
                ),
                "function" != typeof t && (t = function(s) {
                    return s
                }
                ),
                {
                    yLbFormatter: a,
                    yLbTitleFormatter: t
                }
            }
        }, {
            key: "getSeriesName",
            value: function(e) {
                var a = e.seriesIndex
                  , s = e.j
                  , r = this.w;
                return (0,
                e.fn)(String(r.globals.seriesNames[e.index]), {
                    series: r.globals.series,
                    seriesIndex: a,
                    dataPointIndex: s,
                    w: r
                })
            }
        }, {
            key: "DOMHandling",
            value: function(e) {
                var t = e.t
                  , i = e.j
                  , a = e.ttItems
                  , s = e.values
                  , r = e.seriesName
                  , n = e.shared
                  , o = e.pColor
                  , h = this.w
                  , d = this.ttCtx
                  , u = s.val
                  , p = s.goalVals
                  , x = s.xVal
                  , b = s.xAxisTTVal
                  , k = s.zVal
                  , S = null;
                S = a[t].children,
                h.config.tooltip.fillSeriesColor && (a[t].style.backgroundColor = o,
                S[0].style.display = "none"),
                d.showTooltipTitle && (null === d.tooltipTitle && (d.tooltipTitle = h.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")),
                d.tooltipTitle.innerHTML = x),
                d.isXAxisTooltipEnabled && (d.xaxisTooltipText.innerHTML = "" !== b ? b : x);
                var E = a[t].querySelector(".apexcharts-tooltip-text-y-label");
                E && (E.innerHTML = r || "");
                var M = a[t].querySelector(".apexcharts-tooltip-text-y-value");
                M && (M.innerHTML = void 0 !== u ? u : ""),
                S[0] && S[0].classList.contains("apexcharts-tooltip-marker") && (h.config.tooltip.marker.fillColors && Array.isArray(h.config.tooltip.marker.fillColors) && (o = h.config.tooltip.marker.fillColors[t]),
                S[0].style.backgroundColor = o),
                h.config.tooltip.marker.show || (S[0].style.display = "none");
                var l = a[t].querySelector(".apexcharts-tooltip-text-goals-label")
                  , f = a[t].querySelector(".apexcharts-tooltip-text-goals-value");
                if (p.length && h.globals.seriesGoals[t]) {
                    var w = function() {
                        var _ = "<div >"
                          , R = "<div>";
                        p.forEach(function(H, B) {
                            _ += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(H.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(H.attrs.name, "</div>"),
                            R += "<div>".concat(H.val, "</div>")
                        }),
                        l.innerHTML = _ + "</div>",
                        f.innerHTML = R + "</div>"
                    };
                    n ? h.globals.seriesGoals[t][i] && Array.isArray(h.globals.seriesGoals[t][i]) ? w() : (l.innerHTML = "",
                    f.innerHTML = "") : w()
                } else
                    l.innerHTML = "",
                    f.innerHTML = "";
                null !== k && (a[t].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = h.config.tooltip.z.title,
                a[t].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== k ? k : ""),
                n && S[0] && (S[0].parentNode.style.display = null == u || h.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || h.globals.collapsedSeriesIndices.indexOf(t) > -1 ? "none" : h.config.tooltip.items.display)
            }
        }, {
            key: "toggleActiveInactiveSeries",
            value: function(e) {
                var t = this.w;
                if (e)
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                else {
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                    var i = t.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                    i && (i.classList.add("apexcharts-active"),
                    i.style.display = t.config.tooltip.items.display)
                }
            }
        }, {
            key: "getValuesToPrint",
            value: function(e) {
                var t = e.i
                  , i = e.j
                  , a = this.w
                  , s = this.ctx.series.filteredSeriesX()
                  , r = ""
                  , n = ""
                  , o = null
                  , h = null
                  , d = {
                    series: a.globals.series,
                    seriesIndex: t,
                    dataPointIndex: i,
                    w: a
                }
                  , u = a.globals.ttZFormatter;
                null === i ? h = a.globals.series[t] : a.globals.isXNumeric && "treemap" !== a.config.chart.type ? (r = s[t][i],
                0 === s[t].length && (r = s[this.tooltipUtil.getFirstActiveXArray(s)][i])) : r = void 0 !== a.globals.labels[i] ? a.globals.labels[i] : "";
                var p = r;
                return r = a.globals.isXNumeric && "datetime" === a.config.xaxis.type ? new At(this.ctx).xLabelFormat(a.globals.ttKeyFormatter, p, p, {
                    i: void 0,
                    dateFormatter: new We(this.ctx).formatDate,
                    w: this.w
                }) : a.globals.isBarHorizontal ? a.globals.yLabelFormatters[0](p, d) : a.globals.xLabelFormatter(p, d),
                void 0 !== a.config.tooltip.x.formatter && (r = a.globals.ttKeyFormatter(p, d)),
                a.globals.seriesZ.length > 0 && a.globals.seriesZ[t].length > 0 && (o = u(a.globals.seriesZ[t][i], a)),
                n = "function" == typeof a.config.xaxis.tooltip.formatter ? a.globals.xaxisTooltipFormatter(p, d) : r,
                {
                    val: Array.isArray(h) ? h.join(" ") : h,
                    xVal: Array.isArray(r) ? r.join(" ") : r,
                    xAxisTTVal: Array.isArray(n) ? n.join(" ") : n,
                    zVal: o
                }
            }
        }, {
            key: "handleCustomTooltip",
            value: function(e) {
                var t = e.i
                  , i = e.j
                  , a = e.y1
                  , s = e.y2
                  , r = e.w
                  , n = this.ttCtx.getElTooltip()
                  , o = r.config.tooltip.custom;
                Array.isArray(o) && o[t] && (o = o[t]),
                n.innerHTML = o({
                    ctx: this.ctx,
                    series: r.globals.series,
                    seriesIndex: t,
                    dataPointIndex: i,
                    y1: a,
                    y2: s,
                    w: r
                })
            }
        }]),
        C
    }()
      , ei = function() {
        function C(e) {
            Q(this, C),
            this.ttCtx = e,
            this.ctx = e.ctx,
            this.w = e.w
        }
        return Te(C, [{
            key: "moveXCrosshairs",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , i = this.ttCtx
                  , a = this.w
                  , s = i.getElXCrosshairs()
                  , r = e - i.xcrosshairsWidth / 2
                  , n = a.globals.labels.slice().length;
                if (null !== t && (r = a.globals.gridWidth / n * t),
                null === s || a.globals.isBarHorizontal || (s.setAttribute("x", r),
                s.setAttribute("x1", r),
                s.setAttribute("x2", r),
                s.setAttribute("y2", a.globals.gridHeight),
                s.classList.add("apexcharts-active")),
                r < 0 && (r = 0),
                r > a.globals.gridWidth && (r = a.globals.gridWidth),
                i.isXAxisTooltipEnabled) {
                    var o = r;
                    "tickWidth" !== a.config.xaxis.crosshairs.width && "barWidth" !== a.config.xaxis.crosshairs.width || (o = r + i.xcrosshairsWidth / 2),
                    this.moveXAxisTooltip(o)
                }
            }
        }, {
            key: "moveYCrosshairs",
            value: function(e) {
                var t = this.ttCtx;
                null !== t.ycrosshairs && U.setAttrs(t.ycrosshairs, {
                    y1: e,
                    y2: e
                }),
                null !== t.ycrosshairsHidden && U.setAttrs(t.ycrosshairsHidden, {
                    y1: e,
                    y2: e
                })
            }
        }, {
            key: "moveXAxisTooltip",
            value: function(e) {
                var t = this.w
                  , i = this.ttCtx;
                if (null !== i.xaxisTooltip && 0 !== i.xcrosshairsWidth) {
                    i.xaxisTooltip.classList.add("apexcharts-active");
                    var s, a = i.xaxisOffY + t.config.xaxis.tooltip.offsetY + t.globals.translateY + 1 + t.config.xaxis.offsetY;
                    e -= i.xaxisTooltip.getBoundingClientRect().width / 2,
                    isNaN(e) || (e += t.globals.translateX,
                    s = new U(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML),
                    i.xaxisTooltipText.style.minWidth = s.width + "px",
                    i.xaxisTooltip.style.left = e + "px",
                    i.xaxisTooltip.style.top = a + "px")
                }
            }
        }, {
            key: "moveYAxisTooltip",
            value: function(e) {
                var t = this.w
                  , i = this.ttCtx;
                null === i.yaxisTTEls && (i.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                var a = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10)
                  , s = t.globals.translateY + a
                  , r = i.yaxisTTEls[e].getBoundingClientRect().height
                  , n = t.globals.translateYAxisX[e] - 2;
                t.config.yaxis[e].opposite && (n -= 26),
                s -= r / 2,
                -1 === t.globals.ignoreYAxisIndexes.indexOf(e) ? (i.yaxisTTEls[e].classList.add("apexcharts-active"),
                i.yaxisTTEls[e].style.top = s + "px",
                i.yaxisTTEls[e].style.left = n + t.config.yaxis[e].tooltip.offsetX + "px") : i.yaxisTTEls[e].classList.remove("apexcharts-active")
            }
        }, {
            key: "moveTooltip",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , a = this.w
                  , s = this.ttCtx
                  , r = s.getElTooltip()
                  , n = s.tooltipRect
                  , o = null !== i ? parseFloat(i) : 1
                  , h = parseFloat(e) + o + 5
                  , d = parseFloat(t) + o / 2;
                if (h > a.globals.gridWidth / 2 && (h = h - n.ttWidth - o - 10),
                h > a.globals.gridWidth - n.ttWidth - 10 && (h = a.globals.gridWidth - n.ttWidth),
                h < -20 && (h = -20),
                a.config.tooltip.followCursor) {
                    var u = s.getElGrid().getBoundingClientRect();
                    (h = s.e.clientX - u.left) > a.globals.gridWidth / 2 && (h -= s.tooltipRect.ttWidth),
                    (d = s.e.clientY + a.globals.translateY - u.top) > a.globals.gridHeight / 2 && (d -= s.tooltipRect.ttHeight)
                } else
                    a.globals.isBarHorizontal || n.ttHeight / 2 + d > a.globals.gridHeight && (d = a.globals.gridHeight - n.ttHeight + a.globals.translateY);
                isNaN(h) || (r.style.left = (h += a.globals.translateX) + "px",
                r.style.top = d + "px")
            }
        }, {
            key: "moveMarkers",
            value: function(e, t) {
                var i = this.w
                  , a = this.ttCtx;
                if (i.globals.markers.size[e] > 0)
                    for (var s = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-marker")), r = 0; r < s.length; r++)
                        parseInt(s[r].getAttribute("rel"), 10) === t && (a.marker.resetPointsSize(),
                        a.marker.enlargeCurrentPoint(t, s[r]));
                else
                    a.marker.resetPointsSize(),
                    this.moveDynamicPointOnHover(t, e)
            }
        }, {
            key: "moveDynamicPointOnHover",
            value: function(e, t) {
                var i, a, s = this.w, r = this.ttCtx, n = s.globals.pointsArray, o = r.tooltipUtil.getHoverMarkerSize(t), h = s.config.series[t].type;
                if (!h || "column" !== h && "candlestick" !== h && "boxPlot" !== h) {
                    i = n[t][e][0],
                    a = n[t][e][1] ? n[t][e][1] : 0;
                    var d = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers circle"));
                    d && a < s.globals.gridHeight && a > 0 && (d.setAttribute("r", o),
                    d.setAttribute("cx", i),
                    d.setAttribute("cy", a)),
                    this.moveXCrosshairs(i),
                    r.fixedTooltip || this.moveTooltip(i, a, o)
                }
            }
        }, {
            key: "moveDynamicPointsOnHover",
            value: function(e) {
                var t, i = this.ttCtx, a = i.w, s = 0, r = 0, n = a.globals.pointsArray;
                t = new Lt(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
                var o = i.tooltipUtil.getHoverMarkerSize(t);
                n[t] && (s = n[t][e][0],
                r = n[t][e][1]);
                var h = i.tooltipUtil.getAllMarkers();
                if (null !== h)
                    for (var d = 0; d < a.globals.series.length; d++) {
                        var u = n[d];
                        if (a.globals.comboCharts && void 0 === u && h.splice(d, 0, null),
                        u && u.length) {
                            var p = n[d][e][1];
                            h[d].setAttribute("cx", s),
                            "rangeArea" !== a.config.chart.type || a.globals.comboCharts || (p -= Math.abs(p - n[d][e + a.globals.series[d].length][1]) / 2),
                            null !== p && !isNaN(p) && p < a.globals.gridHeight + o && p + o > 0 ? (h[d] && h[d].setAttribute("r", o),
                            h[d] && h[d].setAttribute("cy", p)) : h[d] && h[d].setAttribute("r", 0)
                        }
                    }
                this.moveXCrosshairs(s),
                i.fixedTooltip || this.moveTooltip(s, r || a.globals.gridHeight, o)
            }
        }, {
            key: "moveStickyTooltipOverBars",
            value: function(e, t) {
                var i = this.w
                  , a = this.ttCtx
                  , s = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length
                  , r = s >= 2 && s % 2 == 0 ? Math.floor(s / 2) : Math.floor(s / 2) + 1;
                i.globals.isBarHorizontal && (r = new Lt(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
                var n = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r, "'] path[j='").concat(e, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e, "']"));
                n || "number" != typeof t || (n = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "']")));
                var o = n ? parseFloat(n.getAttribute("cx")) : 0
                  , h = n ? parseFloat(n.getAttribute("cy")) : 0
                  , d = n ? parseFloat(n.getAttribute("barWidth")) : 0
                  , u = a.getElGrid().getBoundingClientRect()
                  , p = n && (n.classList.contains("apexcharts-candlestick-area") || n.classList.contains("apexcharts-boxPlot-area"));
                i.globals.isXNumeric ? (n && !p && (o -= s % 2 != 0 ? d / 2 : 0),
                n && p && i.globals.comboCharts && (o -= d / 2)) : i.globals.isBarHorizontal || (o = a.xAxisTicksPositions[e - 1] + a.dataPointsDividedWidth / 2,
                isNaN(o) && (o = a.xAxisTicksPositions[e] - a.dataPointsDividedWidth / 2)),
                i.globals.isBarHorizontal ? h -= a.tooltipRect.ttHeight : i.config.tooltip.followCursor ? h = a.e.clientY - u.top - a.tooltipRect.ttHeight / 2 : h + a.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (h = i.globals.gridHeight),
                i.globals.isBarHorizontal || this.moveXCrosshairs(o),
                a.fixedTooltip || this.moveTooltip(o, h || i.globals.gridHeight)
            }
        }]),
        C
    }()
      , sa = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.ttCtx = e,
            this.ctx = e.ctx,
            this.tooltipPosition = new ei(e)
        }
        return Te(C, [{
            key: "drawDynamicPoints",
            value: function() {
                var e = this.w
                  , t = new U(this.ctx)
                  , i = new ye(this.ctx)
                  , a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                a = J(a),
                e.config.chart.stacked && a.sort(function(u, p) {
                    return parseFloat(u.getAttribute("data:realIndex")) - parseFloat(p.getAttribute("data:realIndex"))
                });
                for (var s = 0; s < a.length; s++) {
                    var r = a[s].querySelector(".apexcharts-series-markers-wrap");
                    if (null !== r) {
                        var n = void 0
                          , o = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                        "line" !== e.config.chart.type && "area" !== e.config.chart.type || e.globals.comboCharts || e.config.tooltip.intersect || (o += " no-pointer-events");
                        var h = i.getMarkerConfig({
                            cssClass: o,
                            seriesIndex: Number(r.getAttribute("data:realIndex"))
                        });
                        (n = t.drawMarker(0, 0, h)).node.setAttribute("default-marker-size", 0);
                        var d = document.createElementNS(e.globals.SVGNS, "g");
                        d.classList.add("apexcharts-series-markers"),
                        d.appendChild(n.node),
                        r.appendChild(d)
                    }
                }
            }
        }, {
            key: "enlargeCurrentPoint",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , s = this.w;
                "bubble" !== s.config.chart.type && this.newPointSize(e, t);
                var r = t.getAttribute("cx")
                  , n = t.getAttribute("cy");
                if (null !== i && null !== a && (r = i,
                n = a),
                this.tooltipPosition.moveXCrosshairs(r),
                !this.fixedTooltip) {
                    if ("radar" === s.config.chart.type) {
                        var o = this.ttCtx.getElGrid().getBoundingClientRect();
                        r = this.ttCtx.e.clientX - o.left
                    }
                    this.tooltipPosition.moveTooltip(r, n, s.config.markers.hover.size)
                }
            }
        }, {
            key: "enlargePoints",
            value: function(e) {
                for (var t = this.w, i = this, a = this.ttCtx, s = e, r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = t.config.markers.hover.size, o = 0; o < r.length; o++) {
                    var h = r[o].getAttribute("rel")
                      , d = r[o].getAttribute("index");
                    if (void 0 === n && (n = t.globals.markers.size[d] + t.config.markers.hover.sizeOffset),
                    s === parseInt(h, 10)) {
                        i.newPointSize(s, r[o]);
                        var u = r[o].getAttribute("cx")
                          , p = r[o].getAttribute("cy");
                        i.tooltipPosition.moveXCrosshairs(u),
                        a.fixedTooltip || i.tooltipPosition.moveTooltip(u, p, n)
                    } else
                        i.oldPointSize(r[o])
                }
            }
        }, {
            key: "newPointSize",
            value: function(e, t) {
                var i = this.w
                  , a = i.config.markers.hover.size
                  , s = 0 === e ? t.parentNode.firstChild : t.parentNode.lastChild;
                if ("0" !== s.getAttribute("default-marker-size")) {
                    var r = parseInt(s.getAttribute("index"), 10);
                    void 0 === a && (a = i.globals.markers.size[r] + i.config.markers.hover.sizeOffset),
                    a < 0 && (a = 0),
                    s.setAttribute("r", a)
                }
            }
        }, {
            key: "oldPointSize",
            value: function(e) {
                var t = parseFloat(e.getAttribute("default-marker-size"));
                e.setAttribute("r", t)
            }
        }, {
            key: "resetPointsSize",
            value: function() {
                for (var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t = 0; t < e.length; t++) {
                    var i = parseFloat(e[t].getAttribute("default-marker-size"));
                    D.isNumber(i) && i >= 0 ? e[t].setAttribute("r", i) : e[t].setAttribute("r", 0)
                }
            }
        }]),
        C
    }()
      , xi = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w;
            var t = this.w;
            this.ttCtx = e,
            this.isVerticalGroupedRangeBar = !t.globals.isBarHorizontal && "rangeBar" === t.config.chart.type && t.config.plotOptions.bar.rangeBarGroupRows
        }
        return Te(C, [{
            key: "getAttr",
            value: function(e, t) {
                return parseFloat(e.target.getAttribute(t))
            }
        }, {
            key: "handleHeatTreeTooltip",
            value: function(e) {
                var t = e.e
                  , i = e.opt
                  , a = e.x
                  , s = e.y
                  , n = this.ttCtx
                  , o = this.w;
                if (t.target.classList.contains("apexcharts-".concat(e.type, "-rect"))) {
                    var h = this.getAttr(t, "i")
                      , d = this.getAttr(t, "j")
                      , u = this.getAttr(t, "cx")
                      , p = this.getAttr(t, "cy")
                      , x = this.getAttr(t, "width")
                      , b = this.getAttr(t, "height");
                    if (n.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: h,
                        j: d,
                        shared: !1,
                        e: t
                    }),
                    o.globals.capturedSeriesIndex = h,
                    o.globals.capturedDataPointIndex = d,
                    a = u + n.tooltipRect.ttWidth / 2 + x,
                    s = p + n.tooltipRect.ttHeight / 2 - b / 2,
                    n.tooltipPosition.moveXCrosshairs(u + x / 2),
                    a > o.globals.gridWidth / 2 && (a = u - n.tooltipRect.ttWidth / 2 + x),
                    n.w.config.tooltip.followCursor) {
                        var k = o.globals.dom.elWrap.getBoundingClientRect();
                        a = o.globals.clientX - k.left - (a > o.globals.gridWidth / 2 ? n.tooltipRect.ttWidth : 0),
                        s = o.globals.clientY - k.top - (s > o.globals.gridHeight / 2 ? n.tooltipRect.ttHeight : 0)
                    }
                }
                return {
                    x: a,
                    y: s
                }
            }
        }, {
            key: "handleMarkerTooltip",
            value: function(e) {
                var t, i, a = e.e, s = e.opt, r = e.x, n = e.y, o = this.w, h = this.ttCtx;
                if (a.target.classList.contains("apexcharts-marker")) {
                    var d = parseInt(s.paths.getAttribute("cx"), 10)
                      , u = parseInt(s.paths.getAttribute("cy"), 10)
                      , p = parseFloat(s.paths.getAttribute("val"));
                    if (i = parseInt(s.paths.getAttribute("rel"), 10),
                    t = parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1,
                    h.intersect) {
                        var x = D.findAncestor(s.paths, "apexcharts-series");
                        x && (t = parseInt(x.getAttribute("data:realIndex"), 10))
                    }
                    if (h.tooltipLabels.drawSeriesTexts({
                        ttItems: s.ttItems,
                        i: t,
                        j: i,
                        shared: !h.showOnIntersect && o.config.tooltip.shared,
                        e: a
                    }),
                    "mouseup" === a.type && h.markerClick(a, t, i),
                    o.globals.capturedSeriesIndex = t,
                    o.globals.capturedDataPointIndex = i,
                    r = d,
                    n = u + o.globals.translateY - 1.4 * h.tooltipRect.ttHeight,
                    h.w.config.tooltip.followCursor) {
                        var b = h.getElGrid().getBoundingClientRect();
                        n = h.e.clientY + o.globals.translateY - b.top
                    }
                    p < 0 && (n = u),
                    h.marker.enlargeCurrentPoint(i, s.paths, r, n)
                }
                return {
                    x: r,
                    y: n
                }
            }
        }, {
            key: "handleBarTooltip",
            value: function(e) {
                var t, i, a = e.e, s = e.opt, r = this.w, n = this.ttCtx, o = n.getElTooltip(), h = 0, d = 0, u = 0, p = this.getBarTooltipXY({
                    e: a,
                    opt: s
                }), x = p.barHeight, b = p.j;
                r.globals.capturedSeriesIndex = t = p.i,
                r.globals.capturedDataPointIndex = b,
                r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (d = p.x,
                u = p.y,
                i = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[t] : r.config.stroke.width,
                h = d) : r.globals.comboCharts || r.config.tooltip.shared || (h /= 2),
                isNaN(u) && (u = r.globals.svgHeight - n.tooltipRect.ttHeight);
                var k = parseInt(s.paths.parentNode.getAttribute("data:realIndex"), 10)
                  , S = r.globals.isMultipleYAxis ? r.config.yaxis[k] && r.config.yaxis[k].reversed : r.config.yaxis[0].reversed;
                if (d + n.tooltipRect.ttWidth > r.globals.gridWidth && !S ? d -= n.tooltipRect.ttWidth : d < 0 && (d = 0),
                n.w.config.tooltip.followCursor) {
                    var E = n.getElGrid().getBoundingClientRect();
                    u = n.e.clientY - E.top
                }
                null === n.tooltip && (n.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")),
                r.config.tooltip.shared || n.tooltipPosition.moveXCrosshairs(r.globals.comboBarCount > 0 ? h + i / 2 : h),
                !n.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && n.tooltipUtil.hasBars()) && (S && (d -= n.tooltipRect.ttWidth) < 0 && (d = 0),
                !S || r.globals.isBarHorizontal && n.tooltipUtil.hasBars() || (u = u + x - 2 * (r.globals.series[t][b] < 0 ? x : 0)),
                u = u + r.globals.translateY - n.tooltipRect.ttHeight / 2,
                o.style.left = d + r.globals.translateX + "px",
                o.style.top = u + "px")
            }
        }, {
            key: "getBarTooltipXY",
            value: function(e) {
                var t = this
                  , i = e.e
                  , a = e.opt
                  , s = this.w
                  , r = null
                  , n = this.ttCtx
                  , o = 0
                  , h = 0
                  , d = 0
                  , u = 0
                  , p = 0
                  , x = i.target.classList;
                if (x.contains("apexcharts-bar-area") || x.contains("apexcharts-candlestick-area") || x.contains("apexcharts-boxPlot-area") || x.contains("apexcharts-rangebar-area")) {
                    var b = i.target
                      , k = b.getBoundingClientRect()
                      , S = a.elGrid.getBoundingClientRect()
                      , E = k.height;
                    p = k.height;
                    var M = k.width
                      , l = parseInt(b.getAttribute("cx"), 10)
                      , f = parseInt(b.getAttribute("cy"), 10);
                    u = parseFloat(b.getAttribute("barWidth"));
                    var w = "touchmove" === i.type ? i.touches[0].clientX : i.clientX;
                    r = parseInt(b.getAttribute("j"), 10),
                    o = parseInt(b.parentNode.getAttribute("rel"), 10) - 1;
                    var _ = b.getAttribute("data-range-y1")
                      , R = b.getAttribute("data-range-y2");
                    s.globals.comboCharts && (o = parseInt(b.parentNode.getAttribute("data:realIndex"), 10));
                    var H = function(j) {
                        return s.globals.isXNumeric ? l - M / 2 : t.isVerticalGroupedRangeBar ? l + M / 2 : l - n.dataPointsDividedWidth + M / 2
                    }
                      , B = function() {
                        return f - n.dataPointsDividedHeight + E / 2 - n.tooltipRect.ttHeight / 2
                    };
                    n.tooltipLabels.drawSeriesTexts({
                        ttItems: a.ttItems,
                        i: o,
                        j: r,
                        y1: _ ? parseInt(_, 10) : null,
                        y2: R ? parseInt(R, 10) : null,
                        shared: !n.showOnIntersect && s.config.tooltip.shared,
                        e: i
                    }),
                    s.config.tooltip.followCursor ? s.globals.isBarHorizontal ? (h = w - S.left + 15,
                    d = B()) : (h = H(),
                    d = i.clientY - S.top - n.tooltipRect.ttHeight / 2 - 15) : s.globals.isBarHorizontal ? ((h = l) < n.xyRatios.baseLineInvertedY && (h = l - n.tooltipRect.ttWidth),
                    d = B()) : (h = H(),
                    d = f)
                }
                return {
                    x: h,
                    y: d,
                    barHeight: p,
                    barWidth: u,
                    i: o,
                    j: r
                }
            }
        }]),
        C
    }()
      , I = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.ttCtx = e
        }
        return Te(C, [{
            key: "drawXaxisTooltip",
            value: function() {
                var e = this.w
                  , t = this.ttCtx
                  , i = "bottom" === e.config.xaxis.position;
                t.xaxisOffY = i ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3;
                var a = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top"
                  , s = e.globals.dom.elWrap;
                t.isXAxisTooltipEnabled && null === e.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (t.xaxisTooltip = document.createElement("div"),
                t.xaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + e.config.tooltip.theme),
                s.appendChild(t.xaxisTooltip),
                t.xaxisTooltipText = document.createElement("div"),
                t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"),
                t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily,
                t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize,
                t.xaxisTooltip.appendChild(t.xaxisTooltipText))
            }
        }, {
            key: "drawYaxisTooltip",
            value: function() {
                for (var e = this.w, t = this.ttCtx, i = function(s) {
                    var r = e.config.yaxis[s].opposite || e.config.yaxis[s].crosshairs.opposite;
                    t.yaxisOffX = r ? e.globals.gridWidth + 1 : 1;
                    var n = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(s, r ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                    e.globals.yAxisSameScaleIndices.map(function(h, d) {
                        h.map(function(u, p) {
                            p === s && (n += e.config.yaxis[p].show ? " " : " apexcharts-yaxistooltip-hidden")
                        })
                    });
                    var o = e.globals.dom.elWrap;
                    null === e.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(s)) && (t.yaxisTooltip = document.createElement("div"),
                    t.yaxisTooltip.setAttribute("class", n + " apexcharts-theme-" + e.config.tooltip.theme),
                    o.appendChild(t.yaxisTooltip),
                    0 === s && (t.yaxisTooltipText = []),
                    t.yaxisTooltipText[s] = document.createElement("div"),
                    t.yaxisTooltipText[s].classList.add("apexcharts-yaxistooltip-text"),
                    t.yaxisTooltip.appendChild(t.yaxisTooltipText[s]))
                }, a = 0; a < e.config.yaxis.length; a++)
                    i(a)
            }
        }, {
            key: "setXCrosshairWidth",
            value: function() {
                var e = this.w
                  , t = this.ttCtx
                  , i = t.getElXCrosshairs();
                if (t.xcrosshairsWidth = parseInt(e.config.xaxis.crosshairs.width, 10),
                e.globals.comboCharts) {
                    var a = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== a && "barWidth" === e.config.xaxis.crosshairs.width) {
                        var s = parseFloat(a.getAttribute("barWidth"));
                        t.xcrosshairsWidth = s
                    } else
                        "tickWidth" === e.config.xaxis.crosshairs.width && (t.xcrosshairsWidth = e.globals.gridWidth / e.globals.labels.length)
                } else if ("tickWidth" === e.config.xaxis.crosshairs.width)
                    t.xcrosshairsWidth = e.globals.gridWidth / e.globals.labels.length;
                else if ("barWidth" === e.config.xaxis.crosshairs.width) {
                    var o = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== o) {
                        var h = parseFloat(o.getAttribute("barWidth"));
                        t.xcrosshairsWidth = h
                    } else
                        t.xcrosshairsWidth = 1
                }
                e.globals.isBarHorizontal && (t.xcrosshairsWidth = 0),
                null !== i && t.xcrosshairsWidth > 0 && i.setAttribute("width", t.xcrosshairsWidth)
            }
        }, {
            key: "handleYCrosshair",
            value: function() {
                var e = this.w
                  , t = this.ttCtx;
                t.ycrosshairs = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"),
                t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
            }
        }, {
            key: "drawYaxisTooltipText",
            value: function(e, t, i) {
                var a = this.ttCtx
                  , s = this.w
                  , r = s.globals.yLabelFormatters[e];
                if (a.yaxisTooltips[e]) {
                    var n = a.getElGrid().getBoundingClientRect()
                      , d = s.globals.minYArr[e] + (s.globals.maxYArr[e] - s.globals.minYArr[e] - (t - n.top) * i.yRatio[e]);
                    a.tooltipPosition.moveYCrosshairs(t - n.top),
                    a.yaxisTooltipText[e].innerHTML = r(d),
                    a.tooltipPosition.moveYAxisTooltip(e)
                }
            }
        }]),
        C
    }()
      , X = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.tConfig = t.config.tooltip,
            this.tooltipUtil = new Bt(this),
            this.tooltipLabels = new Qt(this),
            this.tooltipPosition = new ei(this),
            this.marker = new sa(this),
            this.intersect = new xi(this),
            this.axesTooltip = new I(this),
            this.showOnIntersect = this.tConfig.intersect,
            this.showTooltipTitle = this.tConfig.x.show,
            this.fixedTooltip = this.tConfig.fixed.enabled,
            this.xaxisTooltip = null,
            this.yaxisTTEls = null,
            this.isBarShared = !t.globals.isBarHorizontal && this.tConfig.shared,
            this.lastHoverTime = Date.now()
        }
        return Te(C, [{
            key: "getElTooltip",
            value: function(e) {
                return e || (e = this),
                e.w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
            }
        }, {
            key: "getElXCrosshairs",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
            }
        }, {
            key: "getElGrid",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
            }
        }, {
            key: "drawTooltip",
            value: function(e) {
                var t = this.w;
                this.xyRatios = e,
                this.isXAxisTooltipEnabled = t.config.xaxis.tooltip.enabled && t.globals.axisCharts,
                this.yaxisTooltips = t.config.yaxis.map(function(r, n) {
                    return !!(r.show && r.tooltip.enabled && t.globals.axisCharts)
                }),
                this.allTooltipSeriesGroups = [],
                t.globals.axisCharts || (this.showTooltipTitle = !1);
                var i = document.createElement("div");
                if (i.classList.add("apexcharts-tooltip"),
                t.config.tooltip.cssClass && i.classList.add(t.config.tooltip.cssClass),
                i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)),
                t.globals.dom.elWrap.appendChild(i),
                t.globals.axisCharts) {
                    this.axesTooltip.drawXaxisTooltip(),
                    this.axesTooltip.drawYaxisTooltip(),
                    this.axesTooltip.setXCrosshairWidth(),
                    this.axesTooltip.handleYCrosshair();
                    var a = new Ot(this.ctx);
                    this.xAxisTicksPositions = a.getXAxisTicksPositions()
                }
                if (!t.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== t.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0),
                0 !== t.config.markers.size && 0 !== t.globals.markers.largestSize || this.marker.drawDynamicPoints(this),
                t.globals.collapsedSeries.length !== t.globals.series.length) {
                    this.dataPointsDividedHeight = t.globals.gridHeight / t.globals.dataPoints,
                    this.dataPointsDividedWidth = t.globals.gridWidth / t.globals.dataPoints,
                    this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"),
                    this.tooltipTitle.classList.add("apexcharts-tooltip-title"),
                    this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily,
                    this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize,
                    i.appendChild(this.tooltipTitle));
                    var s = t.globals.series.length;
                    (t.globals.xyCharts || t.globals.comboCharts) && this.tConfig.shared && (s = this.showOnIntersect ? 1 : t.globals.series.length),
                    this.legendLabels = t.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"),
                    this.ttItems = this.createTTElements(s),
                    this.addSVGEvents()
                }
            }
        }, {
            key: "createTTElements",
            value: function(e) {
                for (var t = this, i = this.w, a = [], s = this.getElTooltip(), r = function(o) {
                    var h = document.createElement("div");
                    h.classList.add("apexcharts-tooltip-series-group"),
                    h.style.order = i.config.tooltip.inverseOrder ? e - o : o + 1,
                    t.tConfig.shared && t.tConfig.enabledOnSeries && Array.isArray(t.tConfig.enabledOnSeries) && t.tConfig.enabledOnSeries.indexOf(o) < 0 && h.classList.add("apexcharts-tooltip-series-group-hidden");
                    var d = document.createElement("span");
                    d.classList.add("apexcharts-tooltip-marker"),
                    d.style.backgroundColor = i.globals.colors[o],
                    h.appendChild(d);
                    var u = document.createElement("div");
                    u.classList.add("apexcharts-tooltip-text"),
                    u.style.fontFamily = t.tConfig.style.fontFamily || i.config.chart.fontFamily,
                    u.style.fontSize = t.tConfig.style.fontSize,
                    ["y", "goals", "z"].forEach(function(p) {
                        var x = document.createElement("div");
                        x.classList.add("apexcharts-tooltip-".concat(p, "-group"));
                        var b = document.createElement("span");
                        b.classList.add("apexcharts-tooltip-text-".concat(p, "-label")),
                        x.appendChild(b);
                        var k = document.createElement("span");
                        k.classList.add("apexcharts-tooltip-text-".concat(p, "-value")),
                        x.appendChild(k),
                        u.appendChild(x)
                    }),
                    h.appendChild(u),
                    s.appendChild(h),
                    a.push(h)
                }, n = 0; n < e; n++)
                    r(n);
                return a
            }
        }, {
            key: "addSVGEvents",
            value: function() {
                var e = this.w
                  , t = e.config.chart.type
                  , i = this.getElTooltip()
                  , a = !("bar" !== t && "candlestick" !== t && "boxPlot" !== t && "rangeBar" !== t)
                  , s = "area" === t || "line" === t || "scatter" === t || "bubble" === t || "radar" === t
                  , r = e.globals.dom.Paper.node
                  , n = this.getElGrid();
                n && (this.seriesBound = n.getBoundingClientRect());
                var o, h = [], d = [], u = {
                    hoverArea: r,
                    elGrid: n,
                    tooltipEl: i,
                    tooltipY: h,
                    tooltipX: d,
                    ttItems: this.ttItems
                };
                if (e.globals.axisCharts && (s ? o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a ? o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== t && "treemap" !== t || (o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")),
                o && o.length))
                    for (var p = 0; p < o.length; p++)
                        h.push(o[p].getAttribute("cy")),
                        d.push(o[p].getAttribute("cx"));
                if (e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || a && this.tooltipUtil.hasBars() && this.tConfig.shared)
                    this.addPathsEventListeners([r], u);
                else if (a && !e.globals.comboCharts || s && this.showOnIntersect)
                    this.addDatapointEventsListeners(u);
                else if (!e.globals.axisCharts || "heatmap" === t || "treemap" === t) {
                    var x = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                    this.addPathsEventListeners(x, u)
                }
                if (this.showOnIntersect) {
                    var b = e.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                    b.length > 0 && this.addPathsEventListeners(b, u),
                    this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(u)
                }
            }
        }, {
            key: "drawFixedTooltipRect",
            value: function() {
                var e = this.w
                  , t = this.getElTooltip()
                  , i = t.getBoundingClientRect()
                  , a = i.width + 10
                  , s = i.height + 10
                  , r = this.tConfig.fixed.offsetX
                  , n = this.tConfig.fixed.offsetY
                  , o = this.tConfig.fixed.position.toLowerCase();
                return o.indexOf("right") > -1 && (r = r + e.globals.svgWidth - a + 10),
                o.indexOf("bottom") > -1 && (n = n + e.globals.svgHeight - s - 10),
                t.style.left = r + "px",
                t.style.top = n + "px",
                {
                    x: r,
                    y: n,
                    ttWidth: a,
                    ttHeight: s
                }
            }
        }, {
            key: "addDatapointEventsListeners",
            value: function(e) {
                var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
                this.addPathsEventListeners(t, e)
            }
        }, {
            key: "addPathsEventListeners",
            value: function(e, t) {
                for (var i = this, a = function(r) {
                    var n = {
                        paths: e[r],
                        tooltipEl: t.tooltipEl,
                        tooltipY: t.tooltipY,
                        tooltipX: t.tooltipX,
                        elGrid: t.elGrid,
                        hoverArea: t.hoverArea,
                        ttItems: t.ttItems
                    };
                    ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(o) {
                        return e[r].addEventListener(o, i.onSeriesHover.bind(i, n), {
                            capture: !1,
                            passive: !0
                        })
                    })
                }, s = 0; s < e.length; s++)
                    a(s)
            }
        }, {
            key: "onSeriesHover",
            value: function(e, t) {
                var i = this
                  , a = Date.now() - this.lastHoverTime;
                a >= 100 ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout),
                this.seriesHoverTimeout = setTimeout(function() {
                    i.seriesHover(e, t)
                }, 100 - a))
            }
        }, {
            key: "seriesHover",
            value: function(e, t) {
                var i = this;
                this.lastHoverTime = Date.now();
                var a = []
                  , s = this.w;
                s.config.chart.group && (a = this.ctx.getGroupedCharts()),
                s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || 0 === s.globals.dataPoints) || (a.length ? a.forEach(function(r) {
                    var n = i.getElTooltip(r);
                    r.w.globals.minX === i.w.globals.minX && r.w.globals.maxX === i.w.globals.maxX && r.w.globals.tooltip.seriesHoverByContext({
                        chartCtx: r,
                        ttCtx: r.w.globals.tooltip,
                        opt: {
                            paths: e.paths,
                            tooltipEl: n,
                            tooltipY: e.tooltipY,
                            tooltipX: e.tooltipX,
                            elGrid: e.elGrid,
                            hoverArea: e.hoverArea,
                            ttItems: r.w.globals.tooltip.ttItems
                        },
                        e: t
                    })
                }) : this.seriesHoverByContext({
                    chartCtx: this.ctx,
                    ttCtx: this.w.globals.tooltip,
                    opt: e,
                    e: t
                }))
            }
        }, {
            key: "seriesHoverByContext",
            value: function(e) {
                var t = e.chartCtx
                  , i = e.ttCtx
                  , a = e.opt
                  , s = e.e
                  , r = t.w
                  , n = this.getElTooltip();
                n && (i.tooltipRect = {
                    x: 0,
                    y: 0,
                    ttWidth: n.getBoundingClientRect().width,
                    ttHeight: n.getBoundingClientRect().height
                },
                i.e = s,
                i.tooltipUtil.hasBars() && !r.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new Lt(t).toggleSeriesOnHover(s, s.target.parentNode),
                i.fixedTooltip && i.drawFixedTooltipRect(),
                r.globals.axisCharts ? i.axisChartsTooltips({
                    e: s,
                    opt: a,
                    tooltipRect: i.tooltipRect
                }) : i.nonAxisChartsTooltips({
                    e: s,
                    opt: a,
                    tooltipRect: i.tooltipRect
                }))
            }
        }, {
            key: "axisChartsTooltips",
            value: function(e) {
                var t, i, a = e.e, s = e.opt, r = this.w, n = s.elGrid.getBoundingClientRect(), o = "touchmove" === a.type ? a.touches[0].clientX : a.clientX, h = "touchmove" === a.type ? a.touches[0].clientY : a.clientY;
                if (this.clientY = h,
                this.clientX = o,
                r.globals.capturedSeriesIndex = -1,
                r.globals.capturedDataPointIndex = -1,
                h < n.top || h > n.top + n.height)
                    this.handleMouseOut(s);
                else {
                    if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
                        var d = parseInt(s.paths.getAttribute("index"), 10);
                        if (this.tConfig.enabledOnSeries.indexOf(d) < 0)
                            return void this.handleMouseOut(s)
                    }
                    var u = this.getElTooltip()
                      , p = this.getElXCrosshairs()
                      , x = r.globals.xyCharts || "bar" === r.config.chart.type && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();
                    if ("mousemove" === a.type || "touchmove" === a.type || "mouseup" === a.type) {
                        if (r.globals.collapsedSeries.length + r.globals.ancillaryCollapsedSeries.length === r.globals.series.length)
                            return;
                        null !== p && p.classList.add("apexcharts-active");
                        var b = this.yaxisTooltips.filter(function(E) {
                            return !0 === E
                        });
                        if (null !== this.ycrosshairs && b.length && this.ycrosshairs.classList.add("apexcharts-active"),
                        x && !this.showOnIntersect)
                            this.handleStickyTooltip(a, o, h, s);
                        else if ("heatmap" === r.config.chart.type || "treemap" === r.config.chart.type) {
                            var k = this.intersect.handleHeatTreeTooltip({
                                e: a,
                                opt: s,
                                x: t,
                                y: i,
                                type: r.config.chart.type
                            });
                            i = k.y,
                            u.style.left = (t = k.x) + "px",
                            u.style.top = i + "px"
                        } else
                            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                                e: a,
                                opt: s
                            }),
                            this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                                e: a,
                                opt: s,
                                x: t,
                                y: i
                            });
                        if (this.yaxisTooltips.length)
                            for (var S = 0; S < r.config.yaxis.length; S++)
                                this.axesTooltip.drawYaxisTooltipText(S, h, this.xyRatios);
                        s.tooltipEl.classList.add("apexcharts-active")
                    } else
                        "mouseout" !== a.type && "touchend" !== a.type || this.handleMouseOut(s)
                }
            }
        }, {
            key: "nonAxisChartsTooltips",
            value: function(e) {
                var t = e.e
                  , i = e.opt
                  , a = e.tooltipRect
                  , s = this.w
                  , r = i.paths.getAttribute("rel")
                  , n = this.getElTooltip()
                  , o = s.globals.dom.elWrap.getBoundingClientRect();
                if ("mousemove" === t.type || "touchmove" === t.type) {
                    n.classList.add("apexcharts-active"),
                    this.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: parseInt(r, 10) - 1,
                        shared: !1
                    });
                    var d = s.globals.clientY - o.top - a.ttHeight - 10;
                    if (n.style.left = s.globals.clientX - o.left - a.ttWidth / 2 + "px",
                    n.style.top = d + "px",
                    s.config.legend.tooltipHoverFormatter) {
                        var u = r - 1
                          , p = (0,
                        s.config.legend.tooltipHoverFormatter)(this.legendLabels[u].getAttribute("data:default-text"), {
                            seriesIndex: u,
                            dataPointIndex: u,
                            w: s
                        });
                        this.legendLabels[u].innerHTML = p
                    }
                } else
                    "mouseout" !== t.type && "touchend" !== t.type || (n.classList.remove("apexcharts-active"),
                    s.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(x) {
                        var b = x.getAttribute("data:default-text");
                        x.innerHTML = decodeURIComponent(b)
                    }))
            }
        }, {
            key: "handleStickyTooltip",
            value: function(e, t, i, a) {
                var s = this.w
                  , r = this.tooltipUtil.getNearestValues({
                    context: this,
                    hoverArea: a.hoverArea,
                    elGrid: a.elGrid,
                    clientX: t,
                    clientY: i
                })
                  , n = r.j
                  , o = r.capturedSeries;
                s.globals.collapsedSeriesIndices.includes(o) && (o = null);
                var h = a.elGrid.getBoundingClientRect();
                if (r.hoverX < 0 || r.hoverX > h.width)
                    this.handleMouseOut(a);
                else if (null !== o)
                    this.handleStickyCapturedSeries(e, o, a, n);
                else if (this.tooltipUtil.isXoverlap(n) || s.globals.isBarHorizontal) {
                    var d = s.globals.series.findIndex(function(u, p) {
                        return !s.globals.collapsedSeriesIndices.includes(p)
                    });
                    this.create(e, this, d, n, a.ttItems)
                }
            }
        }, {
            key: "handleStickyCapturedSeries",
            value: function(e, t, i, a) {
                var s = this.w;
                if (this.tConfig.shared || null !== s.globals.series[t][a]) {
                    if (void 0 !== s.globals.series[t][a])
                        this.tConfig.shared && this.tooltipUtil.isXoverlap(a) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, a, i.ttItems) : this.create(e, this, t, a, i.ttItems, !1);
                    else if (this.tooltipUtil.isXoverlap(a)) {
                        var r = s.globals.series.findIndex(function(n, o) {
                            return !s.globals.collapsedSeriesIndices.includes(o)
                        });
                        this.create(e, this, r, a, i.ttItems)
                    }
                } else
                    this.handleMouseOut(i)
            }
        }, {
            key: "deactivateHoverFilter",
            value: function() {
                for (var e = this.w, t = new U(this.ctx), i = e.globals.dom.Paper.select(".apexcharts-bar-area"), a = 0; a < i.length; a++)
                    t.pathMouseLeave(i[a])
            }
        }, {
            key: "handleMouseOut",
            value: function(e) {
                var t = this.w
                  , i = this.getElXCrosshairs();
                if (e.tooltipEl.classList.remove("apexcharts-active"),
                this.deactivateHoverFilter(),
                "bubble" !== t.config.chart.type && this.marker.resetPointsSize(),
                null !== i && i.classList.remove("apexcharts-active"),
                null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"),
                this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"),
                this.yaxisTooltips.length) {
                    null === this.yaxisTTEls && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                    for (var a = 0; a < this.yaxisTTEls.length; a++)
                        this.yaxisTTEls[a].classList.remove("apexcharts-active")
                }
                t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(s) {
                    var r = s.getAttribute("data:default-text");
                    s.innerHTML = decodeURIComponent(r)
                })
            }
        }, {
            key: "markerClick",
            value: function(e, t, i) {
                var a = this.w;
                "function" == typeof a.config.chart.events.markerClick && a.config.chart.events.markerClick(e, this.ctx, {
                    seriesIndex: t,
                    dataPointIndex: i,
                    w: a
                }),
                this.ctx.events.fireEvent("markerClick", [e, this.ctx, {
                    seriesIndex: t,
                    dataPointIndex: i,
                    w: a
                }])
            }
        }, {
            key: "create",
            value: function(e, t, i, a, s) {
                var r, n, o, h, d, u, p, x, b, k, S, E, M, l, f, w, _ = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, R = this.w, H = t;
                "mouseup" === e.type && this.markerClick(e, i, a),
                null === _ && (_ = this.tConfig.shared);
                var B = this.tooltipUtil.hasMarkers(i)
                  , j = this.tooltipUtil.getElBars();
                if (R.config.legend.tooltipHoverFormatter) {
                    var ce = R.config.legend.tooltipHoverFormatter
                      , me = Array.from(this.legendLabels);
                    me.forEach(function(ii) {
                        var Li = ii.getAttribute("data:default-text");
                        ii.innerHTML = decodeURIComponent(Li)
                    });
                    for (var ue = 0; ue < me.length; ue++) {
                        var Ee = me[ue]
                          , Ie = parseInt(Ee.getAttribute("i"), 10)
                          , rt = decodeURIComponent(Ee.getAttribute("data:default-text"))
                          , nt = ce(rt, {
                            seriesIndex: _ ? Ie : i,
                            dataPointIndex: a,
                            w: R
                        });
                        if (_)
                            Ee.innerHTML = R.globals.collapsedSeriesIndices.indexOf(Ie) < 0 ? nt : rt;
                        else if (Ee.innerHTML = Ie === i ? nt : rt,
                        i === Ie)
                            break
                    }
                }
                var ht = K(K({
                    ttItems: s,
                    i,
                    j: a
                }, void 0 !== (null === (r = R.globals.seriesRange) || void 0 === r || null === (n = r[i]) || void 0 === n || null === (o = n[a]) || void 0 === o || null === (h = o.y[0]) || void 0 === h ? void 0 : h.y1) && {
                    y1: null === (d = R.globals.seriesRange) || void 0 === d || null === (u = d[i]) || void 0 === u || null === (p = u[a]) || void 0 === p || null === (x = p.y[0]) || void 0 === x ? void 0 : x.y1
                }), void 0 !== (null === (b = R.globals.seriesRange) || void 0 === b || null === (k = b[i]) || void 0 === k || null === (S = k[a]) || void 0 === S || null === (E = S.y[0]) || void 0 === E ? void 0 : E.y2) && {
                    y2: null === (M = R.globals.seriesRange) || void 0 === M || null === (l = M[i]) || void 0 === l || null === (f = l[a]) || void 0 === f || null === (w = f.y[0]) || void 0 === w ? void 0 : w.y2
                });
                if (_) {
                    if (H.tooltipLabels.drawSeriesTexts(K(K({}, ht), {}, {
                        shared: !this.showOnIntersect && this.tConfig.shared
                    })),
                    B)
                        R.globals.markers.largestSize > 0 ? H.marker.enlargePoints(a) : H.tooltipPosition.moveDynamicPointsOnHover(a);
                    else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(j),
                    this.barSeriesHeight > 0)) {
                        var vt = new U(this.ctx)
                          , mt = R.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a, "']"));
                        this.deactivateHoverFilter(),
                        this.tooltipPosition.moveStickyTooltipOverBars(a, i);
                        for (var _t = 0; _t < mt.length; _t++)
                            vt.pathMouseEnter(mt[_t])
                    }
                } else
                    H.tooltipLabels.drawSeriesTexts(K({
                        shared: !1
                    }, ht)),
                    this.tooltipUtil.hasBars() && H.tooltipPosition.moveStickyTooltipOverBars(a, i),
                    B && H.tooltipPosition.moveMarkers(i, a)
            }
        }]),
        C
    }()
      , q = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.barCtx = e,
            this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter,
            this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter)
        }
        return Te(C, [{
            key: "handleBarDataLabels",
            value: function(e) {
                var t = e.x
                  , i = e.y
                  , a = e.y1
                  , s = e.y2
                  , r = e.i
                  , n = e.j
                  , o = e.realIndex
                  , h = e.groupIndex
                  , d = e.series
                  , u = e.barHeight
                  , p = e.barWidth
                  , x = e.barXPosition
                  , b = e.barYPosition
                  , k = e.visibleSeries
                  , S = e.renderedPath
                  , E = this.w
                  , M = new U(this.barCtx.ctx)
                  , l = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth
                  , f = t + parseFloat(p * k)
                  , w = i + parseFloat(u * k);
                E.globals.isXNumeric && !E.globals.isBarHorizontal && (f = t + parseFloat(p * (k + 1)),
                w = i + parseFloat(u * (k + 1)) - l);
                var _, j, R = null, H = t, B = i, ce = E.config.dataLabels, me = this.barCtx.barOptions.dataLabels, ue = this.barCtx.barOptions.dataLabels.total;
                void 0 !== b && this.barCtx.isRangeBar && (w = b,
                B = b),
                void 0 !== x && this.barCtx.isVerticalGroupedRangeBar && (f = x,
                H = x);
                var Ee = ce.offsetX
                  , Ie = ce.offsetY
                  , rt = {
                    width: 0,
                    height: 0
                };
                E.config.dataLabels.enabled && (rt = M.getTextRects(E.globals.yLabelFormatters[0](this.barCtx.series[r][n]), parseFloat(ce.style.fontSize)));
                var ht = {
                    x: t,
                    y: i,
                    i: r,
                    j: n,
                    realIndex: o,
                    groupIndex: h || -1,
                    renderedPath: S,
                    bcx: f,
                    bcy: w,
                    barHeight: u,
                    barWidth: p,
                    textRects: rt,
                    strokeWidth: l,
                    dataLabelsX: H,
                    dataLabelsY: B,
                    dataLabelsConfig: ce,
                    barDataLabelsConfig: me,
                    barTotalDataLabelsConfig: ue,
                    offX: Ee,
                    offY: Ie
                };
                return j = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(ht) : this.calculateColumnsDataLabelsPosition(ht),
                S.attr({
                    cy: j.bcy,
                    cx: j.bcx,
                    j: n,
                    val: d[r][n],
                    barHeight: u,
                    barWidth: p
                }),
                _ = this.drawCalculatedDataLabels({
                    x: j.dataLabelsX,
                    y: j.dataLabelsY,
                    val: this.barCtx.isRangeBar ? [a, s] : d[r][n],
                    i: o,
                    j: n,
                    barWidth: p,
                    barHeight: u,
                    textRects: rt,
                    dataLabelsConfig: ce
                }),
                E.config.chart.stacked && ue.enabled && (R = this.drawTotalDataLabels({
                    x: j.totalDataLabelsX,
                    y: j.totalDataLabelsY,
                    realIndex: o,
                    textAnchor: j.totalDataLabelsAnchor,
                    val: this.getStackedTotalDataLabel({
                        realIndex: o,
                        j: n
                    }),
                    dataLabelsConfig: ce,
                    barTotalDataLabelsConfig: ue
                })),
                {
                    dataLabels: _,
                    totalDataLabels: R
                }
            }
        }, {
            key: "getStackedTotalDataLabel",
            value: function(e) {
                var t = e.realIndex
                  , i = e.j
                  , a = this.w
                  , s = this.barCtx.stackedSeriesTotals[i];
                return this.totalFormatter && (s = this.totalFormatter(s, K(K({}, a), {}, {
                    seriesIndex: t,
                    dataPointIndex: i,
                    w: a
                }))),
                s
            }
        }, {
            key: "calculateColumnsDataLabelsPosition",
            value: function(e) {
                var t, i, a = this.w, s = e.i, r = e.j, n = e.realIndex, o = e.groupIndex, h = e.y, d = e.bcx, u = e.barWidth, p = e.barHeight, x = e.textRects, b = e.dataLabelsX, k = e.dataLabelsY, S = e.dataLabelsConfig, E = e.barDataLabelsConfig, M = e.barTotalDataLabelsConfig, l = e.strokeWidth, f = e.offX, w = e.offY;
                p = Math.abs(p);
                var _ = "vertical" === a.config.plotOptions.bar.dataLabels.orientation
                  , R = this.barCtx.barHelpers.getZeroValueEncounters({
                    i: s,
                    j: r
                }).zeroEncounters;
                d = d - l / 2 + (-1 !== o ? o * u : 0),
                this.barCtx.isVerticalGroupedRangeBar ? b += u / 2 : (b = a.globals.isXNumeric ? d - u / 2 + f : d - a.globals.gridWidth / a.globals.dataPoints + u / 2 + f,
                R > 0 && a.config.plotOptions.bar.hideZeroBarsWhenGrouped && (b -= u * R)),
                _ && (b = b + x.height / 2 - l / 2 - 2);
                var B = this.barCtx.series[s][r] < 0
                  , j = h;
                switch (this.barCtx.isReversed && (j = h - p + (B ? 2 * p : 0),
                h -= p),
                E.position) {
                case "center":
                    k = _ ? B ? j - p / 2 + w : j + p / 2 - w : B ? j - p / 2 + x.height / 2 + w : j + p / 2 + x.height / 2 - w;
                    break;
                case "bottom":
                    k = _ ? B ? j - p + w : j + p - w : B ? j - p + x.height + l + w : j + p - x.height / 2 + l - w;
                    break;
                case "top":
                    k = _ ? B ? j + w : j - w : B ? j - x.height / 2 - w : j + x.height + w
                }
                if (this.barCtx.lastActiveBarSerieIndex === n && M.enabled) {
                    var ce = new U(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                        realIndex: n,
                        j: r
                    }), S.fontSize);
                    t = B ? j - ce.height / 2 - w - M.offsetY + 18 : j + ce.height + w + M.offsetY - 18,
                    i = b + M.offsetX
                }
                return a.config.chart.stacked || (k < 0 ? k = 0 + l : k + x.height / 3 > a.globals.gridHeight && (k = a.globals.gridHeight - l)),
                {
                    bcx: d,
                    bcy: h,
                    dataLabelsX: b,
                    dataLabelsY: k,
                    totalDataLabelsX: i,
                    totalDataLabelsY: t,
                    totalDataLabelsAnchor: "middle"
                }
            }
        }, {
            key: "calculateBarsDataLabelsPosition",
            value: function(e) {
                var t = this.w
                  , i = e.x
                  , a = e.i
                  , s = e.j
                  , r = e.realIndex
                  , n = e.groupIndex
                  , o = e.bcy
                  , h = e.barHeight
                  , d = e.barWidth
                  , u = e.textRects
                  , p = e.dataLabelsX
                  , x = e.strokeWidth
                  , b = e.dataLabelsConfig
                  , k = e.barDataLabelsConfig
                  , S = e.barTotalDataLabelsConfig
                  , E = e.offX
                  , M = e.offY
                  , l = t.globals.gridHeight / t.globals.dataPoints;
                d = Math.abs(d);
                var f, w, _ = (o += -1 !== n ? n * h : 0) - (this.barCtx.isRangeBar ? 0 : l) + h / 2 + u.height / 2 + M - 3, R = "start", H = this.barCtx.series[a][s] < 0, B = i;
                switch (this.barCtx.isReversed && (B = i + d - (H ? 2 * d : 0),
                i = t.globals.gridWidth - d),
                k.position) {
                case "center":
                    p = H ? B + d / 2 - E : Math.max(u.width / 2, B - d / 2) + E;
                    break;
                case "bottom":
                    p = H ? B + d - x - Math.round(u.width / 2) - E : B - d + x + Math.round(u.width / 2) + E;
                    break;
                case "top":
                    p = H ? B - x + Math.round(u.width / 2) - E : B - x - Math.round(u.width / 2) + E
                }
                if (this.barCtx.lastActiveBarSerieIndex === r && S.enabled) {
                    var j = new U(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                        realIndex: r,
                        j: s
                    }), b.fontSize);
                    H ? (f = B - x + Math.round(j.width / 2) - E - S.offsetX - 15,
                    R = "end") : f = B - x - Math.round(j.width / 2) + E + S.offsetX + 15,
                    w = _ + S.offsetY
                }
                return t.config.chart.stacked || (p < 0 ? p = p + u.width + x : p + u.width / 2 > t.globals.gridWidth && (p = t.globals.gridWidth - u.width - x)),
                {
                    bcx: i,
                    bcy: o,
                    dataLabelsX: p,
                    dataLabelsY: _,
                    totalDataLabelsX: f,
                    totalDataLabelsY: w,
                    totalDataLabelsAnchor: R
                }
            }
        }, {
            key: "drawCalculatedDataLabels",
            value: function(e) {
                var t = e.x
                  , i = e.y
                  , a = e.val
                  , s = e.i
                  , r = e.j
                  , n = e.textRects
                  , o = e.barHeight
                  , h = e.barWidth
                  , d = e.dataLabelsConfig
                  , u = this.w
                  , p = "rotate(0)";
                "vertical" === u.config.plotOptions.bar.dataLabels.orientation && (p = "rotate(-90, ".concat(t, ", ").concat(i, ")"));
                var x = new It(this.barCtx.ctx)
                  , b = new U(this.barCtx.ctx)
                  , k = d.formatter
                  , S = null
                  , E = u.globals.collapsedSeriesIndices.indexOf(s) > -1;
                if (d.enabled && !E) {
                    S = b.group({
                        class: "apexcharts-data-labels",
                        transform: p
                    });
                    var M = "";
                    void 0 !== a && (M = k(a, K(K({}, u), {}, {
                        seriesIndex: s,
                        dataPointIndex: r,
                        w: u
                    }))),
                    !a && u.config.plotOptions.bar.hideZeroBarsWhenGrouped && (M = "");
                    var l = u.globals.series[s][r] < 0
                      , f = u.config.plotOptions.bar.dataLabels.position;
                    "vertical" === u.config.plotOptions.bar.dataLabels.orientation && ("top" === f && (d.textAnchor = l ? "end" : "start"),
                    "center" === f && (d.textAnchor = "middle"),
                    "bottom" === f && (d.textAnchor = l ? "end" : "start")),
                    this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && h < b.getTextRects(M, parseFloat(d.style.fontSize)).width && (M = ""),
                    u.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n.width / 1.6 > Math.abs(h) && (M = "") : n.height / 1.6 > Math.abs(o) && (M = ""));
                    var w = K({}, d);
                    this.barCtx.isHorizontal && a < 0 && ("start" === d.textAnchor ? w.textAnchor = "end" : "end" === d.textAnchor && (w.textAnchor = "start")),
                    x.plotDataLabelsText({
                        x: t,
                        y: i,
                        text: M,
                        i: s,
                        j: r,
                        parent: S,
                        dataLabelsConfig: w,
                        alwaysDrawDataLabel: !0,
                        offsetCorrection: !0
                    })
                }
                return S
            }
        }, {
            key: "drawTotalDataLabels",
            value: function(e) {
                var t, i = e.x, a = e.y, s = e.val, r = e.realIndex, n = e.textAnchor, o = e.barTotalDataLabelsConfig, h = new U(this.barCtx.ctx);
                return o.enabled && void 0 !== i && void 0 !== a && this.barCtx.lastActiveBarSerieIndex === r && (t = h.drawText({
                    x: i,
                    y: a,
                    foreColor: o.style.color,
                    text: s,
                    textAnchor: n,
                    fontFamily: o.style.fontFamily,
                    fontSize: o.style.fontSize,
                    fontWeight: o.style.fontWeight
                })),
                t
            }
        }]),
        C
    }()
      , te = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.barCtx = e
        }
        return Te(C, [{
            key: "initVariables",
            value: function(e) {
                var t = this.w;
                this.barCtx.series = e,
                this.barCtx.totalItems = 0,
                this.barCtx.seriesLen = 0,
                this.barCtx.visibleI = -1,
                this.barCtx.visibleItems = 1;
                for (var i = 0; i < e.length; i++)
                    if (e[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1,
                    this.barCtx.totalItems += e[i].length),
                    t.globals.isXNumeric)
                        for (var a = 0; a < e[i].length; a++)
                            t.globals.seriesX[i][a] > t.globals.minX && t.globals.seriesX[i][a] < t.globals.maxX && this.barCtx.visibleItems++;
                    else
                        this.barCtx.visibleItems = t.globals.dataPoints;
                0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1),
                this.barCtx.zeroSerieses = [],
                t.globals.comboCharts || this.checkZeroSeries({
                    series: e
                })
            }
        }, {
            key: "initialPositions",
            value: function() {
                var e, t, i, a, s, r, n, o, h = this.w, d = h.globals.dataPoints;
                this.barCtx.isRangeBar && (d = h.globals.labels.length);
                var u = this.barCtx.seriesLen;
                if (h.config.plotOptions.bar.rangeBarGroupRows && (u = 1),
                this.barCtx.isHorizontal)
                    s = (i = h.globals.gridHeight / d) / u,
                    h.globals.isXNumeric && (s = (i = h.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen),
                    s = s * parseInt(this.barCtx.barOptions.barHeight, 10) / 100,
                    -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (s = parseInt(this.barCtx.barOptions.barHeight, 10)),
                    o = this.barCtx.baseLineInvertedY + h.globals.padHorizontal + (this.barCtx.isReversed ? h.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0),
                    this.barCtx.isFunnel && (o = h.globals.gridWidth / 2),
                    t = (i - s * this.barCtx.seriesLen) / 2;
                else {
                    if (a = h.globals.gridWidth / this.barCtx.visibleItems,
                    h.config.xaxis.convertedCatToNumeric && (a = h.globals.gridWidth / h.globals.dataPoints),
                    r = a / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100,
                    h.globals.isXNumeric) {
                        var p = this.barCtx.xRatio;
                        h.config.xaxis.convertedCatToNumeric && (p = this.barCtx.initialXRatio),
                        h.globals.minXDiff && .5 !== h.globals.minXDiff && h.globals.minXDiff / p > 0 && (a = h.globals.minXDiff / p),
                        (r = a / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1)
                    }
                    -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (r = parseInt(this.barCtx.barOptions.columnWidth, 10)),
                    n = h.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? h.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0),
                    e = h.globals.padHorizontal + (a - r * this.barCtx.seriesLen) / 2
                }
                return {
                    x: e,
                    y: t,
                    yDivision: i,
                    xDivision: a,
                    barHeight: s,
                    barWidth: r,
                    zeroH: n,
                    zeroW: o
                }
            }
        }, {
            key: "initializeStackedPrevVars",
            value: function(e) {
                var t = e.w;
                t.globals.hasSeriesGroups ? t.globals.seriesGroups.forEach(function(i) {
                    e[i] || (e[i] = {}),
                    e[i].prevY = [],
                    e[i].prevX = [],
                    e[i].prevYF = [],
                    e[i].prevXF = [],
                    e[i].prevYVal = [],
                    e[i].prevXVal = []
                }) : (e.prevY = [],
                e.prevX = [],
                e.prevYF = [],
                e.prevXF = [],
                e.prevYVal = [],
                e.prevXVal = [])
            }
        }, {
            key: "initializeStackedXYVars",
            value: function(e) {
                var t = e.w;
                t.globals.hasSeriesGroups ? t.globals.seriesGroups.forEach(function(i) {
                    e[i] || (e[i] = {}),
                    e[i].xArrj = [],
                    e[i].xArrjF = [],
                    e[i].xArrjVal = [],
                    e[i].yArrj = [],
                    e[i].yArrjF = [],
                    e[i].yArrjVal = []
                }) : (e.xArrj = [],
                e.xArrjF = [],
                e.xArrjVal = [],
                e.yArrj = [],
                e.yArrjF = [],
                e.yArrjVal = [])
            }
        }, {
            key: "getPathFillColor",
            value: function(e, t, i, a) {
                var s, r, n, o, h = this.w, d = new wt(this.barCtx.ctx), u = null, p = this.barCtx.barOptions.distributed ? i : t;
                return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(x) {
                    e[t][i] >= x.from && e[t][i] <= x.to && (u = x.color)
                }),
                h.config.series[t].data[i] && h.config.series[t].data[i].fillColor && (u = h.config.series[t].data[i].fillColor),
                d.fillPath({
                    seriesNumber: this.barCtx.barOptions.distributed ? p : a,
                    dataPointIndex: i,
                    color: u,
                    value: e[t][i],
                    fillConfig: null === (s = h.config.series[t].data[i]) || void 0 === s ? void 0 : s.fill,
                    fillType: null !== (r = h.config.series[t].data[i]) && void 0 !== r && null !== (n = r.fill) && void 0 !== n && n.type ? null === (o = h.config.series[t].data[i]) || void 0 === o ? void 0 : o.fill.type : h.config.fill.type
                })
            }
        }, {
            key: "getStrokeWidth",
            value: function(e, t, i) {
                var a = 0
                  , s = this.w;
                return this.barCtx.isNullValue = !this.barCtx.series[e][t],
                s.config.stroke.show && (this.barCtx.isNullValue || (a = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)),
                a
            }
        }, {
            key: "shouldApplyRadius",
            value: function(e) {
                var t = this.w
                  , i = !1;
                return t.config.plotOptions.bar.borderRadius > 0 && (t.config.chart.stacked && "last" === t.config.plotOptions.bar.borderRadiusWhenStacked ? this.barCtx.lastActiveBarSerieIndex === e && (i = !0) : i = !0),
                i
            }
        }, {
            key: "barBackground",
            value: function(e) {
                var t = e.j
                  , i = e.i
                  , a = e.x1
                  , s = e.x2
                  , r = e.y1
                  , n = e.y2
                  , o = e.elSeries
                  , h = this.w
                  , d = new U(this.barCtx.ctx)
                  , u = new Lt(this.barCtx.ctx).getActiveConfigSeriesIndex();
                if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && u === i) {
                    t >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t %= this.barCtx.barOptions.colors.backgroundBarColors.length);
                    var x = d.drawRect(void 0 !== a ? a : 0, void 0 !== r ? r : 0, void 0 !== s ? s : h.globals.gridWidth, void 0 !== n ? n : h.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, this.barCtx.barOptions.colors.backgroundBarColors[t], this.barCtx.barOptions.colors.backgroundBarOpacity);
                    o.add(x),
                    x.node.classList.add("apexcharts-backgroundBar")
                }
            }
        }, {
            key: "getColumnPaths",
            value: function(e) {
                var t, i = e.barWidth, a = e.barXPosition, s = e.y1, r = e.y2, n = e.strokeWidth, o = e.seriesGroup, h = e.realIndex, d = e.i, u = e.j, p = e.w, x = new U(this.barCtx.ctx);
                (n = Array.isArray(n) ? n[h] : n) || (n = 0);
                var b = i
                  , k = a;
                null !== (t = p.config.series[h].data[u]) && void 0 !== t && t.columnWidthOffset && (k = a - p.config.series[h].data[u].columnWidthOffset / 2,
                b = i + p.config.series[h].data[u].columnWidthOffset);
                var S = k
                  , E = k + b;
                r += .001;
                var M = x.move(S, s += .001)
                  , l = x.move(S, s)
                  , f = x.line(E - n, s);
                if (p.globals.previousPaths.length > 0 && (l = this.barCtx.getPreviousPath(h, u, !1)),
                M = M + x.line(S, r) + x.line(E - n, r) + x.line(E - n, s) + ("around" === p.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                l = l + x.line(S, s) + f + f + f + f + f + x.line(S, s) + ("around" === p.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                this.shouldApplyRadius(h) && (M = x.roundPathCorners(M, p.config.plotOptions.bar.borderRadius)),
                p.config.chart.stacked) {
                    var w = this.barCtx;
                    p.globals.hasSeriesGroups && o && (w = this.barCtx[o]),
                    w.yArrj.push(r),
                    w.yArrjF.push(Math.abs(s - r)),
                    w.yArrjVal.push(this.barCtx.series[d][u])
                }
                return {
                    pathTo: M,
                    pathFrom: l
                }
            }
        }, {
            key: "getBarpaths",
            value: function(e) {
                var t, i = e.barYPosition, a = e.barHeight, s = e.x1, r = e.x2, n = e.strokeWidth, o = e.seriesGroup, h = e.realIndex, d = e.i, u = e.j, p = e.w, x = new U(this.barCtx.ctx);
                (n = Array.isArray(n) ? n[h] : n) || (n = 0);
                var b = i
                  , k = a;
                null !== (t = p.config.series[h].data[u]) && void 0 !== t && t.barHeightOffset && (b = i - p.config.series[h].data[u].barHeightOffset / 2,
                k = a + p.config.series[h].data[u].barHeightOffset);
                var S = b
                  , E = b + k;
                r += .001;
                var M = x.move(s += .001, S)
                  , l = x.move(s, S);
                p.globals.previousPaths.length > 0 && (l = this.barCtx.getPreviousPath(h, u, !1));
                var f = x.line(s, E - n);
                if (M = M + x.line(r, S) + x.line(r, E - n) + f + ("around" === p.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                l = l + x.line(s, S) + f + f + f + f + f + x.line(s, S) + ("around" === p.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                this.shouldApplyRadius(h) && (M = x.roundPathCorners(M, p.config.plotOptions.bar.borderRadius)),
                p.config.chart.stacked) {
                    var w = this.barCtx;
                    p.globals.hasSeriesGroups && o && (w = this.barCtx[o]),
                    w.xArrj.push(r),
                    w.xArrjF.push(Math.abs(s - r)),
                    w.xArrjVal.push(this.barCtx.series[d][u])
                }
                return {
                    pathTo: M,
                    pathFrom: l
                }
            }
        }, {
            key: "checkZeroSeries",
            value: function(e) {
                for (var t = e.series, i = this.w, a = 0; a < t.length; a++) {
                    for (var s = 0, r = 0; r < t[i.globals.maxValsInArrayIndex].length; r++)
                        s += t[a][r];
                    0 === s && this.barCtx.zeroSerieses.push(a)
                }
            }
        }, {
            key: "getXForValue",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] && !arguments[2] ? null : t;
                return null != e && (i = t + e / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0)),
                i
            }
        }, {
            key: "getYForValue",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] && !arguments[2] ? null : t;
                return null != e && (i = t - e / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? e / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)),
                i
            }
        }, {
            key: "getGoalValues",
            value: function(e, t, i, a, s) {
                var r = this
                  , n = this.w
                  , o = []
                  , h = function(p, x) {
                    var b;
                    o.push((Re(b = {}, e, "x" === e ? r.getXForValue(p, t, !1) : r.getYForValue(p, i, !1)),
                    Re(b, "attrs", x),
                    b))
                };
                if (n.globals.seriesGoals[a] && n.globals.seriesGoals[a][s] && Array.isArray(n.globals.seriesGoals[a][s]) && n.globals.seriesGoals[a][s].forEach(function(p) {
                    h(p.value, p)
                }),
                this.barCtx.barOptions.isDumbbell && n.globals.seriesRange.length) {
                    var d = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : n.globals.colors
                      , u = {
                        strokeHeight: "x" === e ? 0 : n.globals.markers.size[a],
                        strokeWidth: "x" === e ? n.globals.markers.size[a] : 0,
                        strokeDashArray: 0,
                        strokeLineCap: "round",
                        strokeColor: Array.isArray(d[a]) ? d[a][0] : d[a]
                    };
                    h(n.globals.seriesRangeStart[a][s], u),
                    h(n.globals.seriesRangeEnd[a][s], K(K({}, u), {}, {
                        strokeColor: Array.isArray(d[a]) ? d[a][1] : d[a]
                    }))
                }
                return o
            }
        }, {
            key: "drawGoalLine",
            value: function(e) {
                var t = e.barXPosition
                  , i = e.barYPosition
                  , a = e.goalX
                  , s = e.goalY
                  , r = e.barWidth
                  , n = e.barHeight
                  , o = new U(this.barCtx.ctx)
                  , h = o.group({
                    className: "apexcharts-bar-goals-groups"
                });
                h.node.classList.add("apexcharts-element-hidden"),
                this.barCtx.w.globals.delayedElements.push({
                    el: h.node
                }),
                h.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
                var d = null;
                return this.barCtx.isHorizontal ? Array.isArray(a) && a.forEach(function(u) {
                    var p = void 0 !== u.attrs.strokeHeight ? u.attrs.strokeHeight : n / 2
                      , x = i + p + n / 2;
                    d = o.drawLine(u.x, x - 2 * p, u.x, x, u.attrs.strokeColor ? u.attrs.strokeColor : void 0, u.attrs.strokeDashArray, u.attrs.strokeWidth ? u.attrs.strokeWidth : 2, u.attrs.strokeLineCap),
                    h.add(d)
                }) : Array.isArray(s) && s.forEach(function(u) {
                    var p = void 0 !== u.attrs.strokeWidth ? u.attrs.strokeWidth : r / 2
                      , x = t + p + r / 2;
                    d = o.drawLine(x - 2 * p, u.y, x, u.y, u.attrs.strokeColor ? u.attrs.strokeColor : void 0, u.attrs.strokeDashArray, u.attrs.strokeHeight ? u.attrs.strokeHeight : 2, u.attrs.strokeLineCap),
                    h.add(d)
                }),
                h
            }
        }, {
            key: "drawBarShadow",
            value: function(e) {
                var t = e.prevPaths
                  , i = e.currPaths
                  , a = e.color
                  , s = this.w
                  , r = t.x
                  , n = t.x1
                  , h = i.x
                  , d = i.x1
                  , u = i.barYPosition
                  , p = t.barYPosition + i.barHeight
                  , x = new U(this.barCtx.ctx)
                  , b = new D
                  , k = x.move(n, p) + x.line(r, p) + x.line(h, u) + x.line(d, u) + x.line(n, p) + ("around" === s.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
                return x.drawPath({
                    d: k,
                    fill: b.shadeColor(.5, D.rgb2hex(a)),
                    stroke: "none",
                    strokeWidth: 0,
                    fillOpacity: 1,
                    classes: "apexcharts-bar-shadows"
                })
            }
        }, {
            key: "getZeroValueEncounters",
            value: function(e) {
                var t = e.i
                  , i = e.j
                  , s = 0
                  , r = 0;
                return this.w.globals.seriesPercent.forEach(function(n, o) {
                    n[i] && s++,
                    o < t && 0 === n[i] && r++
                }),
                {
                    nonZeroColumns: s,
                    zeroEncounters: r
                }
            }
        }]),
        C
    }()
      , xe = function() {
        function C(e, t) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w;
            var i = this.w;
            this.barOptions = i.config.plotOptions.bar,
            this.isHorizontal = this.barOptions.horizontal,
            this.strokeWidth = i.config.stroke.width,
            this.isNullValue = !1,
            this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal,
            this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows,
            this.isFunnel = this.barOptions.isFunnel,
            this.xyRatios = t,
            null !== this.xyRatios && (this.xRatio = t.xRatio,
            this.initialXRatio = t.initialXRatio,
            this.yRatio = t.yRatio,
            this.invertedXRatio = t.invertedXRatio,
            this.invertedYRatio = t.invertedYRatio,
            this.baseLineY = t.baseLineY,
            this.baseLineInvertedY = t.baseLineInvertedY),
            this.yaxisIndex = 0,
            this.seriesLen = 0,
            this.pathArr = [];
            var a = new Lt(this.ctx);
            this.lastActiveBarSerieIndex = a.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
            var s = a.getBarSeriesIndices()
              , r = new ae(this.ctx);
            this.stackedSeriesTotals = r.getStackedSeriesTotals(this.w.config.series.map(function(n, o) {
                return -1 === s.indexOf(o) ? o : -1
            }).filter(function(n) {
                return -1 !== n
            })),
            this.barHelpers = new te(this)
        }
        return Te(C, [{
            key: "draw",
            value: function(e, t) {
                var i = this.w
                  , a = new U(this.ctx)
                  , s = new ae(this.ctx,i);
                e = s.getLogSeries(e),
                this.series = e,
                this.yRatio = s.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(e);
                var r = a.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                });
                i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
                for (var n = 0, o = 0; n < e.length; n++,
                o++) {
                    var h, d, u, p, x = void 0, b = void 0, k = [], S = [], E = i.globals.comboCharts ? t[n] : n, M = a.group({
                        class: "apexcharts-series",
                        rel: n + 1,
                        seriesName: D.escapeString(i.globals.seriesNames[E]),
                        "data:realIndex": E
                    });
                    this.ctx.series.addCollapsedClassToSeries(M, E),
                    e[n].length > 0 && (this.visibleI = this.visibleI + 1);
                    var l = 0
                      , f = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = E),
                    this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
                    var w = this.barHelpers.initialPositions();
                    b = w.y,
                    l = w.barHeight,
                    d = w.yDivision,
                    p = w.zeroW,
                    x = w.x,
                    f = w.barWidth,
                    h = w.xDivision,
                    u = w.zeroH,
                    this.horizontal || S.push(x + f / 2);
                    var _ = a.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": E
                    });
                    i.globals.delayedElements.push({
                        el: _.node
                    }),
                    _.node.classList.add("apexcharts-element-hidden");
                    var R = a.group({
                        class: "apexcharts-bar-goals-markers"
                    })
                      , H = a.group({
                        class: "apexcharts-bar-shadows"
                    });
                    i.globals.delayedElements.push({
                        el: H.node
                    }),
                    H.node.classList.add("apexcharts-element-hidden");
                    for (var B = 0; B < i.globals.dataPoints; B++) {
                        var j = this.barHelpers.getStrokeWidth(n, B, E)
                          , ce = null
                          , me = {
                            indexes: {
                                i: n,
                                j: B,
                                realIndex: E,
                                bc: o
                            },
                            x,
                            y: b,
                            strokeWidth: j,
                            elSeries: M
                        };
                        this.isHorizontal ? (ce = this.drawBarPaths(K(K({}, me), {}, {
                            barHeight: l,
                            zeroW: p,
                            yDivision: d
                        })),
                        f = this.series[n][B] / this.invertedYRatio) : (ce = this.drawColumnPaths(K(K({}, me), {}, {
                            xDivision: h,
                            barWidth: f,
                            zeroH: u
                        })),
                        l = this.series[n][B] / this.yRatio[this.yaxisIndex]);
                        var ue = this.barHelpers.getPathFillColor(e, n, B, E);
                        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && B > 0) {
                            var Ee = this.barHelpers.drawBarShadow({
                                color: "string" == typeof ue && -1 === ue?.indexOf("url") ? ue : D.hexToRgba(i.globals.colors[n]),
                                prevPaths: this.pathArr[this.pathArr.length - 1],
                                currPaths: ce
                            });
                            Ee && H.add(Ee)
                        }
                        this.pathArr.push(ce);
                        var Ie = this.barHelpers.drawGoalLine({
                            barXPosition: ce.barXPosition,
                            barYPosition: ce.barYPosition,
                            goalX: ce.goalX,
                            goalY: ce.goalY,
                            barHeight: l,
                            barWidth: f
                        });
                        Ie && R.add(Ie),
                        b = ce.y,
                        x = ce.x,
                        B > 0 && S.push(x + f / 2),
                        k.push(b),
                        this.renderSeries({
                            realIndex: E,
                            pathFill: ue,
                            j: B,
                            i: n,
                            pathFrom: ce.pathFrom,
                            pathTo: ce.pathTo,
                            strokeWidth: j,
                            elSeries: M,
                            x,
                            y: b,
                            series: e,
                            barHeight: ce.barHeight ? ce.barHeight : l,
                            barWidth: ce.barWidth ? ce.barWidth : f,
                            elDataLabelsWrap: _,
                            elGoalsMarkers: R,
                            elBarShadows: H,
                            visibleSeries: this.visibleI,
                            type: "bar"
                        })
                    }
                    i.globals.seriesXvalues[E] = S,
                    i.globals.seriesYvalues[E] = k,
                    r.add(M)
                }
                return r
            }
        }, {
            key: "renderSeries",
            value: function(e) {
                var t = e.realIndex
                  , i = e.pathFill
                  , a = e.lineFill
                  , s = e.j
                  , r = e.i
                  , n = e.groupIndex
                  , o = e.pathFrom
                  , h = e.pathTo
                  , d = e.strokeWidth
                  , u = e.elSeries
                  , p = e.x
                  , x = e.y
                  , b = e.y1
                  , k = e.y2
                  , S = e.series
                  , E = e.barHeight
                  , M = e.barWidth
                  , l = e.barXPosition
                  , f = e.barYPosition
                  , w = e.elDataLabelsWrap
                  , _ = e.elGoalsMarkers
                  , R = e.elBarShadows
                  , H = e.visibleSeries
                  , B = e.type
                  , j = this.w
                  , ce = new U(this.ctx);
                a || (a = this.barOptions.distributed ? j.globals.stroke.colors[s] : j.globals.stroke.colors[t]),
                j.config.series[r].data[s] && j.config.series[r].data[s].strokeColor && (a = j.config.series[r].data[s].strokeColor),
                this.isNullValue && (i = "none");
                var ue = ce.renderPaths({
                    i: r,
                    j: s,
                    realIndex: t,
                    pathFrom: o,
                    pathTo: h,
                    stroke: a,
                    strokeWidth: d,
                    strokeLineCap: j.config.stroke.lineCap,
                    fill: i,
                    animationDelay: s / j.config.chart.animations.animateGradually.delay * (j.config.chart.animations.speed / j.globals.dataPoints) / 2.4,
                    initialSpeed: j.config.chart.animations.speed,
                    dataChangeSpeed: j.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(B, "-area")
                });
                ue.attr("clip-path", "url(#gridRectMask".concat(j.globals.cuid, ")"));
                var Ee = j.config.forecastDataPoints;
                Ee.count > 0 && s >= j.globals.dataPoints - Ee.count && (ue.node.setAttribute("stroke-dasharray", Ee.dashArray),
                ue.node.setAttribute("stroke-width", Ee.strokeWidth),
                ue.node.setAttribute("fill-opacity", Ee.fillOpacity)),
                void 0 !== b && void 0 !== k && (ue.attr("data-range-y1", b),
                ue.attr("data-range-y2", k)),
                new _e(this.ctx).setSelectionFilter(ue, t, s),
                u.add(ue);
                var Ie = new q(this).handleBarDataLabels({
                    x: p,
                    y: x,
                    y1: b,
                    y2: k,
                    i: r,
                    j: s,
                    series: S,
                    realIndex: t,
                    groupIndex: n,
                    barHeight: E,
                    barWidth: M,
                    barXPosition: l,
                    barYPosition: f,
                    renderedPath: ue,
                    visibleSeries: H
                });
                return null !== Ie.dataLabels && w.add(Ie.dataLabels),
                Ie.totalDataLabels && w.add(Ie.totalDataLabels),
                u.add(w),
                _ && u.add(_),
                R && u.add(R),
                u
            }
        }, {
            key: "drawBarPaths",
            value: function(e) {
                var t, n, i = e.indexes, a = e.barHeight, s = e.strokeWidth, r = e.zeroW, o = e.y, h = e.yDivision, d = e.elSeries, u = this.w, p = i.i, x = i.j;
                if (u.globals.isXNumeric)
                    t = (o = (u.globals.seriesX[p][x] - u.globals.minX) / this.invertedXRatio - a) + a * this.visibleI;
                else if (u.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
                    var b = 0
                      , k = 0;
                    u.globals.seriesPercent.forEach(function(E, M) {
                        E[x] && b++,
                        M < p && 0 === E[x] && k++
                    }),
                    b > 0 && (a = this.seriesLen * a / b),
                    t = o + a * this.visibleI,
                    t -= a * k
                } else
                    t = o + a * this.visibleI;
                this.isFunnel && (r -= (this.barHelpers.getXForValue(this.series[p][x], r) - r) / 2),
                n = this.barHelpers.getXForValue(this.series[p][x], r);
                var S = this.barHelpers.getBarpaths({
                    barYPosition: t,
                    barHeight: a,
                    x1: r,
                    x2: n,
                    strokeWidth: s,
                    series: this.series,
                    realIndex: i.realIndex,
                    i: p,
                    j: x,
                    w: u
                });
                return u.globals.isXNumeric || (o += h),
                this.barHelpers.barBackground({
                    j: x,
                    i: p,
                    y1: t - a * this.visibleI,
                    y2: a * this.seriesLen,
                    elSeries: d
                }),
                {
                    pathTo: S.pathTo,
                    pathFrom: S.pathFrom,
                    x1: r,
                    x: n,
                    y: o,
                    goalX: this.barHelpers.getGoalValues("x", r, null, p, x),
                    barYPosition: t,
                    barHeight: a
                }
            }
        }, {
            key: "drawColumnPaths",
            value: function(e) {
                var t, s, i = e.indexes, a = e.x, r = e.xDivision, n = e.barWidth, o = e.zeroH, h = e.strokeWidth, d = e.elSeries, u = this.w, p = i.realIndex, x = i.i, b = i.j, k = i.bc;
                if (u.globals.isXNumeric) {
                    var S = p;
                    u.globals.seriesX[p].length || (S = u.globals.maxValsInArrayIndex),
                    u.globals.seriesX[S][b] && (a = (u.globals.seriesX[S][b] - u.globals.minX) / this.xRatio - n * this.seriesLen / 2),
                    t = a + n * this.visibleI
                } else if (u.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
                    var E = this.barHelpers.getZeroValueEncounters({
                        i: x,
                        j: b
                    })
                      , M = E.nonZeroColumns;
                    M > 0 && (n = this.seriesLen * n / M),
                    t = a + n * this.visibleI,
                    t -= n * E.zeroEncounters
                } else
                    t = a + n * this.visibleI;
                s = this.barHelpers.getYForValue(this.series[x][b], o);
                var f = this.barHelpers.getColumnPaths({
                    barXPosition: t,
                    barWidth: n,
                    y1: o,
                    y2: s,
                    strokeWidth: h,
                    series: this.series,
                    realIndex: i.realIndex,
                    i: x,
                    j: b,
                    w: u
                });
                return u.globals.isXNumeric || (a += r),
                this.barHelpers.barBackground({
                    bc: k,
                    j: b,
                    i: x,
                    x1: t - h / 2 - n * this.visibleI,
                    x2: n * this.seriesLen + h / 2,
                    elSeries: d
                }),
                {
                    pathTo: f.pathTo,
                    pathFrom: f.pathFrom,
                    x: a,
                    y: s,
                    goalY: this.barHelpers.getGoalValues("y", null, o, x, b),
                    barXPosition: t,
                    barWidth: n
                }
            }
        }, {
            key: "getPreviousPath",
            value: function(e, t) {
                for (var i, a = this.w, s = 0; s < a.globals.previousPaths.length; s++) {
                    var r = a.globals.previousPaths[s];
                    r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(e, 10) && void 0 !== a.globals.previousPaths[s].paths[t] && (i = a.globals.previousPaths[s].paths[t].d)
                }
                return i
            }
        }]),
        C
    }()
      , ve = function(C) {
        pe(t, C);
        var e = He(t);
        function t() {
            return Q(this, t),
            e.apply(this, arguments)
        }
        return Te(t, [{
            key: "draw",
            value: function(i, a) {
                var s = this
                  , r = this.w;
                this.graphics = new U(this.ctx),
                this.bar = new xe(this.ctx,this.xyRatios);
                var n = new ae(this.ctx,r);
                i = n.getLogSeries(i),
                this.yRatio = n.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(i),
                "100%" === r.config.chart.stackType && (i = r.globals.seriesPercent.slice()),
                this.series = i,
                this.barHelpers.initializeStackedPrevVars(this);
                for (var o = this.graphics.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                }), h = 0, d = 0, u = function(b, k) {
                    var S = void 0
                      , E = void 0
                      , M = void 0
                      , l = void 0
                      , f = -1;
                    s.groupCtx = s,
                    r.globals.seriesGroups.forEach(function(mt, _t) {
                        mt.indexOf(r.config.series[b].name) > -1 && (f = _t)
                    }),
                    -1 !== f && (s.groupCtx = s[r.globals.seriesGroups[f]]);
                    var w = []
                      , _ = []
                      , R = r.globals.comboCharts ? a[b] : b;
                    s.yRatio.length > 1 && (s.yaxisIndex = R),
                    s.isReversed = r.config.yaxis[s.yaxisIndex] && r.config.yaxis[s.yaxisIndex].reversed;
                    var H = s.graphics.group({
                        class: "apexcharts-series",
                        seriesName: D.escapeString(r.globals.seriesNames[R]),
                        rel: b + 1,
                        "data:realIndex": R
                    });
                    s.ctx.series.addCollapsedClassToSeries(H, R);
                    var B = s.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": R
                    })
                      , j = s.graphics.group({
                        class: "apexcharts-bar-goals-markers"
                    })
                      , ce = 0
                      , me = 0
                      , ue = s.initialPositions(h, d, S, E, M, l);
                    d = ue.y,
                    ce = ue.barHeight,
                    E = ue.yDivision,
                    l = ue.zeroW,
                    h = ue.x,
                    me = ue.barWidth,
                    S = ue.xDivision,
                    M = ue.zeroH,
                    s.barHelpers.initializeStackedXYVars(s),
                    1 === s.groupCtx.prevY.length && s.groupCtx.prevY[0].every(function(mt) {
                        return isNaN(mt)
                    }) && (s.groupCtx.prevY[0] = s.groupCtx.prevY[0].map(function(mt) {
                        return M
                    }),
                    s.groupCtx.prevYF[0] = s.groupCtx.prevYF[0].map(function(mt) {
                        return 0
                    }));
                    for (var Ee = 0; Ee < r.globals.dataPoints; Ee++) {
                        var Ie = s.barHelpers.getStrokeWidth(b, Ee, R)
                          , rt = {
                            indexes: {
                                i: b,
                                j: Ee,
                                realIndex: R,
                                bc: k
                            },
                            strokeWidth: Ie,
                            x: h,
                            y: d,
                            elSeries: H,
                            groupIndex: f,
                            seriesGroup: r.globals.seriesGroups[f]
                        }
                          , nt = null;
                        s.isHorizontal ? (nt = s.drawStackedBarPaths(K(K({}, rt), {}, {
                            zeroW: l,
                            barHeight: ce,
                            yDivision: E
                        })),
                        me = s.series[b][Ee] / s.invertedYRatio) : (nt = s.drawStackedColumnPaths(K(K({}, rt), {}, {
                            xDivision: S,
                            barWidth: me,
                            zeroH: M
                        })),
                        ce = s.series[b][Ee] / s.yRatio[s.yaxisIndex]);
                        var ht = s.barHelpers.drawGoalLine({
                            barXPosition: nt.barXPosition,
                            barYPosition: nt.barYPosition,
                            goalX: nt.goalX,
                            goalY: nt.goalY,
                            barHeight: ce,
                            barWidth: me
                        });
                        ht && j.add(ht),
                        d = nt.y,
                        w.push(h = nt.x),
                        _.push(d);
                        var vt = s.barHelpers.getPathFillColor(i, b, Ee, R);
                        H = s.renderSeries({
                            realIndex: R,
                            pathFill: vt,
                            j: Ee,
                            i: b,
                            groupIndex: f,
                            pathFrom: nt.pathFrom,
                            pathTo: nt.pathTo,
                            strokeWidth: Ie,
                            elSeries: H,
                            x: h,
                            y: d,
                            series: i,
                            barHeight: ce,
                            barWidth: me,
                            elDataLabelsWrap: B,
                            elGoalsMarkers: j,
                            type: "bar",
                            visibleSeries: 0
                        })
                    }
                    r.globals.seriesXvalues[R] = w,
                    r.globals.seriesYvalues[R] = _,
                    s.groupCtx.prevY.push(s.groupCtx.yArrj),
                    s.groupCtx.prevYF.push(s.groupCtx.yArrjF),
                    s.groupCtx.prevYVal.push(s.groupCtx.yArrjVal),
                    s.groupCtx.prevX.push(s.groupCtx.xArrj),
                    s.groupCtx.prevXF.push(s.groupCtx.xArrjF),
                    s.groupCtx.prevXVal.push(s.groupCtx.xArrjVal),
                    o.add(H)
                }, p = 0, x = 0; p < i.length; p++,
                x++)
                    u(p, x);
                return o
            }
        }, {
            key: "initialPositions",
            value: function(i, a, s, r, n, o) {
                var h, d, u, p, x = this.w;
                return this.isHorizontal ? (u = (u = r = x.globals.gridHeight / x.globals.dataPoints) * parseInt(x.config.plotOptions.bar.barHeight, 10) / 100,
                -1 === String(x.config.plotOptions.bar.barHeight).indexOf("%") && (u = parseInt(x.config.plotOptions.bar.barHeight, 10)),
                o = this.baseLineInvertedY + x.globals.padHorizontal + (this.isReversed ? x.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0),
                a = (r - u) / 2) : (p = s = x.globals.gridWidth / x.globals.dataPoints,
                p = x.globals.isXNumeric && x.globals.dataPoints > 1 ? (s = x.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : p * parseInt(x.config.plotOptions.bar.columnWidth, 10) / 100,
                -1 === String(x.config.plotOptions.bar.columnWidth).indexOf("%") && (p = parseInt(x.config.plotOptions.bar.columnWidth, 10)),
                n = x.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? x.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0),
                i = x.globals.padHorizontal + (s - p) / 2),
                {
                    x: i,
                    y: a,
                    yDivision: r,
                    xDivision: s,
                    barHeight: null !== (h = x.globals.seriesGroups) && void 0 !== h && h.length ? u / x.globals.seriesGroups.length : u,
                    barWidth: null !== (d = x.globals.seriesGroups) && void 0 !== d && d.length ? p / x.globals.seriesGroups.length : p,
                    zeroH: n,
                    zeroW: o
                }
            }
        }, {
            key: "drawStackedBarPaths",
            value: function(i) {
                for (var a, h, s = i.indexes, r = i.barHeight, n = i.strokeWidth, o = i.zeroW, d = i.y, u = i.groupIndex, p = i.seriesGroup, x = i.yDivision, b = i.elSeries, k = this.w, S = d + (-1 !== u ? u * r : 0), E = s.i, M = s.j, l = 0, f = 0; f < this.groupCtx.prevXF.length; f++)
                    l += this.groupCtx.prevXF[f][M];
                var w = E;
                if (p && (w = p.indexOf(k.config.series[E].name)),
                w > 0) {
                    var _ = o;
                    this.groupCtx.prevXVal[w - 1][M] < 0 ? _ = this.series[E][M] >= 0 ? this.groupCtx.prevX[w - 1][M] + l - 2 * (this.isReversed ? l : 0) : this.groupCtx.prevX[w - 1][M] : this.groupCtx.prevXVal[w - 1][M] >= 0 && (_ = this.series[E][M] >= 0 ? this.groupCtx.prevX[w - 1][M] : this.groupCtx.prevX[w - 1][M] - l + 2 * (this.isReversed ? l : 0)),
                    a = _
                } else
                    a = o;
                var R = this.barHelpers.getBarpaths({
                    barYPosition: S,
                    barHeight: r,
                    x1: a,
                    x2: h = null === this.series[E][M] ? a : a + this.series[E][M] / this.invertedYRatio - 2 * (this.isReversed ? this.series[E][M] / this.invertedYRatio : 0),
                    strokeWidth: n,
                    series: this.series,
                    realIndex: s.realIndex,
                    seriesGroup: p,
                    i: E,
                    j: M,
                    w: k
                });
                return this.barHelpers.barBackground({
                    j: M,
                    i: E,
                    y1: S,
                    y2: r,
                    elSeries: b
                }),
                d += x,
                {
                    pathTo: R.pathTo,
                    pathFrom: R.pathFrom,
                    goalX: this.barHelpers.getGoalValues("x", o, null, E, M),
                    barYPosition: S,
                    x: h,
                    y: d
                }
            }
        }, {
            key: "drawStackedColumnPaths",
            value: function(i) {
                var r, a = i.indexes, s = i.x, n = i.xDivision, o = i.barWidth, h = i.zeroH, d = i.groupIndex, u = i.seriesGroup, p = i.elSeries, x = this.w, b = a.i, k = a.j, S = a.bc;
                if (x.globals.isXNumeric) {
                    var E = x.globals.seriesX[b][k];
                    E || (E = 0),
                    s = (E - x.globals.minX) / this.xRatio - o / 2,
                    x.globals.seriesGroups.length && (s = (E - x.globals.minX) / this.xRatio - o / 2 * x.globals.seriesGroups.length)
                }
                for (var M, l = s + (-1 !== d ? d * o : 0), f = 0, w = 0; w < this.groupCtx.prevYF.length; w++)
                    f += isNaN(this.groupCtx.prevYF[w][k]) ? 0 : this.groupCtx.prevYF[w][k];
                var _ = b;
                if (u && (_ = u.indexOf(x.config.series[b].name)),
                _ > 0 && !x.globals.isXNumeric || _ > 0 && x.globals.isXNumeric && x.globals.seriesX[b - 1][k] === x.globals.seriesX[b][k]) {
                    var R, H, B, j = Math.min(this.yRatio.length + 1, b + 1);
                    if (void 0 !== this.groupCtx.prevY[_ - 1] && this.groupCtx.prevY[_ - 1].length)
                        for (var ce = 1; ce < j; ce++) {
                            var me;
                            if (!isNaN(null === (me = this.groupCtx.prevY[_ - ce]) || void 0 === me ? void 0 : me[k])) {
                                B = this.groupCtx.prevY[_ - ce][k];
                                break
                            }
                        }
                    for (var ue = 1; ue < j; ue++) {
                        var Ee, Ie;
                        if ((null === (Ee = this.groupCtx.prevYVal[_ - ue]) || void 0 === Ee ? void 0 : Ee[k]) < 0) {
                            H = this.series[b][k] >= 0 ? B - f + 2 * (this.isReversed ? f : 0) : B;
                            break
                        }
                        if ((null === (Ie = this.groupCtx.prevYVal[_ - ue]) || void 0 === Ie ? void 0 : Ie[k]) >= 0) {
                            H = this.series[b][k] >= 0 ? B : B + f - 2 * (this.isReversed ? f : 0);
                            break
                        }
                    }
                    void 0 === H && (H = x.globals.gridHeight),
                    M = null !== (R = this.groupCtx.prevYF[0]) && void 0 !== R && R.every(function(nt) {
                        return 0 === nt
                    }) && this.groupCtx.prevYF.slice(1, _).every(function(nt) {
                        return nt.every(function(ht) {
                            return isNaN(ht)
                        })
                    }) ? h : H
                } else
                    M = h;
                var rt = this.barHelpers.getColumnPaths({
                    barXPosition: l,
                    barWidth: o,
                    y1: M,
                    y2: r = this.series[b][k] ? M - this.series[b][k] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[b][k] / this.yRatio[this.yaxisIndex] : 0) : M,
                    yRatio: this.yRatio[this.yaxisIndex],
                    strokeWidth: this.strokeWidth,
                    series: this.series,
                    seriesGroup: u,
                    realIndex: a.realIndex,
                    i: b,
                    j: k,
                    w: x
                });
                return this.barHelpers.barBackground({
                    bc: S,
                    j: k,
                    i: b,
                    x1: l,
                    x2: o,
                    elSeries: p
                }),
                s += n,
                {
                    pathTo: rt.pathTo,
                    pathFrom: rt.pathFrom,
                    goalY: this.barHelpers.getGoalValues("y", null, h, b, k),
                    barXPosition: l,
                    x: x.globals.isXNumeric ? s - n : s,
                    y: r
                }
            }
        }]),
        t
    }(xe)
      , fe = function(C) {
        pe(t, C);
        var e = He(t);
        function t() {
            return Q(this, t),
            e.apply(this, arguments)
        }
        return Te(t, [{
            key: "draw",
            value: function(i, a, s) {
                var r = this
                  , n = this.w
                  , o = new U(this.ctx)
                  , h = n.globals.comboCharts ? a : n.config.chart.type
                  , d = new wt(this.ctx);
                this.candlestickOptions = this.w.config.plotOptions.candlestick,
                this.boxOptions = this.w.config.plotOptions.boxPlot,
                this.isHorizontal = n.config.plotOptions.bar.horizontal;
                var u = new ae(this.ctx,n);
                i = u.getLogSeries(i),
                this.series = i,
                this.yRatio = u.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(i);
                for (var p = o.group({
                    class: "apexcharts-".concat(h, "-series apexcharts-plot-series")
                }), x = function(k) {
                    r.isBoxPlot = "boxPlot" === n.config.chart.type || "boxPlot" === n.config.series[k].type;
                    var S, E, M, l, j, ce, f = void 0, w = void 0, _ = [], R = [], H = n.globals.comboCharts ? s[k] : k, B = o.group({
                        class: "apexcharts-series",
                        seriesName: D.escapeString(n.globals.seriesNames[H]),
                        rel: k + 1,
                        "data:realIndex": H
                    });
                    r.ctx.series.addCollapsedClassToSeries(B, H),
                    i[k].length > 0 && (r.visibleI = r.visibleI + 1),
                    r.yRatio.length > 1 && (r.yaxisIndex = H);
                    var me = r.barHelpers.initialPositions();
                    w = me.y,
                    j = me.barHeight,
                    E = me.yDivision,
                    l = me.zeroW,
                    S = me.xDivision,
                    M = me.zeroH,
                    R.push((f = me.x) + (ce = me.barWidth) / 2);
                    for (var ue = o.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": H
                    }), Ee = function(rt) {
                        var nt = r.barHelpers.getStrokeWidth(k, rt, H)
                          , ht = null
                          , vt = {
                            indexes: {
                                i: k,
                                j: rt,
                                realIndex: H
                            },
                            x: f,
                            y: w,
                            strokeWidth: nt,
                            elSeries: B
                        };
                        ht = r.isHorizontal ? r.drawHorizontalBoxPaths(K(K({}, vt), {}, {
                            yDivision: E,
                            barHeight: j,
                            zeroW: l
                        })) : r.drawVerticalBoxPaths(K(K({}, vt), {}, {
                            xDivision: S,
                            barWidth: ce,
                            zeroH: M
                        })),
                        w = ht.y,
                        f = ht.x,
                        rt > 0 && R.push(f + ce / 2),
                        _.push(w),
                        ht.pathTo.forEach(function(mt, _t) {
                            var ii = !r.isBoxPlot && r.candlestickOptions.wick.useFillColor ? ht.color[_t] : n.globals.stroke.colors[k]
                              , Li = d.fillPath({
                                seriesNumber: H,
                                dataPointIndex: rt,
                                color: ht.color[_t],
                                value: i[k][rt]
                            });
                            r.renderSeries({
                                realIndex: H,
                                pathFill: Li,
                                lineFill: ii,
                                j: rt,
                                i: k,
                                pathFrom: ht.pathFrom,
                                pathTo: mt,
                                strokeWidth: nt,
                                elSeries: B,
                                x: f,
                                y: w,
                                series: i,
                                barHeight: j,
                                barWidth: ce,
                                elDataLabelsWrap: ue,
                                visibleSeries: r.visibleI,
                                type: n.config.chart.type
                            })
                        })
                    }, Ie = 0; Ie < n.globals.dataPoints; Ie++)
                        Ee(Ie);
                    n.globals.seriesXvalues[H] = R,
                    n.globals.seriesYvalues[H] = _,
                    p.add(B)
                }, b = 0; b < i.length; b++)
                    x(b);
                return p
            }
        }, {
            key: "drawVerticalBoxPaths",
            value: function(i) {
                var a = i.indexes
                  , s = i.x
                  , r = i.xDivision
                  , n = i.barWidth
                  , o = i.zeroH
                  , h = i.strokeWidth
                  , d = this.w
                  , u = new U(this.ctx)
                  , p = a.i
                  , x = a.j
                  , b = !0
                  , k = d.config.plotOptions.candlestick.colors.upward
                  , S = d.config.plotOptions.candlestick.colors.downward
                  , E = "";
                this.isBoxPlot && (E = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                var M = this.yRatio[this.yaxisIndex]
                  , l = a.realIndex
                  , f = this.getOHLCValue(l, x)
                  , w = o
                  , _ = o;
                f.o > f.c && (b = !1);
                var R = Math.min(f.o, f.c)
                  , H = Math.max(f.o, f.c)
                  , B = f.m;
                d.globals.isXNumeric && (s = (d.globals.seriesX[l][x] - d.globals.minX) / this.xRatio - n / 2);
                var j = s + n * this.visibleI;
                null == this.series[p][x] ? (R = o,
                H = o) : (R = o - R / M,
                H = o - H / M,
                w = o - f.h / M,
                _ = o - f.l / M,
                B = o - f.m / M);
                var ce = u.move(j, o)
                  , me = u.move(j + n / 2, R);
                return d.globals.previousPaths.length > 0 && (me = this.getPreviousPath(l, x, !0)),
                ce = this.isBoxPlot ? [u.move(j, R) + u.line(j + n / 2, R) + u.line(j + n / 2, w) + u.line(j + n / 4, w) + u.line(j + n - n / 4, w) + u.line(j + n / 2, w) + u.line(j + n / 2, R) + u.line(j + n, R) + u.line(j + n, B) + u.line(j, B) + u.line(j, R + h / 2), u.move(j, B) + u.line(j + n, B) + u.line(j + n, H) + u.line(j + n / 2, H) + u.line(j + n / 2, _) + u.line(j + n - n / 4, _) + u.line(j + n / 4, _) + u.line(j + n / 2, _) + u.line(j + n / 2, H) + u.line(j, H) + u.line(j, B) + "z"] : [u.move(j, H) + u.line(j + n / 2, H) + u.line(j + n / 2, w) + u.line(j + n / 2, H) + u.line(j + n, H) + u.line(j + n, R) + u.line(j + n / 2, R) + u.line(j + n / 2, _) + u.line(j + n / 2, R) + u.line(j, R) + u.line(j, H - h / 2)],
                me += u.move(j, R),
                d.globals.isXNumeric || (s += r),
                {
                    pathTo: ce,
                    pathFrom: me,
                    x: s,
                    y: H,
                    barXPosition: j,
                    color: this.isBoxPlot ? E : b ? [k] : [S]
                }
            }
        }, {
            key: "drawHorizontalBoxPaths",
            value: function(i) {
                var a = i.indexes
                  , s = i.y
                  , r = i.yDivision
                  , n = i.barHeight
                  , o = i.zeroW
                  , h = i.strokeWidth
                  , d = this.w
                  , u = new U(this.ctx)
                  , p = a.i
                  , x = a.j
                  , b = this.boxOptions.colors.lower;
                this.isBoxPlot && (b = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                var k = this.invertedYRatio
                  , S = a.realIndex
                  , E = this.getOHLCValue(S, x)
                  , M = o
                  , l = o
                  , f = Math.min(E.o, E.c)
                  , w = Math.max(E.o, E.c)
                  , _ = E.m;
                d.globals.isXNumeric && (s = (d.globals.seriesX[S][x] - d.globals.minX) / this.invertedXRatio - n / 2);
                var R = s + n * this.visibleI;
                null == this.series[p][x] ? (f = o,
                w = o) : (f = o + f / k,
                w = o + w / k,
                M = o + E.h / k,
                l = o + E.l / k,
                _ = o + E.m / k);
                var H = u.move(o, R)
                  , B = u.move(f, R + n / 2);
                return d.globals.previousPaths.length > 0 && (B = this.getPreviousPath(S, x, !0)),
                H = [u.move(f, R) + u.line(f, R + n / 2) + u.line(M, R + n / 2) + u.line(M, R + n / 2 - n / 4) + u.line(M, R + n / 2 + n / 4) + u.line(M, R + n / 2) + u.line(f, R + n / 2) + u.line(f, R + n) + u.line(_, R + n) + u.line(_, R) + u.line(f + h / 2, R), u.move(_, R) + u.line(_, R + n) + u.line(w, R + n) + u.line(w, R + n / 2) + u.line(l, R + n / 2) + u.line(l, R + n - n / 4) + u.line(l, R + n / 4) + u.line(l, R + n / 2) + u.line(w, R + n / 2) + u.line(w, R) + u.line(_, R) + "z"],
                B += u.move(f, R),
                d.globals.isXNumeric || (s += r),
                {
                    pathTo: H,
                    pathFrom: B,
                    x: w,
                    y: s,
                    barYPosition: R,
                    color: b
                }
            }
        }, {
            key: "getOHLCValue",
            value: function(i, a) {
                var s = this.w;
                return {
                    o: this.isBoxPlot ? s.globals.seriesCandleH[i][a] : s.globals.seriesCandleO[i][a],
                    h: this.isBoxPlot ? s.globals.seriesCandleO[i][a] : s.globals.seriesCandleH[i][a],
                    m: s.globals.seriesCandleM[i][a],
                    l: this.isBoxPlot ? s.globals.seriesCandleC[i][a] : s.globals.seriesCandleL[i][a],
                    c: this.isBoxPlot ? s.globals.seriesCandleL[i][a] : s.globals.seriesCandleC[i][a]
                }
            }
        }]),
        t
    }(xe)
      , Le = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "checkColorRange",
            value: function() {
                var e = this.w
                  , t = !1
                  , i = e.config.plotOptions[e.config.chart.type];
                return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(a, s) {
                    a.from <= 0 && (t = !0)
                }),
                t
            }
        }, {
            key: "getShadeColor",
            value: function(e, t, i, a) {
                var s = this.w
                  , r = 1
                  , n = s.config.plotOptions[e].shadeIntensity
                  , o = this.determineColor(e, t, i);
                s.globals.hasNegs || a ? r = s.config.plotOptions[e].reverseNegativeShade ? o.percent < 0 ? o.percent / 100 * (1.25 * n) : 1.25 * n * (1 - o.percent / 100) : o.percent <= 0 ? 1 - (1 + o.percent / 100) * n : (1 - o.percent / 100) * n : (r = 1 - o.percent / 100,
                "treemap" === e && (r = 1.25 * n * (1 - o.percent / 100)));
                var h = o.color
                  , d = new D;
                return s.config.plotOptions[e].enableShades && (h = D.hexToRgba(d.shadeColor("dark" === this.w.config.theme.mode ? -1 * r : r, o.color), s.config.fill.opacity)),
                {
                    color: h,
                    colorProps: o
                }
            }
        }, {
            key: "determineColor",
            value: function(e, t, i) {
                var a = this.w
                  , s = a.globals.series[t][i]
                  , r = a.config.plotOptions[e]
                  , n = r.colorScale.inverse ? i : t;
                r.distributed && "treemap" === a.config.chart.type && (n = i);
                var o = a.globals.colors[n]
                  , h = null
                  , d = Math.min.apply(Math, J(a.globals.series[t]))
                  , u = Math.max.apply(Math, J(a.globals.series[t]));
                r.distributed || "heatmap" !== e || (d = a.globals.minY,
                u = a.globals.maxY),
                void 0 !== r.colorScale.min && (d = r.colorScale.min < a.globals.minY ? r.colorScale.min : a.globals.minY,
                u = r.colorScale.max > a.globals.maxY ? r.colorScale.max : a.globals.maxY);
                var p = Math.abs(u) + Math.abs(d)
                  , x = 100 * s / (0 === p ? p - 1e-6 : p);
                return r.colorScale.ranges.length > 0 && r.colorScale.ranges.map(function(b, k) {
                    if (s >= b.from && s <= b.to) {
                        o = b.color,
                        h = b.foreColor ? b.foreColor : null,
                        d = b.from,
                        u = b.to;
                        var S = Math.abs(u) + Math.abs(d);
                        x = 100 * s / (0 === S ? S - 1e-6 : S)
                    }
                }),
                {
                    color: o,
                    foreColor: h,
                    percent: x
                }
            }
        }, {
            key: "calculateDataLabels",
            value: function(e) {
                var t = e.text
                  , i = e.x
                  , a = e.y
                  , s = e.i
                  , r = e.j
                  , n = e.colorProps
                  , o = e.fontSize
                  , h = this.w.config.dataLabels
                  , d = new U(this.ctx)
                  , u = new It(this.ctx)
                  , p = null;
                if (h.enabled) {
                    p = d.group({
                        class: "apexcharts-data-labels"
                    });
                    var b = h.offsetY
                      , k = i + h.offsetX
                      , S = a + parseFloat(h.style.fontSize) / 3 + b;
                    u.plotDataLabelsText({
                        x: k,
                        y: S,
                        text: t,
                        i: s,
                        j: r,
                        color: n.foreColor,
                        parent: p,
                        fontSize: o,
                        dataLabelsConfig: h
                    })
                }
                return p
            }
        }, {
            key: "addListeners",
            value: function(e) {
                var t = new U(this.ctx);
                e.node.addEventListener("mouseenter", t.pathMouseEnter.bind(this, e)),
                e.node.addEventListener("mouseleave", t.pathMouseLeave.bind(this, e)),
                e.node.addEventListener("mousedown", t.pathMouseDown.bind(this, e))
            }
        }]),
        C
    }()
      , Pe = function() {
        function C(e, t) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.xRatio = t.xRatio,
            this.yRatio = t.yRatio,
            this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation,
            this.helpers = new Le(e),
            this.rectRadius = this.w.config.plotOptions.heatmap.radius,
            this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
        }
        return Te(C, [{
            key: "draw",
            value: function(e) {
                var t = this.w
                  , i = new U(this.ctx)
                  , a = i.group({
                    class: "apexcharts-heatmap"
                });
                a.attr("clip-path", "url(#gridRectMask".concat(t.globals.cuid, ")"));
                var s = t.globals.gridWidth / t.globals.dataPoints
                  , r = t.globals.gridHeight / t.globals.series.length
                  , n = 0
                  , o = !1;
                this.negRange = this.helpers.checkColorRange();
                var h = e.slice();
                t.config.yaxis[0].reversed && (o = !0,
                h.reverse());
                for (var d = o ? 0 : h.length - 1; o ? d < h.length : d >= 0; o ? d++ : d--) {
                    var u = i.group({
                        class: "apexcharts-series apexcharts-heatmap-series",
                        seriesName: D.escapeString(t.globals.seriesNames[d]),
                        rel: d + 1,
                        "data:realIndex": d
                    });
                    if (this.ctx.series.addCollapsedClassToSeries(u, d),
                    t.config.chart.dropShadow.enabled) {
                        var p = t.config.chart.dropShadow;
                        new _e(this.ctx).dropShadow(u, p, d)
                    }
                    for (var x = 0, b = t.config.plotOptions.heatmap.shadeIntensity, k = 0; k < h[d].length; k++) {
                        var S = this.helpers.getShadeColor(t.config.chart.type, d, k, this.negRange)
                          , E = S.color
                          , M = S.colorProps;
                        "image" === t.config.fill.type && (E = new wt(this.ctx).fillPath({
                            seriesNumber: d,
                            dataPointIndex: k,
                            opacity: t.globals.hasNegs ? M.percent < 0 ? 1 - (1 + M.percent / 100) : b + M.percent / 100 : M.percent / 100,
                            patternID: D.randomId(),
                            width: t.config.fill.image.width ? t.config.fill.image.width : s,
                            height: t.config.fill.image.height ? t.config.fill.image.height : r
                        }));
                        var f = i.drawRect(x, n, s, r, this.rectRadius);
                        if (f.attr({
                            cx: x,
                            cy: n
                        }),
                        f.node.classList.add("apexcharts-heatmap-rect"),
                        u.add(f),
                        f.attr({
                            fill: E,
                            i: d,
                            index: d,
                            j: k,
                            val: h[d][k],
                            "stroke-width": this.strokeWidth,
                            stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? E : t.globals.stroke.colors[0],
                            color: E
                        }),
                        this.helpers.addListeners(f),
                        t.config.chart.animations.enabled && !t.globals.dataChanged) {
                            var w = 1;
                            t.globals.resized || (w = t.config.chart.animations.speed),
                            this.animateHeatMap(f, x, n, s, r, w)
                        }
                        if (t.globals.dataChanged) {
                            var _ = 1;
                            if (this.dynamicAnim.enabled && t.globals.shouldAnimate) {
                                _ = this.dynamicAnim.speed;
                                var R = t.globals.previousPaths[d] && t.globals.previousPaths[d][k] && t.globals.previousPaths[d][k].color;
                                R || (R = "rgba(255, 255, 255, 0)"),
                                this.animateHeatColor(f, D.isColorHex(R) ? R : D.rgb2hex(R), D.isColorHex(E) ? E : D.rgb2hex(E), _)
                            }
                        }
                        var H = (0,
                        t.config.dataLabels.formatter)(t.globals.series[d][k], {
                            value: t.globals.series[d][k],
                            seriesIndex: d,
                            dataPointIndex: k,
                            w: t
                        })
                          , B = this.helpers.calculateDataLabels({
                            text: H,
                            x: x + s / 2,
                            y: n + r / 2,
                            i: d,
                            j: k,
                            colorProps: M,
                            series: h
                        });
                        null !== B && u.add(B),
                        x += s
                    }
                    n += r,
                    a.add(u)
                }
                var j = t.globals.yAxisScale[0].result.slice();
                return t.config.yaxis[0].reversed ? j.unshift("") : j.push(""),
                t.globals.yAxisScale[0].result = j,
                a
            }
        }, {
            key: "animateHeatMap",
            value: function(e, t, i, a, s, r) {
                var n = new Se(this.ctx);
                n.animateRect(e, {
                    x: t + a / 2,
                    y: i + s / 2,
                    width: 0,
                    height: 0
                }, {
                    x: t,
                    y: i,
                    width: a,
                    height: s
                }, r, function() {
                    n.animationCompleted(e)
                })
            }
        }, {
            key: "animateHeatColor",
            value: function(e, t, i, a) {
                e.attr({
                    fill: t
                }).animate(a).attr({
                    fill: i
                })
            }
        }]),
        C
    }()
      , Fe = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "drawYAxisTexts",
            value: function(e, t, i, a) {
                var s = this.w
                  , r = s.config.yaxis[0]
                  , n = s.globals.yLabelFormatters[0];
                return new U(this.ctx).drawText({
                    x: e + r.labels.offsetX,
                    y: t + r.labels.offsetY,
                    text: n(a, i),
                    textAnchor: "middle",
                    fontSize: r.labels.style.fontSize,
                    fontFamily: r.labels.style.fontFamily,
                    foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[i] : r.labels.style.colors
                })
            }
        }]),
        C
    }()
      , Qe = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w;
            var t = this.w;
            this.chartType = this.w.config.chart.type,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled,
            this.animBeginArr = [0],
            this.animDur = 0,
            this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels,
            this.lineColorArr = void 0 !== t.globals.stroke.colors ? t.globals.stroke.colors : t.globals.colors,
            this.defaultSize = Math.min(t.globals.gridWidth, t.globals.gridHeight),
            this.centerY = this.defaultSize / 2,
            this.centerX = t.globals.gridWidth / 2,
            this.fullAngle = "radialBar" === t.config.chart.type ? 360 : Math.abs(t.config.plotOptions.pie.endAngle - t.config.plotOptions.pie.startAngle),
            this.initialAngle = t.config.plotOptions.pie.startAngle % this.fullAngle,
            t.globals.radialSize = this.defaultSize / 2.05 - t.config.stroke.width - (t.config.chart.sparkline.enabled ? 0 : t.config.chart.dropShadow.blur),
            this.donutSize = t.globals.radialSize * parseInt(t.config.plotOptions.pie.donut.size, 10) / 100,
            this.maxY = 0,
            this.sliceLabels = [],
            this.sliceSizes = [],
            this.prevSectorAngleArr = []
        }
        return Te(C, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = new U(this.ctx);
                if (this.ret = a.group({
                    class: "apexcharts-pie"
                }),
                i.globals.noData)
                    return this.ret;
                for (var s = 0, r = 0; r < e.length; r++)
                    s += D.negToZero(e[r]);
                var n = []
                  , o = a.group();
                0 === s && (s = 1e-5),
                e.forEach(function(R) {
                    t.maxY = Math.max(t.maxY, R)
                }),
                i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max),
                "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
                for (var h = 0; h < e.length; h++) {
                    var d = this.fullAngle * D.negToZero(e[h]) / s;
                    n.push(d),
                    "polarArea" === this.chartType ? (n[h] = this.fullAngle / e.length,
                    this.sliceSizes.push(i.globals.radialSize * e[h] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize)
                }
                if (i.globals.dataChanged) {
                    for (var u, p = 0, x = 0; x < i.globals.previousPaths.length; x++)
                        p += D.negToZero(i.globals.previousPaths[x]);
                    for (var b = 0; b < i.globals.previousPaths.length; b++)
                        u = this.fullAngle * D.negToZero(i.globals.previousPaths[b]) / p,
                        this.prevSectorAngleArr.push(u)
                }
                this.donutSize < 0 && (this.donutSize = 0);
                var k = i.config.plotOptions.pie.customScale
                  , M = i.globals.gridWidth / 2 - i.globals.gridWidth / 2 * k
                  , l = i.globals.gridHeight / 2 - i.globals.gridHeight / 2 * k;
                if ("donut" === this.chartType) {
                    var f = a.drawCircle(this.donutSize);
                    f.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
                    }),
                    o.add(f)
                }
                var w = this.drawArcs(n, e);
                if (this.sliceLabels.forEach(function(R) {
                    w.add(R)
                }),
                o.attr({
                    transform: "translate(".concat(M, ", ").concat(l, ") scale(").concat(k, ")")
                }),
                o.add(w),
                this.ret.add(o),
                this.donutDataLabels.show) {
                    var _ = this.renderInnerDataLabels(this.donutDataLabels, {
                        hollowSize: this.donutSize,
                        centerX: this.centerX,
                        centerY: this.centerY,
                        opacity: this.donutDataLabels.show,
                        translateX: M,
                        translateY: l
                    });
                    this.ret.add(_)
                }
                return "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret),
                this.ret
            }
        }, {
            key: "drawArcs",
            value: function(e, t) {
                var i = this.w
                  , a = new _e(this.ctx)
                  , s = new U(this.ctx)
                  , r = new wt(this.ctx)
                  , n = s.group({
                    class: "apexcharts-slices"
                })
                  , o = this.initialAngle
                  , h = this.initialAngle
                  , d = this.initialAngle
                  , u = this.initialAngle;
                this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
                for (var p = 0; p < e.length; p++) {
                    var x = s.group({
                        class: "apexcharts-series apexcharts-pie-series",
                        seriesName: D.escapeString(i.globals.seriesNames[p]),
                        rel: p + 1,
                        "data:realIndex": p
                    });
                    n.add(x),
                    d = (o = d) + e[p],
                    u = (h = u) + this.prevSectorAngleArr[p];
                    var b = d < o ? this.fullAngle + d - o : d - o
                      , k = r.fillPath({
                        seriesNumber: p,
                        size: this.sliceSizes[p],
                        value: t[p]
                    })
                      , S = this.getChangedPath(h, u)
                      , E = s.drawPath({
                        d: S,
                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[p] : this.lineColorArr,
                        strokeWidth: 0,
                        fill: k,
                        fillOpacity: i.config.fill.opacity,
                        classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(p)
                    });
                    E.attr({
                        index: 0,
                        j: p
                    }),
                    a.setSelectionFilter(E, 0, p),
                    i.config.chart.dropShadow.enabled && a.dropShadow(E, i.config.chart.dropShadow, p),
                    this.addListeners(E, this.donutDataLabels),
                    U.setAttrs(E.node, {
                        "data:angle": b,
                        "data:startAngle": o,
                        "data:strokeWidth": this.strokeWidth,
                        "data:value": t[p]
                    });
                    var l = {
                        x: 0,
                        y: 0
                    };
                    "pie" === this.chartType || "polarArea" === this.chartType ? l = D.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (o + b / 2) % this.fullAngle) : "donut" === this.chartType && (l = D.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (o + b / 2) % this.fullAngle)),
                    x.add(E);
                    var f = 0;
                    if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (f = b / this.fullAngle * i.config.chart.animations.speed) && (f = 1),
                    this.animDur = f + this.animDur,
                    this.animBeginArr.push(this.animDur)),
                    this.animatePaths(E, this.dynamicAnim && i.globals.dataChanged ? {
                        size: this.sliceSizes[p],
                        endAngle: d,
                        startAngle: o,
                        prevStartAngle: h,
                        prevEndAngle: u,
                        animateStartingPos: !0,
                        i: p,
                        animBeginArr: this.animBeginArr,
                        shouldSetPrevPaths: !0,
                        dur: i.config.chart.animations.dynamicAnimation.speed
                    } : {
                        size: this.sliceSizes[p],
                        endAngle: d,
                        startAngle: o,
                        i: p,
                        totalItems: e.length - 1,
                        animBeginArr: this.animBeginArr,
                        dur: f
                    }),
                    i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && E.click(this.pieClicked.bind(this, p)),
                    void 0 !== i.globals.selectedDataPoints[0] && i.globals.selectedDataPoints[0].indexOf(p) > -1 && this.pieClicked(p),
                    i.config.dataLabels.enabled) {
                        var w = l.x
                          , _ = l.y
                          , R = 100 * b / this.fullAngle + "%";
                        if (0 !== b && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[p]) {
                            var H = i.config.dataLabels.formatter;
                            void 0 !== H && (R = H(i.globals.seriesPercent[p][0], {
                                seriesIndex: p,
                                w: i
                            }));
                            var B = i.globals.dataLabels.style.colors[p]
                              , j = s.group({
                                class: "apexcharts-datalabels"
                            })
                              , ce = s.drawText({
                                x: w,
                                y: _,
                                text: R,
                                textAnchor: "middle",
                                fontSize: i.config.dataLabels.style.fontSize,
                                fontFamily: i.config.dataLabels.style.fontFamily,
                                fontWeight: i.config.dataLabels.style.fontWeight,
                                foreColor: B
                            });
                            j.add(ce),
                            i.config.dataLabels.dropShadow.enabled && a.dropShadow(ce, i.config.dataLabels.dropShadow),
                            ce.node.classList.add("apexcharts-pie-label"),
                            i.config.chart.animations.animate && !1 === i.globals.resized && (ce.node.classList.add("apexcharts-pie-label-delay"),
                            ce.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"),
                            this.sliceLabels.push(j)
                        }
                    }
                }
                return n
            }
        }, {
            key: "addListeners",
            value: function(e, t) {
                var i = new U(this.ctx);
                e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, e)),
                e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, e)),
                e.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e.node, t)),
                e.node.addEventListener("mousedown", i.pathMouseDown.bind(this, e)),
                this.donutDataLabels.total.showAlways || (e.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e.node, t)),
                e.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e.node, t)))
            }
        }, {
            key: "animatePaths",
            value: function(e, t) {
                var a = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle
                  , s = a
                  , r = t.startAngle
                  , n = t.startAngle;
                void 0 !== t.prevStartAngle && void 0 !== t.prevEndAngle && (r = t.prevEndAngle,
                s = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle),
                t.i === this.w.config.series.length - 1 && (a + n > this.fullAngle ? t.endAngle = t.endAngle - (a + n) : a + n < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (a + n)))),
                a === this.fullAngle && (a = this.fullAngle - .01),
                this.animateArc(e, r, n, a, s, t)
            }
        }, {
            key: "animateArc",
            value: function(e, t, i, a, s, r) {
                var n, o = this, h = this.w, d = new Se(this.ctx), u = r.size;
                (isNaN(t) || isNaN(s)) && (t = i,
                s = a,
                r.dur = 0);
                var p = a
                  , x = i
                  , b = t < i ? this.fullAngle + t - i : t - i;
                h.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (n = o.getPiePath({
                    me: o,
                    startAngle: r.prevStartAngle,
                    angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
                    size: u
                }),
                e.attr({
                    d: n
                })),
                0 !== r.dur ? e.animate(r.dur, h.globals.easing, r.animBeginArr[r.i]).afterAll(function() {
                    "pie" !== o.chartType && "donut" !== o.chartType && "polarArea" !== o.chartType || this.animate(h.config.chart.animations.dynamicAnimation.speed).attr({
                        "stroke-width": o.strokeWidth
                    }),
                    r.i === h.config.series.length - 1 && d.animationCompleted(e)
                }).during(function(k) {
                    p = b + (a - b) * k,
                    r.animateStartingPos && (p = s + (a - s) * k,
                    x = t - s + (i - (t - s)) * k),
                    n = o.getPiePath({
                        me: o,
                        startAngle: x,
                        angle: p,
                        size: u
                    }),
                    e.node.setAttribute("data:pathOrig", n),
                    e.attr({
                        d: n
                    })
                }) : (n = o.getPiePath({
                    me: o,
                    startAngle: x,
                    angle: a,
                    size: u
                }),
                r.isTrack || (h.globals.animationEnded = !0),
                e.node.setAttribute("data:pathOrig", n),
                e.attr({
                    d: n,
                    "stroke-width": o.strokeWidth
                }))
            }
        }, {
            key: "pieClicked",
            value: function(e) {
                var t, i = this.w, a = this, s = a.sliceSizes[e] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), r = i.globals.dom.Paper.select(".apexcharts-".concat(a.chartType.toLowerCase(), "-slice-").concat(e)).members[0];
                if ("true" !== r.attr("data:pieClicked")) {
                    var n = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                    Array.prototype.forEach.call(n, function(u) {
                        u.setAttribute("data:pieClicked", "false");
                        var p = u.getAttribute("data:pathOrig");
                        p && u.setAttribute("d", p)
                    }),
                    r.attr("data:pieClicked", "true");
                    var o = parseInt(r.attr("data:startAngle"), 10)
                      , h = parseInt(r.attr("data:angle"), 10);
                    t = a.getPiePath({
                        me: a,
                        startAngle: o,
                        angle: h,
                        size: s
                    }),
                    360 !== h && r.plot(t)
                } else {
                    r.attr({
                        "data:pieClicked": "false"
                    }),
                    this.revertDataLabelsInner(r.node, this.donutDataLabels);
                    var d = r.attr("data:pathOrig");
                    r.attr({
                        d
                    })
                }
            }
        }, {
            key: "getChangedPath",
            value: function(e, t) {
                var i = "";
                return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
                    me: this,
                    startAngle: e,
                    angle: t - e,
                    size: this.size
                })),
                i
            }
        }, {
            key: "getPiePath",
            value: function(e) {
                var t = e.me
                  , i = e.startAngle
                  , a = e.angle
                  , s = e.size
                  , r = i
                  , n = Math.PI * (r - 90) / 180
                  , o = a + i;
                Math.ceil(o) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (o = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01),
                Math.ceil(o) > this.fullAngle && (o -= this.fullAngle);
                var h = Math.PI * (o - 90) / 180
                  , d = t.centerX + s * Math.cos(n)
                  , u = t.centerY + s * Math.sin(n)
                  , p = t.centerX + s * Math.cos(h)
                  , x = t.centerY + s * Math.sin(h)
                  , b = D.polarToCartesian(t.centerX, t.centerY, t.donutSize, o)
                  , k = D.polarToCartesian(t.centerX, t.centerY, t.donutSize, r)
                  , S = a > 180 ? 1 : 0
                  , E = ["M", d, u, "A", s, s, 0, S, 1, p, x];
                return "donut" === t.chartType ? [].concat(E, ["L", b.x, b.y, "A", t.donutSize, t.donutSize, 0, S, 0, k.x, k.y, "L", d, u, "z"]).join(" ") : "pie" === t.chartType || "polarArea" === t.chartType ? [].concat(E, ["L", t.centerX, t.centerY, "L", d, u]).join(" ") : [].concat(E).join(" ")
            }
        }, {
            key: "drawPolarElements",
            value: function(e) {
                var t = this.w
                  , i = new Jt(this.ctx)
                  , a = new U(this.ctx)
                  , s = new Fe(this.ctx)
                  , r = a.group()
                  , n = a.group()
                  , o = i.niceScale(0, Math.ceil(this.maxY), t.config.yaxis[0].tickAmount, 0, !0)
                  , h = o.result.reverse()
                  , d = o.result.length;
                this.maxY = o.niceMax;
                for (var u = t.globals.radialSize, p = u / (d - 1), x = 0; x < d - 1; x++) {
                    var b = a.drawCircle(u);
                    if (b.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: "none",
                        "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth,
                        stroke: t.config.plotOptions.polarArea.rings.strokeColor
                    }),
                    t.config.yaxis[0].show) {
                        var k = s.drawYAxisTexts(this.centerX, this.centerY - u + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, x, h[x]);
                        n.add(k)
                    }
                    r.add(b),
                    u -= p
                }
                this.drawSpokes(e),
                e.add(r),
                e.add(n)
            }
        }, {
            key: "renderInnerDataLabels",
            value: function(e, t) {
                var i = this.w
                  , a = new U(this.ctx)
                  , s = a.group({
                    class: "apexcharts-datalabels-group",
                    transform: "translate(".concat(t.translateX ? t.translateX : 0, ", ").concat(t.translateY ? t.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")
                })
                  , r = e.total.show;
                s.node.style.opacity = t.opacity;
                var n, o, h = t.centerX, d = t.centerY;
                n = void 0 === e.name.color ? i.globals.colors[0] : e.name.color;
                var u = e.name.fontSize
                  , p = e.name.fontFamily
                  , x = e.name.fontWeight;
                o = void 0 === e.value.color ? i.config.chart.foreColor : e.value.color;
                var b = e.value.formatter
                  , k = ""
                  , S = "";
                if (r ? (n = e.total.color,
                u = e.total.fontSize,
                p = e.total.fontFamily,
                x = e.total.fontWeight,
                S = e.total.label,
                k = e.total.formatter(i)) : 1 === i.globals.series.length && (k = b(i.globals.series[0], i),
                S = i.globals.seriesNames[0]),
                S && (S = e.name.formatter(S, e.total.show, i)),
                e.name.show) {
                    var E = a.drawText({
                        x: h,
                        y: d + parseFloat(e.name.offsetY),
                        text: S,
                        textAnchor: "middle",
                        foreColor: n,
                        fontSize: u,
                        fontWeight: x,
                        fontFamily: p
                    });
                    E.node.classList.add("apexcharts-datalabel-label"),
                    s.add(E)
                }
                if (e.value.show) {
                    var M = e.name.show ? parseFloat(e.value.offsetY) + 16 : e.value.offsetY
                      , l = a.drawText({
                        x: h,
                        y: d + M,
                        text: k,
                        textAnchor: "middle",
                        foreColor: o,
                        fontWeight: e.value.fontWeight,
                        fontSize: e.value.fontSize,
                        fontFamily: e.value.fontFamily
                    });
                    l.node.classList.add("apexcharts-datalabel-value"),
                    s.add(l)
                }
                return s
            }
        }, {
            key: "printInnerLabels",
            value: function(e, t, i, a) {
                var s, r = this.w;
                a ? s = void 0 === e.name.color ? r.globals.colors[parseInt(a.parentNode.getAttribute("rel"), 10) - 1] : e.name.color : r.globals.series.length > 1 && e.total.show && (s = e.total.color);
                var n = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label")
                  , o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                i = (0,
                e.value.formatter)(i, r),
                a || "function" != typeof e.total.formatter || (i = e.total.formatter(r)),
                t = e.name.formatter(t, t === e.total.label, r),
                null !== n && (n.textContent = t),
                null !== o && (o.textContent = i),
                null !== n && (n.style.fill = s)
            }
        }, {
            key: "printDataLabelsInner",
            value: function(e, t) {
                var i = this.w
                  , a = e.getAttribute("data:value")
                  , s = i.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1];
                i.globals.series.length > 1 && this.printInnerLabels(t, s, a, e);
                var r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                null !== r && (r.style.opacity = 1)
            }
        }, {
            key: "drawSpokes",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = new U(this.ctx)
                  , s = i.config.plotOptions.polarArea.spokes;
                if (0 !== s.strokeWidth) {
                    for (var r = [], n = 360 / i.globals.series.length, o = 0; o < i.globals.series.length; o++)
                        r.push(D.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + n * o));
                    r.forEach(function(h, d) {
                        var u = a.drawLine(h.x, h.y, t.centerX, t.centerY, Array.isArray(s.connectorColors) ? s.connectorColors[d] : s.connectorColors);
                        e.add(u)
                    })
                }
            }
        }, {
            key: "revertDataLabelsInner",
            value: function(e, t, i) {
                var a = this
                  , s = this.w
                  , r = s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group")
                  , n = !1
                  , o = s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area")
                  , h = function(p) {
                    var x = p.makeSliceOut
                      , b = p.printLabel;
                    Array.prototype.forEach.call(o, function(k) {
                        "true" === k.getAttribute("data:pieClicked") && (x && (n = !0),
                        b && a.printDataLabelsInner(k, t))
                    })
                };
                if (h({
                    makeSliceOut: !0,
                    printLabel: !1
                }),
                t.total.show && s.globals.series.length > 1)
                    n && !t.total.showAlways ? h({
                        makeSliceOut: !1,
                        printLabel: !0
                    }) : this.printInnerLabels(t, t.total.label, t.total.formatter(s));
                else if (h({
                    makeSliceOut: !1,
                    printLabel: !0
                }),
                !n)
                    if (s.globals.selectedDataPoints.length && s.globals.series.length > 1)
                        if (s.globals.selectedDataPoints[0].length > 0) {
                            var d = s.globals.selectedDataPoints[0]
                              , u = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d));
                            this.printDataLabelsInner(u, t)
                        } else
                            r && s.globals.selectedDataPoints.length && 0 === s.globals.selectedDataPoints[0].length && (r.style.opacity = 0);
                    else
                        r && s.globals.series.length > 1 && (r.style.opacity = 0)
            }
        }]),
        C
    }()
      , Ye = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.chartType = this.w.config.chart.type,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled,
            this.animDur = 0;
            var t = this.w;
            this.graphics = new U(this.ctx),
            this.lineColorArr = void 0 !== t.globals.stroke.colors ? t.globals.stroke.colors : t.globals.colors,
            this.defaultSize = t.globals.svgHeight < t.globals.svgWidth ? t.globals.gridHeight + 1.5 * t.globals.goldenPadding : t.globals.gridWidth,
            this.isLog = t.config.yaxis[0].logarithmic,
            this.coreUtils = new ae(this.ctx),
            this.maxValue = this.isLog ? this.coreUtils.getLogVal(t.globals.maxY, 0) : t.globals.maxY,
            this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : t.globals.minY,
            this.polygons = t.config.plotOptions.radar.polygons,
            this.strokeWidth = t.config.stroke.show ? t.config.stroke.width : 0,
            this.size = this.defaultSize / 2.1 - this.strokeWidth - t.config.chart.dropShadow.blur,
            t.config.xaxis.labels.show && (this.size = this.size - t.globals.xAxisLabelsWidth / 1.75),
            void 0 !== t.config.plotOptions.radar.size && (this.size = t.config.plotOptions.radar.size),
            this.dataRadiusOfPercent = [],
            this.dataRadius = [],
            this.angleArr = [],
            this.yaxisLabelsTextsPos = []
        }
        return Te(C, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = new wt(this.ctx)
                  , s = []
                  , r = new It(this.ctx);
                e.length && (this.dataPointsLen = e[i.globals.maxValsInArrayIndex].length),
                this.disAngle = 2 * Math.PI / this.dataPointsLen;
                var d = i.globals.gridHeight / 2 + i.config.plotOptions.radar.offsetY
                  , u = this.graphics.group({
                    class: "apexcharts-radar-series apexcharts-plot-series",
                    transform: "translate(".concat(i.globals.gridWidth / 2 + i.config.plotOptions.radar.offsetX || 0, ", ").concat(d || 0, ")")
                })
                  , p = []
                  , x = null
                  , b = null;
                if (this.yaxisLabels = this.graphics.group({
                    class: "apexcharts-yaxis"
                }),
                e.forEach(function(S, E) {
                    var M = S.length === i.globals.dataPoints
                      , l = t.graphics.group().attr({
                        class: "apexcharts-series",
                        "data:longestSeries": M,
                        seriesName: D.escapeString(i.globals.seriesNames[E]),
                        rel: E + 1,
                        "data:realIndex": E
                    });
                    t.dataRadiusOfPercent[E] = [],
                    t.dataRadius[E] = [],
                    t.angleArr[E] = [],
                    S.forEach(function(ue, Ee) {
                        var Ie = Math.abs(t.maxValue - t.minValue);
                        ue += Math.abs(t.minValue),
                        t.isLog && (ue = t.coreUtils.getLogVal(ue, 0)),
                        t.dataRadiusOfPercent[E][Ee] = ue / Ie,
                        t.dataRadius[E][Ee] = t.dataRadiusOfPercent[E][Ee] * t.size,
                        t.angleArr[E][Ee] = Ee * t.disAngle
                    }),
                    p = t.getDataPointsPos(t.dataRadius[E], t.angleArr[E]);
                    var f = t.createPaths(p, {
                        x: 0,
                        y: 0
                    });
                    x = t.graphics.group({
                        class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
                    }),
                    b = t.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": E
                    }),
                    i.globals.delayedElements.push({
                        el: x.node,
                        index: E
                    });
                    var w = {
                        i: E,
                        realIndex: E,
                        animationDelay: E,
                        initialSpeed: i.config.chart.animations.speed,
                        dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
                        className: "apexcharts-radar",
                        shouldClipToGrid: !1,
                        bindEventsOnPaths: !1,
                        stroke: i.globals.stroke.colors[E],
                        strokeLineCap: i.config.stroke.lineCap
                    }
                      , _ = null;
                    i.globals.previousPaths.length > 0 && (_ = t.getPreviousPath(E));
                    for (var R = 0; R < f.linePathsTo.length; R++) {
                        var H = t.graphics.renderPaths(K(K({}, w), {}, {
                            pathFrom: null === _ ? f.linePathsFrom[R] : _,
                            pathTo: f.linePathsTo[R],
                            strokeWidth: Array.isArray(t.strokeWidth) ? t.strokeWidth[E] : t.strokeWidth,
                            fill: "none",
                            drawShadow: !1
                        }));
                        l.add(H);
                        var B = a.fillPath({
                            seriesNumber: E
                        })
                          , j = t.graphics.renderPaths(K(K({}, w), {}, {
                            pathFrom: null === _ ? f.areaPathsFrom[R] : _,
                            pathTo: f.areaPathsTo[R],
                            strokeWidth: 0,
                            fill: B,
                            drawShadow: !1
                        }));
                        i.config.chart.dropShadow.enabled && new _e(t.ctx).dropShadow(j, Object.assign({}, i.config.chart.dropShadow, {
                            noUserSpaceOnUse: !0
                        }), E),
                        l.add(j)
                    }
                    S.forEach(function(ue, Ee) {
                        var Ie = new ye(t.ctx).getMarkerConfig({
                            cssClass: "apexcharts-marker",
                            seriesIndex: E,
                            dataPointIndex: Ee
                        })
                          , rt = t.graphics.drawMarker(p[Ee].x, p[Ee].y, Ie);
                        rt.attr("rel", Ee),
                        rt.attr("j", Ee),
                        rt.attr("index", E),
                        rt.node.setAttribute("default-marker-size", Ie.pSize);
                        var nt = t.graphics.group({
                            class: "apexcharts-series-markers"
                        });
                        nt && nt.add(rt),
                        x.add(nt),
                        l.add(x);
                        var ht = i.config.dataLabels;
                        if (ht.enabled) {
                            var vt = ht.formatter(i.globals.series[E][Ee], {
                                seriesIndex: E,
                                dataPointIndex: Ee,
                                w: i
                            });
                            r.plotDataLabelsText({
                                x: p[Ee].x,
                                y: p[Ee].y,
                                text: vt,
                                textAnchor: "middle",
                                i: E,
                                j: E,
                                parent: b,
                                offsetCorrection: !1,
                                dataLabelsConfig: K({}, ht)
                            })
                        }
                        l.add(b)
                    }),
                    s.push(l)
                }),
                this.drawPolygons({
                    parent: u
                }),
                i.config.xaxis.labels.show) {
                    var k = this.drawXAxisTexts();
                    u.add(k)
                }
                return s.forEach(function(S) {
                    u.add(S)
                }),
                u.add(this.yaxisLabels),
                u
            }
        }, {
            key: "drawPolygons",
            value: function(e) {
                for (var t = this, i = this.w, a = e.parent, s = new Fe(this.ctx), r = i.globals.yAxisScale[0].result.reverse(), n = r.length, o = [], h = this.size / (n - 1), d = 0; d < n; d++)
                    o[d] = h * d;
                o.reverse();
                var u = []
                  , p = [];
                o.forEach(function(x, b) {
                    var k = D.getPolygonPos(x, t.dataPointsLen)
                      , S = "";
                    k.forEach(function(E, M) {
                        if (0 === b) {
                            var l = t.graphics.drawLine(E.x, E.y, 0, 0, Array.isArray(t.polygons.connectorColors) ? t.polygons.connectorColors[M] : t.polygons.connectorColors);
                            p.push(l)
                        }
                        0 === M && t.yaxisLabelsTextsPos.push({
                            x: E.x,
                            y: E.y
                        }),
                        S += E.x + "," + E.y + " "
                    }),
                    u.push(S)
                }),
                u.forEach(function(x, b) {
                    var k = t.polygons.strokeColors
                      , S = t.polygons.strokeWidth
                      , E = t.graphics.drawPolygon(x, Array.isArray(k) ? k[b] : k, Array.isArray(S) ? S[b] : S, i.globals.radarPolygons.fill.colors[b]);
                    a.add(E)
                }),
                p.forEach(function(x) {
                    a.add(x)
                }),
                i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(x, b) {
                    var k = s.drawYAxisTexts(x.x, x.y, b, r[b]);
                    t.yaxisLabels.add(k)
                })
            }
        }, {
            key: "drawXAxisTexts",
            value: function() {
                var e = this
                  , t = this.w
                  , i = t.config.xaxis.labels
                  , a = this.graphics.group({
                    class: "apexcharts-xaxis"
                })
                  , s = D.getPolygonPos(this.size, this.dataPointsLen);
                return t.globals.labels.forEach(function(r, n) {
                    var o = t.config.xaxis.labels.formatter
                      , h = new It(e.ctx);
                    if (s[n]) {
                        var d = e.getTextPos(s[n], e.size)
                          , u = o(r, {
                            seriesIndex: -1,
                            dataPointIndex: n,
                            w: t
                        });
                        h.plotDataLabelsText({
                            x: d.newX,
                            y: d.newY,
                            text: u,
                            textAnchor: d.textAnchor,
                            i: n,
                            j: n,
                            parent: a,
                            color: Array.isArray(i.style.colors) && i.style.colors[n] ? i.style.colors[n] : "#a8a8a8",
                            dataLabelsConfig: K({
                                textAnchor: d.textAnchor,
                                dropShadow: {
                                    enabled: !1
                                }
                            }, i),
                            offsetCorrection: !1
                        })
                    }
                }),
                a
            }
        }, {
            key: "createPaths",
            value: function(e, t) {
                var i = this
                  , a = []
                  , s = []
                  , r = []
                  , n = [];
                if (e.length) {
                    s = [this.graphics.move(t.x, t.y)],
                    n = [this.graphics.move(t.x, t.y)];
                    var o = this.graphics.move(e[0].x, e[0].y)
                      , h = this.graphics.move(e[0].x, e[0].y);
                    e.forEach(function(d, u) {
                        o += i.graphics.line(d.x, d.y),
                        h += i.graphics.line(d.x, d.y),
                        u === e.length - 1 && (o += "Z",
                        h += "Z")
                    }),
                    a.push(o),
                    r.push(h)
                }
                return {
                    linePathsFrom: s,
                    linePathsTo: a,
                    areaPathsFrom: n,
                    areaPathsTo: r
                }
            }
        }, {
            key: "getTextPos",
            value: function(e, t) {
                var i = "middle"
                  , a = e.x
                  , s = e.y;
                return Math.abs(e.x) >= 10 ? e.x > 0 ? (i = "start",
                a += 10) : e.x < 0 && (i = "end",
                a -= 10) : i = "middle",
                Math.abs(e.y) >= t - 10 && (e.y < 0 ? s -= 10 : e.y > 0 && (s += 10)),
                {
                    textAnchor: i,
                    newX: a,
                    newY: s
                }
            }
        }, {
            key: "getPreviousPath",
            value: function(e) {
                for (var t = this.w, i = null, a = 0; a < t.globals.previousPaths.length; a++) {
                    var s = t.globals.previousPaths[a];
                    s.paths.length > 0 && parseInt(s.realIndex, 10) === parseInt(e, 10) && void 0 !== t.globals.previousPaths[a].paths[0] && (i = t.globals.previousPaths[a].paths[0].d)
                }
                return i
            }
        }, {
            key: "getDataPointsPos",
            value: function(e, t) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                e = e || [],
                t = t || [];
                for (var a = [], s = 0; s < i; s++) {
                    var r = {};
                    r.x = e[s] * Math.sin(t[s]),
                    r.y = -e[s] * Math.cos(t[s]),
                    a.push(r)
                }
                return a
            }
        }]),
        C
    }()
      , Ue = function(C) {
        pe(t, C);
        var e = He(t);
        function t(i) {
            var a;
            Q(this, t),
            (a = e.call(this, i)).ctx = i,
            a.w = i.w,
            a.animBeginArr = [0],
            a.animDur = 0;
            var s = a.w;
            return a.startAngle = s.config.plotOptions.radialBar.startAngle,
            a.endAngle = s.config.plotOptions.radialBar.endAngle,
            a.totalAngle = Math.abs(s.config.plotOptions.radialBar.endAngle - s.config.plotOptions.radialBar.startAngle),
            a.trackStartAngle = s.config.plotOptions.radialBar.track.startAngle,
            a.trackEndAngle = s.config.plotOptions.radialBar.track.endAngle,
            a.donutDataLabels = a.w.config.plotOptions.radialBar.dataLabels,
            a.radialDataLabels = a.donutDataLabels,
            a.trackStartAngle || (a.trackStartAngle = a.startAngle),
            a.trackEndAngle || (a.trackEndAngle = a.endAngle),
            360 === a.endAngle && (a.endAngle = 359.99),
            a.margin = parseInt(s.config.plotOptions.radialBar.track.margin, 10),
            a
        }
        return Te(t, [{
            key: "draw",
            value: function(i) {
                var a = this.w
                  , s = new U(this.ctx)
                  , r = s.group({
                    class: "apexcharts-radialbar"
                });
                if (a.globals.noData)
                    return r;
                var n = s.group()
                  , o = this.defaultSize / 2
                  , h = a.globals.gridWidth / 2
                  , d = this.defaultSize / 2.05;
                a.config.chart.sparkline.enabled || (d = d - a.config.stroke.width - a.config.chart.dropShadow.blur);
                var u = a.globals.fill.colors;
                if (a.config.plotOptions.radialBar.track.show) {
                    var p = this.drawTracks({
                        size: d,
                        centerX: h,
                        centerY: o,
                        colorArr: u,
                        series: i
                    });
                    n.add(p)
                }
                var x = this.drawArcs({
                    size: d,
                    centerX: h,
                    centerY: o,
                    colorArr: u,
                    series: i
                })
                  , b = 360;
                a.config.plotOptions.radialBar.startAngle < 0 && (b = this.totalAngle);
                var k = (360 - b) / 360;
                if (a.globals.radialSize = d - d * k,
                this.radialDataLabels.value.show) {
                    var S = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                    a.globals.radialSize += S * k
                }
                return n.add(x.g),
                "front" === a.config.plotOptions.radialBar.hollow.position && (x.g.add(x.elHollow),
                x.dataLabels && x.g.add(x.dataLabels)),
                r.add(n),
                r
            }
        }, {
            key: "drawTracks",
            value: function(i) {
                var a = this.w
                  , s = new U(this.ctx)
                  , r = s.group({
                    class: "apexcharts-tracks"
                })
                  , n = new _e(this.ctx)
                  , o = new wt(this.ctx)
                  , h = this.getStrokeWidth(i);
                i.size = i.size - h / 2;
                for (var d = 0; d < i.series.length; d++) {
                    var u = s.group({
                        class: "apexcharts-radialbar-track apexcharts-track"
                    });
                    r.add(u),
                    u.attr({
                        rel: d + 1
                    }),
                    i.size = i.size - h - this.margin;
                    var p = a.config.plotOptions.radialBar.track
                      , x = o.fillPath({
                        seriesNumber: 0,
                        size: i.size,
                        fillColors: Array.isArray(p.background) ? p.background[d] : p.background,
                        solid: !0
                    })
                      , b = this.trackStartAngle
                      , k = this.trackEndAngle;
                    Math.abs(k) + Math.abs(b) >= 360 && (k = 360 - Math.abs(this.startAngle) - .1);
                    var S = s.drawPath({
                        d: "",
                        stroke: x,
                        strokeWidth: h * parseInt(p.strokeWidth, 10) / 100,
                        fill: "none",
                        strokeOpacity: p.opacity,
                        classes: "apexcharts-radialbar-area"
                    });
                    p.dropShadow.enabled && n.dropShadow(S, p.dropShadow),
                    u.add(S),
                    S.attr("id", "apexcharts-radialbarTrack-" + d),
                    this.animatePaths(S, {
                        centerX: i.centerX,
                        centerY: i.centerY,
                        endAngle: k,
                        startAngle: b,
                        size: i.size,
                        i: d,
                        totalItems: 2,
                        animBeginArr: 0,
                        dur: 0,
                        isTrack: !0,
                        easing: a.globals.easing
                    })
                }
                return r
            }
        }, {
            key: "drawArcs",
            value: function(i) {
                var a = this.w
                  , s = new U(this.ctx)
                  , r = new wt(this.ctx)
                  , n = new _e(this.ctx)
                  , o = s.group()
                  , h = this.getStrokeWidth(i);
                i.size = i.size - h / 2;
                var d = a.config.plotOptions.radialBar.hollow.background
                  , u = i.size - h * i.series.length - this.margin * i.series.length - h * parseInt(a.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2
                  , p = u - a.config.plotOptions.radialBar.hollow.margin;
                void 0 !== a.config.plotOptions.radialBar.hollow.image && (d = this.drawHollowImage(i, o, u, d));
                var x = this.drawHollow({
                    size: p,
                    centerX: i.centerX,
                    centerY: i.centerY,
                    fill: d || "transparent"
                });
                a.config.plotOptions.radialBar.hollow.dropShadow.enabled && n.dropShadow(x, a.config.plotOptions.radialBar.hollow.dropShadow);
                var k = 1;
                !this.radialDataLabels.total.show && a.globals.series.length > 1 && (k = 0);
                var S = null;
                this.radialDataLabels.show && (S = this.renderInnerDataLabels(this.radialDataLabels, {
                    hollowSize: u,
                    centerX: i.centerX,
                    centerY: i.centerY,
                    opacity: k
                })),
                "back" === a.config.plotOptions.radialBar.hollow.position && (o.add(x),
                S && o.add(S));
                var E = !1;
                a.config.plotOptions.radialBar.inverseOrder && (E = !0);
                for (var M = E ? i.series.length - 1 : 0; E ? M >= 0 : M < i.series.length; E ? M-- : M++) {
                    var l = s.group({
                        class: "apexcharts-series apexcharts-radial-series",
                        seriesName: D.escapeString(a.globals.seriesNames[M])
                    });
                    o.add(l),
                    l.attr({
                        rel: M + 1,
                        "data:realIndex": M
                    }),
                    this.ctx.series.addCollapsedClassToSeries(l, M),
                    i.size = i.size - h - this.margin;
                    var f = r.fillPath({
                        seriesNumber: M,
                        size: i.size,
                        value: i.series[M]
                    })
                      , w = this.startAngle
                      , _ = void 0
                      , R = D.negToZero(i.series[M] > 100 ? 100 : i.series[M]) / 100
                      , H = Math.round(this.totalAngle * R) + this.startAngle
                      , B = void 0;
                    a.globals.dataChanged && (_ = this.startAngle,
                    B = Math.round(this.totalAngle * D.negToZero(a.globals.previousPaths[M]) / 100) + _),
                    Math.abs(H) + Math.abs(w) >= 360 && (H -= .01),
                    Math.abs(B) + Math.abs(_) >= 360 && (B -= .01);
                    var j = H - w
                      , ce = Array.isArray(a.config.stroke.dashArray) ? a.config.stroke.dashArray[M] : a.config.stroke.dashArray
                      , me = s.drawPath({
                        d: "",
                        stroke: f,
                        strokeWidth: h,
                        fill: "none",
                        fillOpacity: a.config.fill.opacity,
                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + M,
                        strokeDashArray: ce
                    });
                    U.setAttrs(me.node, {
                        "data:angle": j,
                        "data:value": i.series[M]
                    }),
                    a.config.chart.dropShadow.enabled && n.dropShadow(me, a.config.chart.dropShadow, M),
                    n.setSelectionFilter(me, 0, M),
                    this.addListeners(me, this.radialDataLabels),
                    l.add(me),
                    me.attr({
                        index: 0,
                        j: M
                    });
                    var Ee = 0;
                    !this.initialAnim || a.globals.resized || a.globals.dataChanged || (Ee = a.config.chart.animations.speed),
                    a.globals.dataChanged && (Ee = a.config.chart.animations.dynamicAnimation.speed),
                    this.animDur = Ee / (1.2 * i.series.length) + this.animDur,
                    this.animBeginArr.push(this.animDur),
                    this.animatePaths(me, {
                        centerX: i.centerX,
                        centerY: i.centerY,
                        endAngle: H,
                        startAngle: w,
                        prevEndAngle: B,
                        prevStartAngle: _,
                        size: i.size,
                        i: M,
                        totalItems: 2,
                        animBeginArr: this.animBeginArr,
                        dur: Ee,
                        shouldSetPrevPaths: !0,
                        easing: a.globals.easing
                    })
                }
                return {
                    g: o,
                    elHollow: x,
                    dataLabels: S
                }
            }
        }, {
            key: "drawHollow",
            value: function(i) {
                var a = new U(this.ctx).drawCircle(2 * i.size);
                return a.attr({
                    class: "apexcharts-radialbar-hollow",
                    cx: i.centerX,
                    cy: i.centerY,
                    r: i.size,
                    fill: i.fill
                }),
                a
            }
        }, {
            key: "drawHollowImage",
            value: function(i, a, s, r) {
                var n = this.w
                  , o = new wt(this.ctx)
                  , h = D.randomId()
                  , d = n.config.plotOptions.radialBar.hollow.image;
                if (n.config.plotOptions.radialBar.hollow.imageClipped)
                    o.clippedImgArea({
                        width: s,
                        height: s,
                        image: d,
                        patternID: "pattern".concat(n.globals.cuid).concat(h)
                    }),
                    r = "url(#pattern".concat(n.globals.cuid).concat(h, ")");
                else {
                    var u = n.config.plotOptions.radialBar.hollow.imageWidth
                      , p = n.config.plotOptions.radialBar.hollow.imageHeight;
                    if (void 0 === u && void 0 === p) {
                        var x = n.globals.dom.Paper.image(d).loaded(function(k) {
                            this.move(i.centerX - k.width / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - k.height / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY)
                        });
                        a.add(x)
                    } else {
                        var b = n.globals.dom.Paper.image(d).loaded(function(k) {
                            this.move(i.centerX - u / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - p / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY),
                            this.size(u, p)
                        });
                        a.add(b)
                    }
                }
                return r
            }
        }, {
            key: "getStrokeWidth",
            value: function(i) {
                return i.size * (100 - parseInt(this.w.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin
            }
        }]),
        t
    }(Qe)
      , st = function(C) {
        pe(t, C);
        var e = He(t);
        function t() {
            return Q(this, t),
            e.apply(this, arguments)
        }
        return Te(t, [{
            key: "draw",
            value: function(i, a) {
                var s = this.w
                  , r = new U(this.ctx);
                this.rangeBarOptions = this.w.config.plotOptions.rangeBar,
                this.series = i,
                this.seriesRangeStart = s.globals.seriesRangeStart,
                this.seriesRangeEnd = s.globals.seriesRangeEnd,
                this.barHelpers.initVariables(i);
                for (var n = r.group({
                    class: "apexcharts-rangebar-series apexcharts-plot-series"
                }), o = 0; o < i.length; o++) {
                    var h, d, u, p, x = void 0, b = void 0, k = s.globals.comboCharts ? a[o] : o, S = r.group({
                        class: "apexcharts-series",
                        seriesName: D.escapeString(s.globals.seriesNames[k]),
                        rel: o + 1,
                        "data:realIndex": k
                    });
                    this.ctx.series.addCollapsedClassToSeries(S, k),
                    i[o].length > 0 && (this.visibleI = this.visibleI + 1);
                    var E = 0
                      , M = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = k);
                    var l = this.barHelpers.initialPositions();
                    b = l.y,
                    p = l.zeroW,
                    x = l.x,
                    M = l.barWidth,
                    E = l.barHeight,
                    h = l.xDivision,
                    d = l.yDivision,
                    u = l.zeroH;
                    for (var f = r.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": k
                    }), w = r.group({
                        class: "apexcharts-rangebar-goals-markers"
                    }), _ = 0; _ < s.globals.dataPoints; _++) {
                        var R, H = this.barHelpers.getStrokeWidth(o, _, k), B = this.seriesRangeStart[o][_], j = this.seriesRangeEnd[o][_], ce = null, me = null, ue = null, Ee = {
                            x,
                            y: b,
                            strokeWidth: H,
                            elSeries: S
                        }, Ie = this.seriesLen;
                        if (s.config.plotOptions.bar.rangeBarGroupRows && (Ie = 1),
                        void 0 === s.config.series[o].data[_])
                            break;
                        if (this.isHorizontal) {
                            if (ue = b + E * this.visibleI,
                            s.config.series[o].data[_].x) {
                                var nt = this.detectOverlappingBars({
                                    i: o,
                                    j: _,
                                    barYPosition: ue,
                                    srty: (d - E * Ie) / 2,
                                    barHeight: E,
                                    yDivision: d,
                                    initPositions: l
                                });
                                E = nt.barHeight,
                                ue = nt.barYPosition
                            }
                            M = (ce = this.drawRangeBarPaths(K({
                                indexes: {
                                    i: o,
                                    j: _,
                                    realIndex: k
                                },
                                barHeight: E,
                                barYPosition: ue,
                                zeroW: p,
                                yDivision: d,
                                y1: B,
                                y2: j
                            }, Ee))).barWidth
                        } else {
                            if (s.globals.isXNumeric && (x = (s.globals.seriesX[o][_] - s.globals.minX) / this.xRatio - M / 2),
                            me = x + M * this.visibleI,
                            s.config.series[o].data[_].x) {
                                var vt = this.detectOverlappingBars({
                                    i: o,
                                    j: _,
                                    barXPosition: me,
                                    srtx: (h - M * Ie) / 2,
                                    barWidth: M,
                                    xDivision: h,
                                    initPositions: l
                                });
                                M = vt.barWidth,
                                me = vt.barXPosition
                            }
                            E = (ce = this.drawRangeColumnPaths(K({
                                indexes: {
                                    i: o,
                                    j: _,
                                    realIndex: k
                                },
                                barWidth: M,
                                barXPosition: me,
                                zeroH: u,
                                xDivision: h
                            }, Ee))).barHeight
                        }
                        var mt = this.barHelpers.drawGoalLine({
                            barXPosition: ce.barXPosition,
                            barYPosition: ue,
                            goalX: ce.goalX,
                            goalY: ce.goalY,
                            barHeight: E,
                            barWidth: M
                        });
                        mt && w.add(mt),
                        b = ce.y,
                        x = ce.x;
                        var _t = this.barHelpers.getPathFillColor(i, o, _, k);
                        this.renderSeries((Re(R = {
                            realIndex: k,
                            pathFill: _t,
                            lineFill: s.globals.stroke.colors[k],
                            j: _,
                            i: o,
                            x,
                            y: b,
                            y1: B,
                            y2: j,
                            pathFrom: ce.pathFrom,
                            pathTo: ce.pathTo,
                            strokeWidth: H,
                            elSeries: S,
                            series: i,
                            barHeight: E,
                            barWidth: M,
                            barXPosition: me,
                            barYPosition: ue
                        }, "barWidth", M),
                        Re(R, "elDataLabelsWrap", f),
                        Re(R, "elGoalsMarkers", w),
                        Re(R, "visibleSeries", this.visibleI),
                        Re(R, "type", "rangebar"),
                        R))
                    }
                    n.add(S)
                }
                return n
            }
        }, {
            key: "detectOverlappingBars",
            value: function(i) {
                var a = i.i
                  , s = i.j
                  , r = i.barYPosition
                  , n = i.barXPosition
                  , o = i.srty
                  , h = i.srtx
                  , d = i.barHeight
                  , u = i.barWidth
                  , p = i.yDivision
                  , x = i.xDivision
                  , b = i.initPositions
                  , k = this.w
                  , S = []
                  , E = k.config.series[a].data[s].rangeName
                  , M = k.config.series[a].data[s].x
                  , l = Array.isArray(M) ? M.join(" ") : M
                  , f = k.globals.labels.map(function(_) {
                    return Array.isArray(_) ? _.join(" ") : _
                }).indexOf(l)
                  , w = k.globals.seriesRange[a].findIndex(function(_) {
                    return _.x === l && _.overlaps.length > 0
                });
                return this.isHorizontal ? (r = k.config.plotOptions.bar.rangeBarGroupRows ? o + p * f : o + d * this.visibleI + p * f,
                w > -1 && !k.config.plotOptions.bar.rangeBarOverlap && (S = k.globals.seriesRange[a][w].overlaps).indexOf(E) > -1 && (r = (d = b.barHeight / S.length) * this.visibleI + p * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + d * (this.visibleI + S.indexOf(E)) + p * f)) : (f > -1 && (n = k.config.plotOptions.bar.rangeBarGroupRows ? h + x * f : h + u * this.visibleI + x * f),
                w > -1 && !k.config.plotOptions.bar.rangeBarOverlap && (S = k.globals.seriesRange[a][w].overlaps).indexOf(E) > -1 && (n = (u = b.barWidth / S.length) * this.visibleI + x * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + u * (this.visibleI + S.indexOf(E)) + x * f)),
                {
                    barYPosition: r,
                    barXPosition: n,
                    barHeight: d,
                    barWidth: u
                }
            }
        }, {
            key: "drawRangeColumnPaths",
            value: function(i) {
                var a = i.indexes
                  , s = i.x
                  , r = i.xDivision
                  , n = i.barWidth
                  , o = i.barXPosition
                  , h = i.zeroH
                  , d = this.w
                  , u = a.i
                  , p = a.j
                  , x = this.yRatio[this.yaxisIndex]
                  , b = a.realIndex
                  , k = this.getRangeValue(b, p)
                  , S = Math.min(k.start, k.end)
                  , E = Math.max(k.start, k.end);
                null == this.series[u][p] ? S = h : (S = h - S / x,
                E = h - E / x);
                var M = Math.abs(E - S)
                  , l = this.barHelpers.getColumnPaths({
                    barXPosition: o,
                    barWidth: n,
                    y1: S,
                    y2: E,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    realIndex: a.realIndex,
                    i: b,
                    j: p,
                    w: d
                });
                return d.globals.isXNumeric || (s += r),
                {
                    pathTo: l.pathTo,
                    pathFrom: l.pathFrom,
                    barHeight: M,
                    x: s,
                    y: E,
                    goalY: this.barHelpers.getGoalValues("y", null, h, u, p),
                    barXPosition: o
                }
            }
        }, {
            key: "drawRangeBarPaths",
            value: function(i) {
                var a = i.indexes
                  , s = i.y
                  , o = i.yDivision
                  , h = i.barHeight
                  , d = i.barYPosition
                  , u = i.zeroW
                  , p = this.w
                  , x = u + i.y1 / this.invertedYRatio
                  , b = u + i.y2 / this.invertedYRatio
                  , k = Math.abs(b - x)
                  , S = this.barHelpers.getBarpaths({
                    barYPosition: d,
                    barHeight: h,
                    x1: x,
                    x2: b,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    i: a.realIndex,
                    realIndex: a.realIndex,
                    j: a.j,
                    w: p
                });
                return p.globals.isXNumeric || (s += o),
                {
                    pathTo: S.pathTo,
                    pathFrom: S.pathFrom,
                    barWidth: k,
                    x: b,
                    goalX: this.barHelpers.getGoalValues("x", u, null, a.realIndex, a.j),
                    y: s
                }
            }
        }, {
            key: "getRangeValue",
            value: function(i, a) {
                var s = this.w;
                return {
                    start: s.globals.seriesRangeStart[i][a],
                    end: s.globals.seriesRangeEnd[i][a]
                }
            }
        }]),
        t
    }(xe)
      , tt = function() {
        function C(e) {
            Q(this, C),
            this.w = e.w,
            this.lineCtx = e
        }
        return Te(C, [{
            key: "sameValueSeriesFix",
            value: function(e, t) {
                var i = this.w;
                if (("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[e]) && new ae(this.lineCtx.ctx,i).seriesHaveSameValues(e)) {
                    var a = t[e].slice();
                    a[a.length - 1] = a[a.length - 1] + 1e-6,
                    t[e] = a
                }
                return t
            }
        }, {
            key: "calculatePoints",
            value: function(e) {
                var t = e.series
                  , a = e.x
                  , s = e.y
                  , r = e.i
                  , n = e.j
                  , o = e.prevY
                  , h = this.w
                  , d = []
                  , u = [];
                if (0 === n) {
                    var p = this.lineCtx.categoryAxisCorrection + h.config.markers.offsetX;
                    h.globals.isXNumeric && (p = (h.globals.seriesX[e.realIndex][0] - h.globals.minX) / this.lineCtx.xRatio + h.config.markers.offsetX),
                    d.push(p),
                    u.push(D.isNumber(t[r][0]) ? o + h.config.markers.offsetY : null),
                    d.push(a + h.config.markers.offsetX),
                    u.push(D.isNumber(t[r][n + 1]) ? s + h.config.markers.offsetY : null)
                } else
                    d.push(a + h.config.markers.offsetX),
                    u.push(D.isNumber(t[r][n + 1]) ? s + h.config.markers.offsetY : null);
                return {
                    x: d,
                    y: u
                }
            }
        }, {
            key: "checkPreviousPaths",
            value: function(e) {
                for (var t = e.pathFromLine, i = e.pathFromArea, a = e.realIndex, s = this.w, r = 0; r < s.globals.previousPaths.length; r++) {
                    var n = s.globals.previousPaths[r];
                    ("line" === n.type || "area" === n.type) && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(a, 10) && ("line" === n.type ? (this.lineCtx.appendPathFrom = !1,
                    t = s.globals.previousPaths[r].paths[0].d) : "area" === n.type && (this.lineCtx.appendPathFrom = !1,
                    i = s.globals.previousPaths[r].paths[0].d,
                    s.config.stroke.show && s.globals.previousPaths[r].paths[1] && (t = s.globals.previousPaths[r].paths[1].d)))
                }
                return {
                    pathFromLine: t,
                    pathFromArea: i
                }
            }
        }, {
            key: "determineFirstPrevY",
            value: function(e) {
                var t, i = e.i, a = e.series, s = e.prevY, r = e.lineYPosition, n = this.w;
                if (void 0 !== (null === (t = a[i]) || void 0 === t ? void 0 : t[0]))
                    s = (r = n.config.chart.stacked && i > 0 ? this.lineCtx.prevSeriesY[i - 1][0] : this.lineCtx.zeroY) - a[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? a[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                else if (n.config.chart.stacked && i > 0 && void 0 === a[i][0])
                    for (var o = i - 1; o >= 0; o--)
                        if (null != a[o][0]) {
                            s = r = this.lineCtx.prevSeriesY[o][0];
                            break
                        }
                return {
                    prevY: s,
                    lineYPosition: r
                }
            }
        }]),
        C
    }()
      , ti = function(C) {
        for (var e = "", t = 0; t < C.length; t++) {
            var i = C[t]
              , a = i.length;
            a > 4 ? (e += "C".concat(i[0], ", ").concat(i[1]),
            e += ", ".concat(i[2], ", ").concat(i[3]),
            e += ", ".concat(i[4], ", ").concat(i[5])) : a > 2 && (e += "S".concat(i[0], ", ").concat(i[1]),
            e += ", ".concat(i[2], ", ").concat(i[3]))
        }
        return e
    }
      , hi = function(C) {
        var e = function(C) {
            for (var e, t, i, a, s = function(d) {
                for (var u = [], p = d[0], x = d[1], b = u[0] = Vt(p, x), k = 1, S = d.length - 1; k < S; k++)
                    u[k] = .5 * (b + (b = Vt(p = x, x = d[k + 1])));
                return u[k] = b,
                u
            }(C), r = C.length - 1, n = [], o = 0; o < r; o++)
                i = Vt(C[o], C[o + 1]),
                Math.abs(i) < 1e-6 ? s[o] = s[o + 1] = 0 : (a = (e = s[o] / i) * e + (t = s[o + 1] / i) * t) > 9 && (a = 3 * i / Math.sqrt(a),
                s[o] = a * e,
                s[o + 1] = a * t);
            for (var h = 0; h <= r; h++)
                a = (C[Math.min(r, h + 1)][0] - C[Math.max(0, h - 1)][0]) / (6 * (1 + s[h] * s[h])),
                n.push([a || 0, s[h] * a || 0]);
            return n
        }(C)
          , t = C[1]
          , i = C[0]
          , a = []
          , s = e[1]
          , r = e[0];
        a.push(i, [i[0] + r[0], i[1] + r[1], t[0] - s[0], t[1] - s[1], t[0], t[1]]);
        for (var n = 2, o = e.length; n < o; n++) {
            var h = C[n]
              , d = e[n];
            a.push([h[0] - d[0], h[1] - d[1], h[0], h[1]])
        }
        return a
    };
    function Vt(C, e) {
        return (e[1] - C[1]) / (e[0] - C[0])
    }
    var vi = function() {
        function C(e, t, i) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.xyRatios = t,
            this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || i,
            this.scatter = new gi(this.ctx),
            this.noNegatives = this.w.globals.minX === Number.MAX_VALUE,
            this.lineHelpers = new tt(this),
            this.markers = new ye(this.ctx),
            this.prevSeriesY = [],
            this.categoryAxisCorrection = 0,
            this.yaxisIndex = 0
        }
        return Te(C, [{
            key: "draw",
            value: function(e, t, i, a) {
                var s = this.w
                  , r = new U(this.ctx)
                  , n = s.globals.comboCharts ? t : s.config.chart.type
                  , o = r.group({
                    class: "apexcharts-".concat(n, "-series apexcharts-plot-series")
                })
                  , h = new ae(this.ctx,s);
                this.yRatio = this.xyRatios.yRatio,
                this.zRatio = this.xyRatios.zRatio,
                this.xRatio = this.xyRatios.xRatio,
                this.baseLineY = this.xyRatios.baseLineY,
                e = h.getLogSeries(e),
                this.yRatio = h.getLogYRatios(this.yRatio);
                for (var d = [], u = 0; u < e.length; u++) {
                    e = this.lineHelpers.sameValueSeriesFix(u, e);
                    var p = s.globals.comboCharts ? i[u] : u;
                    this._initSerieVariables(e, u, p);
                    var x = []
                      , b = []
                      , k = []
                      , S = s.globals.padHorizontal + this.categoryAxisCorrection;
                    this.ctx.series.addCollapsedClassToSeries(this.elSeries, p),
                    s.globals.isXNumeric && s.globals.seriesX.length > 0 && (S = (s.globals.seriesX[p][0] - s.globals.minX) / this.xRatio),
                    k.push(S);
                    var E = S
                      , M = this.zeroY
                      , l = this.zeroY;
                    M = this.lineHelpers.determineFirstPrevY({
                        i: u,
                        series: e,
                        prevY: M,
                        lineYPosition: 0
                    }).prevY,
                    x.push("smooth" === s.config.stroke.curve && null === e[u][0] ? null : M),
                    "rangeArea" === n && (l = this.lineHelpers.determineFirstPrevY({
                        i: u,
                        series: a,
                        prevY: l,
                        lineYPosition: 0
                    }).prevY,
                    b.push(l));
                    var f = {
                        type: n,
                        series: e,
                        realIndex: p,
                        i: u,
                        x: S,
                        y: 1,
                        pathsFrom: this._calculatePathsFrom({
                            type: n,
                            series: e,
                            i: u,
                            realIndex: p,
                            prevX: E,
                            prevY: M,
                            prevY2: l
                        }),
                        linePaths: [],
                        areaPaths: [],
                        seriesIndex: i,
                        lineYPosition: 0,
                        xArrj: k,
                        yArrj: x,
                        y2Arrj: b,
                        seriesRangeEnd: a
                    }
                      , w = this._iterateOverDataPoints(K(K({}, f), {}, {
                        iterations: "rangeArea" === n ? e[u].length - 1 : void 0,
                        isRangeStart: !0
                    }));
                    if ("rangeArea" === n) {
                        var _ = this._calculatePathsFrom({
                            series: a,
                            i: u,
                            realIndex: p,
                            prevX: E,
                            prevY: l
                        })
                          , R = this._iterateOverDataPoints(K(K({}, f), {}, {
                            series: a,
                            pathsFrom: _,
                            iterations: a[u].length - 1,
                            isRangeStart: !1
                        }));
                        w.linePaths[0] = R.linePath + w.linePath,
                        w.pathFromLine = R.pathFromLine + w.pathFromLine
                    }
                    this._handlePaths({
                        type: n,
                        realIndex: p,
                        i: u,
                        paths: w
                    }),
                    this.elSeries.add(this.elPointsMain),
                    this.elSeries.add(this.elDataLabelsWrap),
                    d.push(this.elSeries)
                }
                if (s.config.chart.stacked)
                    for (var H = d.length; H > 0; H--)
                        o.add(d[H - 1]);
                else
                    for (var B = 0; B < d.length; B++)
                        o.add(d[B]);
                return o
            }
        }, {
            key: "_initSerieVariables",
            value: function(e, t, i) {
                var a = this.w
                  , s = new U(this.ctx);
                this.xDivision = a.globals.gridWidth / (a.globals.dataPoints - ("on" === a.config.xaxis.tickPlacement ? 1 : 0)),
                this.strokeWidth = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[i] : a.config.stroke.width,
                this.yRatio.length > 1 && (this.yaxisIndex = i),
                this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed,
                this.zeroY = a.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0),
                this.areaBottomY = this.zeroY,
                (this.zeroY > a.globals.gridHeight || "end" === a.config.plotOptions.area.fillTo) && (this.areaBottomY = a.globals.gridHeight),
                this.categoryAxisCorrection = this.xDivision / 2,
                this.elSeries = s.group({
                    class: "apexcharts-series",
                    seriesName: D.escapeString(a.globals.seriesNames[i])
                }),
                this.elPointsMain = s.group({
                    class: "apexcharts-series-markers-wrap",
                    "data:realIndex": i
                }),
                this.elDataLabelsWrap = s.group({
                    class: "apexcharts-datalabels",
                    "data:realIndex": i
                }),
                this.elSeries.attr({
                    "data:longestSeries": e[t].length === a.globals.dataPoints,
                    rel: t + 1,
                    "data:realIndex": i
                }),
                this.appendPathFrom = !0
            }
        }, {
            key: "_calculatePathsFrom",
            value: function(e) {
                var t, i, a, s, r = e.type, n = e.series, o = e.i, h = e.realIndex, d = e.prevX, u = e.prevY, p = e.prevY2, x = this.w, b = new U(this.ctx);
                if (null === n[o][0]) {
                    for (var k = 0; k < n[o].length; k++)
                        if (null !== n[o][k]) {
                            t = b.move(d = this.xDivision * k, u = this.zeroY - n[o][k] / this.yRatio[this.yaxisIndex]),
                            i = b.move(d, this.areaBottomY);
                            break
                        }
                } else
                    t = b.move(d, u),
                    "rangeArea" === r && (t = b.move(d, p) + b.line(d, u)),
                    i = b.move(d, this.areaBottomY) + b.line(d, u);
                if (a = b.move(-1, this.zeroY) + b.line(-1, this.zeroY),
                s = b.move(-1, this.zeroY) + b.line(-1, this.zeroY),
                x.globals.previousPaths.length > 0) {
                    var S = this.lineHelpers.checkPreviousPaths({
                        pathFromLine: a,
                        pathFromArea: s,
                        realIndex: h
                    });
                    a = S.pathFromLine,
                    s = S.pathFromArea
                }
                return {
                    prevX: d,
                    prevY: u,
                    linePath: t,
                    areaPath: i,
                    pathFromLine: a,
                    pathFromArea: s
                }
            }
        }, {
            key: "_handlePaths",
            value: function(e) {
                var t = e.type
                  , i = e.realIndex
                  , a = e.i
                  , s = e.paths
                  , r = this.w
                  , n = new U(this.ctx)
                  , o = new wt(this.ctx);
                this.prevSeriesY.push(s.yArrj),
                r.globals.seriesXvalues[i] = s.xArrj,
                r.globals.seriesYvalues[i] = s.yArrj;
                var h = r.config.forecastDataPoints;
                if (h.count > 0 && "rangeArea" !== t) {
                    var d = r.globals.seriesXvalues[i][r.globals.seriesXvalues[i].length - h.count - 1]
                      , u = n.drawRect(d, 0, r.globals.gridWidth, r.globals.gridHeight, 0);
                    r.globals.dom.elForecastMask.appendChild(u.node);
                    var p = n.drawRect(0, 0, d, r.globals.gridHeight, 0);
                    r.globals.dom.elNonForecastMask.appendChild(p.node)
                }
                this.pointsChart || r.globals.delayedElements.push({
                    el: this.elPointsMain.node,
                    index: i
                });
                var x = {
                    i: a,
                    realIndex: i,
                    animationDelay: a,
                    initialSpeed: r.config.chart.animations.speed,
                    dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(t)
                };
                if ("area" === t)
                    for (var b = o.fillPath({
                        seriesNumber: i
                    }), k = 0; k < s.areaPaths.length; k++) {
                        var S = n.renderPaths(K(K({}, x), {}, {
                            pathFrom: s.pathFromArea,
                            pathTo: s.areaPaths[k],
                            stroke: "none",
                            strokeWidth: 0,
                            strokeLineCap: null,
                            fill: b
                        }));
                        this.elSeries.add(S)
                    }
                if (r.config.stroke.show && !this.pointsChart) {
                    var E = null;
                    if ("line" === t)
                        E = o.fillPath({
                            seriesNumber: i,
                            i: a
                        });
                    else if ("solid" === r.config.stroke.fill.type)
                        E = r.globals.stroke.colors[i];
                    else {
                        var M = r.config.fill;
                        r.config.fill = r.config.stroke.fill,
                        E = o.fillPath({
                            seriesNumber: i,
                            i: a
                        }),
                        r.config.fill = M
                    }
                    for (var l = 0; l < s.linePaths.length; l++) {
                        var f = E;
                        "rangeArea" === t && (f = o.fillPath({
                            seriesNumber: i
                        }));
                        var w = K(K({}, x), {}, {
                            pathFrom: s.pathFromLine,
                            pathTo: s.linePaths[l],
                            stroke: E,
                            strokeWidth: this.strokeWidth,
                            strokeLineCap: r.config.stroke.lineCap,
                            fill: "rangeArea" === t ? f : "none"
                        })
                          , _ = n.renderPaths(w);
                        if (this.elSeries.add(_),
                        _.attr("fill-rule", "evenodd"),
                        h.count > 0 && "rangeArea" !== t) {
                            var R = n.renderPaths(w);
                            R.node.setAttribute("stroke-dasharray", h.dashArray),
                            h.strokeWidth && R.node.setAttribute("stroke-width", h.strokeWidth),
                            this.elSeries.add(R),
                            R.attr("clip-path", "url(#forecastMask".concat(r.globals.cuid, ")")),
                            _.attr("clip-path", "url(#nonForecastMask".concat(r.globals.cuid, ")"))
                        }
                    }
                }
            }
        }, {
            key: "_iterateOverDataPoints",
            value: function(e) {
                var t = this
                  , i = e.type
                  , a = e.series
                  , s = e.iterations
                  , r = e.realIndex
                  , n = e.i
                  , o = e.x
                  , h = e.y
                  , d = e.pathsFrom
                  , u = e.linePaths
                  , p = e.areaPaths
                  , x = e.seriesIndex
                  , b = e.lineYPosition
                  , k = e.xArrj
                  , S = e.yArrj
                  , E = e.y2Arrj
                  , M = e.isRangeStart
                  , l = e.seriesRangeEnd
                  , f = this.w
                  , w = new U(this.ctx)
                  , _ = this.yRatio
                  , R = d.prevY
                  , H = d.linePath
                  , B = d.areaPath
                  , j = d.pathFromLine
                  , ce = d.pathFromArea
                  , me = D.isNumber(f.globals.minYArr[r]) ? f.globals.minYArr[r] : f.globals.minY;
                s || (s = f.globals.dataPoints > 1 ? f.globals.dataPoints - 1 : f.globals.dataPoints);
                for (var ue = function(mt, _t) {
                    return _t - mt / _[t.yaxisIndex] + 2 * (t.isReversed ? mt / _[t.yaxisIndex] : 0)
                }, Ee = h, Ie = 0; Ie < s; Ie++) {
                    var rt = null == a[n][Ie + 1];
                    if (f.globals.isXNumeric) {
                        var nt = f.globals.seriesX[r][Ie + 1];
                        void 0 === f.globals.seriesX[r][Ie + 1] && (nt = f.globals.seriesX[r][s - 1]),
                        o = (nt - f.globals.minX) / this.xRatio
                    } else
                        o += this.xDivision;
                    b = f.config.chart.stacked && n > 0 && f.globals.collapsedSeries.length < f.config.series.length - 1 ? this.prevSeriesY[function(mt) {
                        for (var _t = mt, ii = 0; ii < f.globals.series.length; ii++)
                            if (f.globals.collapsedSeriesIndices.indexOf(mt) > -1) {
                                _t--;
                                break
                            }
                        return _t >= 0 ? _t : 0
                    }(n - 1)][Ie + 1] : this.zeroY,
                    rt ? h = ue(me, b) : (h = ue(a[n][Ie + 1], b),
                    "rangeArea" === i && (Ee = ue(l[n][Ie + 1], b))),
                    k.push(o),
                    S.push(rt && "smooth" === f.config.stroke.curve ? null : h),
                    E.push(Ee);
                    var ht = this.lineHelpers.calculatePoints({
                        series: a,
                        x: o,
                        y: h,
                        realIndex: r,
                        i: n,
                        j: Ie,
                        prevY: R
                    })
                      , vt = this._createPaths({
                        type: i,
                        series: a,
                        i: n,
                        realIndex: r,
                        j: Ie,
                        x: o,
                        y: h,
                        y2: Ee,
                        xArrj: k,
                        yArrj: S,
                        y2Arrj: E,
                        linePath: H,
                        areaPath: B,
                        linePaths: u,
                        areaPaths: p,
                        seriesIndex: x,
                        isRangeStart: M
                    });
                    p = vt.areaPaths,
                    u = vt.linePaths,
                    B = vt.areaPath,
                    H = vt.linePath,
                    !this.appendPathFrom || "smooth" === f.config.stroke.curve && "rangeArea" === i || (j += w.line(o, this.zeroY),
                    ce += w.line(o, this.zeroY)),
                    this.handleNullDataPoints(a, ht, n, Ie, r),
                    this._handleMarkersAndLabels({
                        type: i,
                        pointsPos: ht,
                        i: n,
                        j: Ie,
                        realIndex: r,
                        isRangeStart: M
                    })
                }
                return {
                    yArrj: S,
                    xArrj: k,
                    pathFromArea: ce,
                    areaPaths: p,
                    pathFromLine: j,
                    linePaths: u,
                    linePath: H,
                    areaPath: B
                }
            }
        }, {
            key: "_handleMarkersAndLabels",
            value: function(e) {
                var t = e.type
                  , i = e.pointsPos
                  , a = e.isRangeStart
                  , s = e.i
                  , r = e.j
                  , n = e.realIndex
                  , o = this.w
                  , h = new It(this.ctx);
                if (this.pointsChart)
                    this.scatter.draw(this.elSeries, r, {
                        realIndex: n,
                        pointsPos: i,
                        zRatio: this.zRatio,
                        elParent: this.elPointsMain
                    });
                else {
                    o.globals.series[s].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                    var d = this.markers.plotChartMarkers(i, n, r + 1);
                    null !== d && this.elPointsMain.add(d)
                }
                var u = h.drawDataLabel({
                    type: t,
                    isRangeStart: a,
                    pos: i,
                    i: n,
                    j: r + 1
                });
                null !== u && this.elDataLabelsWrap.add(u)
            }
        }, {
            key: "_createPaths",
            value: function(e) {
                var t = e.type
                  , i = e.series
                  , a = e.i
                  , s = e.realIndex
                  , r = e.j
                  , n = e.x
                  , o = e.y
                  , h = e.xArrj
                  , d = e.yArrj
                  , u = e.y2
                  , p = e.y2Arrj
                  , x = e.linePath
                  , b = e.areaPath
                  , k = e.linePaths
                  , S = e.areaPaths
                  , E = e.seriesIndex
                  , M = e.isRangeStart
                  , l = this.w
                  , f = new U(this.ctx)
                  , w = l.config.stroke.curve
                  , _ = this.areaBottomY;
                if (Array.isArray(l.config.stroke.curve) && (w = Array.isArray(E) ? l.config.stroke.curve[E[a]] : l.config.stroke.curve[a]),
                "rangeArea" === t && (l.globals.hasNullValues || l.config.forecastDataPoints.count > 0) && "smooth" === w && (w = "straight"),
                "smooth" === w) {
                    if ("rangeArea" === t ? h.length === l.globals.dataPoints : r === i[a].length - 2) {
                        var R = h.map(function(Ee, Ie) {
                            return [h[Ie], d[Ie]]
                        }).filter(function(Ee) {
                            return null !== Ee[1]
                        })
                          , H = hi(R);
                        if (x += ti(H),
                        null === i[a][0] ? b = x : b += ti(H),
                        "rangeArea" === t && M) {
                            x += f.line(h[h.length - 1], p[p.length - 1]);
                            var B = h.slice().reverse()
                              , j = p.slice().reverse()
                              , ce = B.map(function(Ee, Ie) {
                                return [B[Ie], j[Ie]]
                            })
                              , me = hi(ce);
                            b = x += ti(me)
                        } else
                            b += f.line(R[R.length - 1][0], _) + f.line(R[0][0], _) + f.move(R[0][0], R[0][1]) + "z";
                        k.push(x),
                        S.push(b)
                    }
                } else
                    null === i[a][r + 1] && (x += f.move(n, o),
                    b = b + f.line(l.globals.isXNumeric ? (l.globals.seriesX[s][r] - l.globals.minX) / this.xRatio : n - this.xDivision, _) + f.move(n, o) + "z"),
                    null === i[a][r] && (x += f.move(n, o),
                    b += f.move(n, _)),
                    "stepline" === w ? (x = x + f.line(n, null, "H") + f.line(null, o, "V"),
                    b = b + f.line(n, null, "H") + f.line(null, o, "V")) : "straight" === w && (x += f.line(n, o),
                    b += f.line(n, o)),
                    r === i[a].length - 2 && (b = b + f.line(n, _) + f.move(n, o) + "z",
                    "rangeArea" === t && M ? x = x + f.line(n, u) + f.move(n, u) + "z" : (k.push(x),
                    S.push(b)));
                return {
                    linePaths: k,
                    areaPaths: S,
                    linePath: x,
                    areaPath: b
                }
            }
        }, {
            key: "handleNullDataPoints",
            value: function(e, t, i, a, s) {
                var r = this.w;
                if (null === e[i][a] && r.config.markers.showNullDataPoints || 1 === e[i].length) {
                    var n = this.markers.plotChartMarkers(t, s, a + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0);
                    null !== n && this.elPointsMain.add(n)
                }
            }
        }]),
        C
    }();
    window.TreemapSquared = {},
    window.TreemapSquared.generate = function() {
        function C(n, o, h, d) {
            this.xoffset = n,
            this.yoffset = o,
            this.height = d,
            this.width = h,
            this.shortestEdge = function() {
                return Math.min(this.height, this.width)
            }
            ,
            this.getCoordinates = function(u) {
                var p, x = [], b = this.xoffset, k = this.yoffset, S = s(u) / this.height, E = s(u) / this.width;
                if (this.width >= this.height)
                    for (p = 0; p < u.length; p++)
                        x.push([b, k, b + S, k + u[p] / S]),
                        k += u[p] / S;
                else
                    for (p = 0; p < u.length; p++)
                        x.push([b, k, b + u[p] / E, k + E]),
                        b += u[p] / E;
                return x
            }
            ,
            this.cutArea = function(u) {
                var p;
                if (this.width >= this.height) {
                    var x = u / this.height;
                    p = new C(this.xoffset + x,this.yoffset,this.width - x,this.height)
                } else {
                    var k = u / this.width;
                    p = new C(this.xoffset,this.yoffset + k,this.width,this.height - k)
                }
                return p
            }
        }
        function e(n, o, h, d, u) {
            return d = void 0 === d ? 0 : d,
            u = void 0 === u ? 0 : u,
            function(x) {
                var b, k, S = [];
                for (b = 0; b < x.length; b++)
                    for (k = 0; k < x[b].length; k++)
                        S.push(x[b][k]);
                return S
            }(t(function(x, b) {
                var k, S = [], E = b / s(x);
                for (k = 0; k < x.length; k++)
                    S[k] = x[k] * E;
                return S
            }(n, o * h), [], new C(d,u,o,h), []))
        }
        function t(n, o, h, d) {
            var u, p, x, b, k, S, E;
            if (0 !== n.length)
                return u = h.shortestEdge(),
                k = p = n[0],
                S = u,
                0 === (b = o).length || ((E = b.slice()).push(k),
                i(b, S) >= i(E, S)) ? (o.push(p),
                t(n.slice(1), o, h, d)) : (x = h.cutArea(s(o), d),
                d.push(h.getCoordinates(o)),
                t(n, [], x, d)),
                d;
            d.push(h.getCoordinates(o))
        }
        function i(n, o) {
            var h = Math.min.apply(Math, n)
              , d = Math.max.apply(Math, n)
              , u = s(n);
            return Math.max(Math.pow(o, 2) * d / Math.pow(u, 2), Math.pow(u, 2) / (Math.pow(o, 2) * h))
        }
        function a(n) {
            return n && n.constructor === Array
        }
        function s(n) {
            var o, h = 0;
            for (o = 0; o < n.length; o++)
                h += n[o];
            return h
        }
        function r(n) {
            var o, h = 0;
            if (a(n[0]))
                for (o = 0; o < n.length; o++)
                    h += r(n[o]);
            else
                h = s(n);
            return h
        }
        return function n(o, h, d, u, p) {
            u = void 0 === u ? 0 : u,
            p = void 0 === p ? 0 : p;
            var x, b, k = [], S = [];
            if (a(o[0])) {
                for (b = 0; b < o.length; b++)
                    k[b] = r(o[b]);
                for (x = e(k, h, d, u, p),
                b = 0; b < o.length; b++)
                    S.push(n(o[b], x[b][2] - x[b][0], x[b][3] - x[b][1], x[b][0], x[b][1]))
            } else
                S = e(o, h, d, u, p);
            return S
        }
    }();
    var bi, yi, Ji = function() {
        function C(e, t) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.strokeWidth = this.w.config.stroke.width,
            this.helpers = new Le(e),
            this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation,
            this.labels = []
        }
        return Te(C, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = new U(this.ctx)
                  , s = new wt(this.ctx)
                  , r = a.group({
                    class: "apexcharts-treemap"
                });
                if (i.globals.noData)
                    return r;
                var n = [];
                return e.forEach(function(o) {
                    var h = o.map(function(d) {
                        return Math.abs(d)
                    });
                    n.push(h)
                }),
                this.negRange = this.helpers.checkColorRange(),
                i.config.series.forEach(function(o, h) {
                    o.data.forEach(function(d) {
                        Array.isArray(t.labels[h]) || (t.labels[h] = []),
                        t.labels[h].push(d.x)
                    })
                }),
                window.TreemapSquared.generate(n, i.globals.gridWidth, i.globals.gridHeight).forEach(function(o, h) {
                    var d = a.group({
                        class: "apexcharts-series apexcharts-treemap-series",
                        seriesName: D.escapeString(i.globals.seriesNames[h]),
                        rel: h + 1,
                        "data:realIndex": h
                    });
                    if (i.config.chart.dropShadow.enabled) {
                        var u = i.config.chart.dropShadow;
                        new _e(t.ctx).dropShadow(r, u, h)
                    }
                    var p = a.group({
                        class: "apexcharts-data-labels"
                    });
                    o.forEach(function(x, b) {
                        var k = x[0]
                          , S = x[1]
                          , E = x[2]
                          , M = x[3]
                          , l = a.drawRect(k, S, E - k, M - S, 0, "#fff", 1, t.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? w : i.globals.stroke.colors[h]);
                        l.attr({
                            cx: k,
                            cy: S,
                            index: h,
                            i: h,
                            j: b,
                            width: E - k,
                            height: M - S
                        });
                        var f = t.helpers.getShadeColor(i.config.chart.type, h, b, t.negRange)
                          , w = f.color;
                        void 0 !== i.config.series[h].data[b] && i.config.series[h].data[b].fillColor && (w = i.config.series[h].data[b].fillColor);
                        var _ = s.fillPath({
                            color: w,
                            seriesNumber: h,
                            dataPointIndex: b
                        });
                        l.node.classList.add("apexcharts-treemap-rect"),
                        l.attr({
                            fill: _
                        }),
                        t.helpers.addListeners(l);
                        var R = {
                            x: k + (E - k) / 2,
                            y: S + (M - S) / 2,
                            width: 0,
                            height: 0
                        }
                          , H = {
                            x: k,
                            y: S,
                            width: E - k,
                            height: M - S
                        };
                        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
                            var B = 1;
                            i.globals.resized || (B = i.config.chart.animations.speed),
                            t.animateTreemap(l, R, H, B)
                        }
                        i.globals.dataChanged && t.dynamicAnim.enabled && i.globals.shouldAnimate && (i.globals.previousPaths[h] && i.globals.previousPaths[h][b] && i.globals.previousPaths[h][b].rect && (R = i.globals.previousPaths[h][b].rect),
                        t.animateTreemap(l, R, H, t.dynamicAnim.speed));
                        var ce = t.getFontSize(x)
                          , me = i.config.dataLabels.formatter(t.labels[h][b], {
                            value: i.globals.series[h][b],
                            seriesIndex: h,
                            dataPointIndex: b,
                            w: i
                        });
                        "truncate" === i.config.plotOptions.treemap.dataLabels.format && (ce = parseInt(i.config.dataLabels.style.fontSize, 10),
                        me = t.truncateLabels(me, ce, k, S, E, M));
                        var ue = t.helpers.calculateDataLabels({
                            text: me,
                            x: (k + E) / 2,
                            y: (S + M) / 2 + t.strokeWidth / 2 + ce / 3,
                            i: h,
                            j: b,
                            colorProps: f,
                            fontSize: ce,
                            series: e
                        });
                        i.config.dataLabels.enabled && ue && t.rotateToFitLabel(ue, ce, me, k, S, E, M),
                        d.add(l),
                        null !== ue && d.add(ue)
                    }),
                    d.add(p),
                    r.add(d)
                }),
                r
            }
        }, {
            key: "getFontSize",
            value: function(e) {
                var r, t = this.w, n = function o(h) {
                    var d, u = 0;
                    if (Array.isArray(h[0]))
                        for (d = 0; d < h.length; d++)
                            u += o(h[d]);
                    else
                        for (d = 0; d < h.length; d++)
                            u += h[d].length;
                    return u
                }(this.labels) / function o(h) {
                    var d, u = 0;
                    if (Array.isArray(h[0]))
                        for (d = 0; d < h.length; d++)
                            u += o(h[d]);
                    else
                        for (d = 0; d < h.length; d++)
                            u += 1;
                    return u
                }(this.labels);
                return r = Math.pow((e[2] - e[0]) * (e[3] - e[1]), .5),
                Math.min(r / n, parseInt(t.config.dataLabels.style.fontSize, 10))
            }
        }, {
            key: "rotateToFitLabel",
            value: function(e, t, i, a, s, r, n) {
                var o = new U(this.ctx)
                  , h = o.getTextRects(i, t);
                if (h.width + this.w.config.stroke.width + 5 > r - a && h.width <= n - s) {
                    var d = o.rotateAroundCenter(e.node);
                    e.node.setAttribute("transform", "rotate(-90 ".concat(d.x, " ").concat(d.y, ") translate(").concat(h.height / 3, ")"))
                }
            }
        }, {
            key: "truncateLabels",
            value: function(e, t, i, a, s, r) {
                var n = new U(this.ctx)
                  , o = n.getTextRects(e, t).width + this.w.config.stroke.width + 5 > s - i && r - a > s - i ? r - a : s - i
                  , h = n.getTextBasedOnMaxWidth({
                    text: e,
                    maxWidth: o,
                    fontSize: t
                });
                return e.length !== h.length && o / t < 5 ? "" : h
            }
        }, {
            key: "animateTreemap",
            value: function(e, t, i, a) {
                var s = new Se(this.ctx);
                s.animateRect(e, {
                    x: t.x,
                    y: t.y,
                    width: t.width,
                    height: t.height
                }, {
                    x: i.x,
                    y: i.y,
                    width: i.width,
                    height: i.height
                }, a, function() {
                    s.animationCompleted(e)
                })
            }
        }]),
        C
    }(), ba = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w,
            this.timeScaleArray = [],
            this.utc = this.w.config.xaxis.labels.datetimeUTC
        }
        return Te(C, [{
            key: "calculateTimeScaleTicks",
            value: function(e, t) {
                var i = this
                  , a = this.w;
                if (a.globals.allSeriesCollapsed)
                    return a.globals.labels = [],
                    a.globals.timescaleLabels = [],
                    [];
                var s = new We(this.ctx)
                  , r = (t - e) / 864e5;
                this.determineInterval(r),
                a.globals.disableZoomIn = !1,
                a.globals.disableZoomOut = !1,
                r < .00011574074074074075 ? a.globals.disableZoomIn = !0 : r > 5e4 && (a.globals.disableZoomOut = !0);
                var n = s.getTimeUnitsfromTimestamp(e, t, this.utc)
                  , o = a.globals.gridWidth / r
                  , h = o / 24
                  , d = h / 60
                  , u = d / 60
                  , p = Math.floor(24 * r)
                  , x = Math.floor(1440 * r)
                  , b = Math.floor(86400 * r)
                  , k = Math.floor(r)
                  , S = Math.floor(r / 30)
                  , E = Math.floor(r / 365)
                  , M = {
                    minMillisecond: n.minMillisecond,
                    minSecond: n.minSecond,
                    minMinute: n.minMinute,
                    minHour: n.minHour,
                    minDate: n.minDate,
                    minMonth: n.minMonth,
                    minYear: n.minYear
                }
                  , l = {
                    firstVal: M,
                    currentMillisecond: M.minMillisecond,
                    currentSecond: M.minSecond,
                    currentMinute: M.minMinute,
                    currentHour: M.minHour,
                    currentMonthDate: M.minDate,
                    currentDate: M.minDate,
                    currentMonth: M.minMonth,
                    currentYear: M.minYear,
                    daysWidthOnXAxis: o,
                    hoursWidthOnXAxis: h,
                    minutesWidthOnXAxis: d,
                    secondsWidthOnXAxis: u,
                    numberOfSeconds: b,
                    numberOfMinutes: x,
                    numberOfHours: p,
                    numberOfDays: k,
                    numberOfMonths: S,
                    numberOfYears: E
                };
                switch (this.tickInterval) {
                case "years":
                    this.generateYearScale(l);
                    break;
                case "months":
                case "half_year":
                    this.generateMonthScale(l);
                    break;
                case "months_days":
                case "months_fortnight":
                case "days":
                case "week_days":
                    this.generateDayScale(l);
                    break;
                case "hours":
                    this.generateHourScale(l);
                    break;
                case "minutes_fives":
                case "minutes":
                    this.generateMinuteScale(l);
                    break;
                case "seconds_tens":
                case "seconds_fives":
                case "seconds":
                    this.generateSecondScale(l)
                }
                var f = this.timeScaleArray.map(function(w) {
                    var _ = {
                        position: w.position,
                        unit: w.unit,
                        year: w.year,
                        day: w.day ? w.day : 1,
                        hour: w.hour ? w.hour : 0,
                        month: w.month + 1
                    };
                    return "month" === w.unit ? K(K({}, _), {}, {
                        day: 1,
                        value: w.value + 1
                    }) : "day" === w.unit || "hour" === w.unit ? K(K({}, _), {}, {
                        value: w.value
                    }) : "minute" === w.unit ? K(K({}, _), {}, {
                        value: w.value,
                        minute: w.value
                    }) : "second" === w.unit ? K(K({}, _), {}, {
                        value: w.value,
                        minute: w.minute,
                        second: w.second
                    }) : w
                });
                return f.filter(function(w) {
                    var _ = 1
                      , R = Math.ceil(a.globals.gridWidth / 120)
                      , H = w.value;
                    void 0 !== a.config.xaxis.tickAmount && (R = a.config.xaxis.tickAmount),
                    f.length > R && (_ = Math.floor(f.length / R));
                    var B = !1
                      , j = !1;
                    switch (i.tickInterval) {
                    case "years":
                        "year" === w.unit && (B = !0);
                        break;
                    case "half_year":
                        _ = 7,
                        "year" === w.unit && (B = !0);
                        break;
                    case "months":
                        _ = 1,
                        "year" === w.unit && (B = !0);
                        break;
                    case "months_fortnight":
                        _ = 15,
                        "year" !== w.unit && "month" !== w.unit || (B = !0),
                        30 === H && (j = !0);
                        break;
                    case "months_days":
                        _ = 10,
                        "month" === w.unit && (B = !0),
                        30 === H && (j = !0);
                        break;
                    case "week_days":
                        _ = 8,
                        "month" === w.unit && (B = !0);
                        break;
                    case "days":
                        _ = 1,
                        "month" === w.unit && (B = !0);
                        break;
                    case "hours":
                        "day" === w.unit && (B = !0);
                        break;
                    case "minutes_fives":
                    case "seconds_fives":
                        H % 5 != 0 && (j = !0);
                        break;
                    case "seconds_tens":
                        H % 10 != 0 && (j = !0)
                    }
                    if ("hours" === i.tickInterval || "minutes_fives" === i.tickInterval || "seconds_tens" === i.tickInterval || "seconds_fives" === i.tickInterval) {
                        if (!j)
                            return !0
                    } else if ((H % _ == 0 || B) && !j)
                        return !0
                })
            }
        }, {
            key: "recalcDimensionsBasedOnFormat",
            value: function(e, t) {
                var i = this.w
                  , a = this.formatDates(e)
                  , s = this.removeOverlappingTS(a);
                i.globals.timescaleLabels = s.slice(),
                new Gi(this.ctx).plotCoords()
            }
        }, {
            key: "determineInterval",
            value: function(e) {
                var t = 24 * e
                  , i = 60 * t;
                switch (!0) {
                case e / 365 > 5:
                    this.tickInterval = "years";
                    break;
                case e > 800:
                    this.tickInterval = "half_year";
                    break;
                case e > 180:
                    this.tickInterval = "months";
                    break;
                case e > 90:
                    this.tickInterval = "months_fortnight";
                    break;
                case e > 60:
                    this.tickInterval = "months_days";
                    break;
                case e > 30:
                    this.tickInterval = "week_days";
                    break;
                case e > 2:
                    this.tickInterval = "days";
                    break;
                case t > 2.4:
                    this.tickInterval = "hours";
                    break;
                case i > 15:
                    this.tickInterval = "minutes_fives";
                    break;
                case i > 5:
                    this.tickInterval = "minutes";
                    break;
                case i > 1:
                    this.tickInterval = "seconds_tens";
                    break;
                case 60 * i > 20:
                    this.tickInterval = "seconds_fives";
                    break;
                default:
                    this.tickInterval = "seconds"
                }
            }
        }, {
            key: "generateYearScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentMonth
                  , a = e.currentYear
                  , s = e.daysWidthOnXAxis
                  , r = e.numberOfYears
                  , n = t.minYear
                  , o = 0
                  , h = new We(this.ctx)
                  , d = "year";
                if (t.minDate > 1 || t.minMonth > 0) {
                    var u = h.determineRemainingDaysOfYear(t.minYear, t.minMonth, t.minDate);
                    o = (h.determineDaysOfYear(t.minYear) - u + 1) * s,
                    this.timeScaleArray.push({
                        position: o,
                        value: n = t.minYear + 1,
                        unit: d,
                        year: n,
                        month: D.monthMod(i + 1)
                    })
                } else
                    1 === t.minDate && 0 === t.minMonth && this.timeScaleArray.push({
                        position: o,
                        value: n,
                        unit: d,
                        year: a,
                        month: D.monthMod(i + 1)
                    });
                for (var p = n, x = o, b = 0; b < r; b++)
                    p++,
                    x = h.determineDaysOfYear(p - 1) * s + x,
                    this.timeScaleArray.push({
                        position: x,
                        value: p,
                        unit: d,
                        year: p,
                        month: 1
                    })
            }
        }, {
            key: "generateMonthScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentMonthDate
                  , a = e.currentMonth
                  , s = e.currentYear
                  , r = e.daysWidthOnXAxis
                  , n = e.numberOfMonths
                  , o = a
                  , h = 0
                  , d = new We(this.ctx)
                  , u = "month"
                  , p = 0;
                if (t.minDate > 1) {
                    h = (d.determineDaysOfMonths(a + 1, t.minYear) - i + 1) * r,
                    o = D.monthMod(a + 1);
                    var x = s + p
                      , b = D.monthMod(o)
                      , k = o;
                    0 === o && (u = "year",
                    k = x,
                    b = 1,
                    x += p += 1),
                    this.timeScaleArray.push({
                        position: h,
                        value: k,
                        unit: u,
                        year: x,
                        month: b
                    })
                } else
                    this.timeScaleArray.push({
                        position: h,
                        value: o,
                        unit: u,
                        year: s,
                        month: D.monthMod(a)
                    });
                for (var S = o + 1, E = h, M = 0, l = 1; M < n; M++,
                l++) {
                    0 === (S = D.monthMod(S)) ? (u = "year",
                    p += 1) : u = "month";
                    var f = this._getYear(s, S, p);
                    E = d.determineDaysOfMonths(S, f) * r + E,
                    this.timeScaleArray.push({
                        position: E,
                        value: 0 === S ? f : S,
                        unit: u,
                        year: f,
                        month: 0 === S ? 1 : S
                    }),
                    S++
                }
            }
        }, {
            key: "generateDayScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentMonth
                  , a = e.currentYear
                  , s = e.hoursWidthOnXAxis
                  , r = e.numberOfDays
                  , n = new We(this.ctx)
                  , o = "day"
                  , h = t.minDate + 1
                  , d = h
                  , u = function(l, f, w) {
                    return l > n.determineDaysOfMonths(f + 1, w) && (d = 1,
                    o = "month",
                    x = f += 1),
                    f
                }
                  , p = (24 - t.minHour) * s
                  , x = h
                  , b = u(d, i, a);
                0 === t.minHour && 1 === t.minDate ? (p = 0,
                x = D.monthMod(t.minMonth),
                o = "month",
                d = t.minDate) : 1 !== t.minDate && 0 === t.minHour && 0 === t.minMinute && (p = 0,
                x = h = t.minDate,
                b = u(d = h, i, a)),
                this.timeScaleArray.push({
                    position: p,
                    value: x,
                    unit: o,
                    year: this._getYear(a, b, 0),
                    month: D.monthMod(b),
                    day: d
                });
                for (var k = p, S = 0; S < r; S++) {
                    o = "day",
                    b = u(d += 1, b, this._getYear(a, b, 0));
                    var E = this._getYear(a, b, 0);
                    k = 24 * s + k;
                    var M = 1 === d ? D.monthMod(b) : d;
                    this.timeScaleArray.push({
                        position: k,
                        value: M,
                        unit: o,
                        year: E,
                        month: D.monthMod(b),
                        day: M
                    })
                }
            }
        }, {
            key: "generateHourScale",
            value: function(e) {
                var t = e.firstVal
                  , i = e.currentDate
                  , a = e.currentMonth
                  , s = e.currentYear
                  , r = e.minutesWidthOnXAxis
                  , n = e.numberOfHours
                  , o = new We(this.ctx)
                  , h = "hour"
                  , d = function(_, R) {
                    return _ > o.determineDaysOfMonths(R + 1, s) && (S = 1,
                    R += 1),
                    {
                        month: R,
                        date: S
                    }
                }
                  , u = function(_, R) {
                    return _ > o.determineDaysOfMonths(R + 1, s) ? R += 1 : R
                }
                  , p = 60 - (t.minMinute + t.minSecond / 60)
                  , x = p * r
                  , b = t.minHour + 1
                  , k = b;
                60 === p && (x = 0,
                k = (b = t.minHour) + 1);
                var S = i;
                k >= 24 && (k = 0,
                S += 1,
                h = "day");
                var E = d(S, a).month;
                E = u(S, E),
                this.timeScaleArray.push({
                    position: x,
                    value: b,
                    unit: h,
                    day: S,
                    hour: k,
                    year: s,
                    month: D.monthMod(E)
                }),
                k++;
                for (var M = x, l = 0; l < n; l++) {
                    h = "hour",
                    k >= 24 && (k = 0,
                    h = "day",
                    E = d(S += 1, E).month,
                    E = u(S, E));
                    var f = this._getYear(s, E, 0);
                    this.timeScaleArray.push({
                        position: M = 60 * r + M,
                        value: 0 === k ? S : k,
                        unit: h,
                        hour: k,
                        day: S,
                        year: f,
                        month: D.monthMod(E)
                    }),
                    k++
                }
            }
        }, {
            key: "generateMinuteScale",
            value: function(e) {
                for (var h = e.minutesWidthOnXAxis, u = e.numberOfMinutes, p = e.currentMinute + 1, x = e.currentDate, b = e.currentMonth, k = e.currentYear, S = e.currentHour, E = (60 - e.currentSecond - e.currentMillisecond / 1e3) * e.secondsWidthOnXAxis, M = 0; M < u; M++)
                    p >= 60 && (p = 0,
                    24 === (S += 1) && (S = 0)),
                    this.timeScaleArray.push({
                        position: E,
                        value: p,
                        unit: "minute",
                        hour: S,
                        minute: p,
                        day: x,
                        year: this._getYear(k, b, 0),
                        month: D.monthMod(b)
                    }),
                    E += h,
                    p++
            }
        }, {
            key: "generateSecondScale",
            value: function(e) {
                for (var h = e.secondsWidthOnXAxis, d = e.numberOfSeconds, u = e.currentSecond + 1, p = e.currentMinute, x = e.currentDate, b = e.currentMonth, k = e.currentYear, S = e.currentHour, E = (1e3 - e.currentMillisecond) / 1e3 * h, M = 0; M < d; M++)
                    u >= 60 && (u = 0,
                    ++p >= 60 && (p = 0,
                    24 == ++S && (S = 0))),
                    this.timeScaleArray.push({
                        position: E,
                        value: u,
                        unit: "second",
                        hour: S,
                        minute: p,
                        second: u,
                        day: x,
                        year: this._getYear(k, b, 0),
                        month: D.monthMod(b)
                    }),
                    E += h,
                    u++
            }
        }, {
            key: "createRawDateString",
            value: function(e, t) {
                var i = e.year;
                return 0 === e.month && (e.month = 1),
                i += "-" + ("0" + e.month.toString()).slice(-2),
                i += "day" === e.unit ? "day" === e.unit ? "-" + ("0" + t).slice(-2) : "-01" : "-" + ("0" + (e.day ? e.day : "1")).slice(-2),
                i += "hour" === e.unit ? "hour" === e.unit ? "T" + ("0" + t).slice(-2) : "T00" : "T" + ("0" + (e.hour ? e.hour : "0")).slice(-2),
                i += "minute" === e.unit ? ":" + ("0" + t).slice(-2) : ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"),
                i += "second" === e.unit ? ":" + ("0" + t).slice(-2) : ":00",
                this.utc && (i += ".000Z"),
                i
            }
        }, {
            key: "formatDates",
            value: function(e) {
                var t = this
                  , i = this.w;
                return e.map(function(a) {
                    var s = a.value.toString()
                      , r = new We(t.ctx)
                      , n = t.createRawDateString(a, s)
                      , o = r.getDate(r.parseDate(n));
                    if (t.utc || (o = r.getDate(r.parseDateWithTimezone(n))),
                    void 0 === i.config.xaxis.labels.format) {
                        var h = "dd MMM"
                          , d = i.config.xaxis.labels.datetimeFormatter;
                        "year" === a.unit && (h = d.year),
                        "month" === a.unit && (h = d.month),
                        "day" === a.unit && (h = d.day),
                        "hour" === a.unit && (h = d.hour),
                        "minute" === a.unit && (h = d.minute),
                        "second" === a.unit && (h = d.second),
                        s = r.formatDate(o, h)
                    } else
                        s = r.formatDate(o, i.config.xaxis.labels.format);
                    return {
                        dateString: n,
                        position: a.position,
                        value: s,
                        unit: a.unit,
                        year: a.year,
                        month: a.month
                    }
                })
            }
        }, {
            key: "removeOverlappingTS",
            value: function(e) {
                var t, i = this, a = new U(this.ctx), s = !1;
                e.length > 0 && e[0].value && e.every(function(o) {
                    return o.value.length === e[0].value.length
                }) && (s = !0,
                t = a.getTextRects(e[0].value).width);
                var r = 0;
                return e.map(function(o, h) {
                    if (h > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
                        var d = s ? t : a.getTextRects(e[r].value).width;
                        return o.position > e[r].position + d + 10 ? (r = h,
                        o) : null
                    }
                    return o
                }).filter(function(o) {
                    return null !== o
                })
            }
        }, {
            key: "_getYear",
            value: function(e, t, i) {
                return e + Math.floor(t / 12) + i
            }
        }]),
        C
    }(), Ri = function() {
        function C(e, t) {
            Q(this, C),
            this.ctx = t,
            this.w = t.w,
            this.el = e
        }
        return Te(C, [{
            key: "setupElements",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config
                  , i = t.chart.type;
                e.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1,
                e.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1,
                e.isBarHorizontal = ("bar" === t.chart.type || "rangeBar" === t.chart.type || "boxPlot" === t.chart.type) && t.plotOptions.bar.horizontal,
                e.chartClass = ".apexcharts" + e.chartID,
                e.dom.baseEl = this.el,
                e.dom.elWrap = document.createElement("div"),
                U.setAttrs(e.dom.elWrap, {
                    id: e.chartClass.substring(1),
                    class: "apexcharts-canvas " + e.chartClass.substring(1)
                }),
                this.el.appendChild(e.dom.elWrap),
                e.dom.Paper = new window.SVG.Doc(e.dom.elWrap),
                e.dom.Paper.attr({
                    class: "apexcharts-svg",
                    "xmlns:data": "ApexChartsNS",
                    transform: "translate(".concat(t.chart.offsetX, ", ").concat(t.chart.offsetY, ")")
                }),
                e.dom.Paper.node.style.background = "dark" === t.theme.mode && "transparent" === t.chart.background ? "rgba(0, 0, 0, 0.8)" : t.chart.background,
                this.setSVGDimensions(),
                e.dom.elLegendForeign = document.createElementNS(e.SVGNS, "foreignObject"),
                U.setAttrs(e.dom.elLegendForeign, {
                    x: 0,
                    y: 0,
                    width: e.svgWidth,
                    height: e.svgHeight
                }),
                e.dom.elLegendWrap = document.createElement("div"),
                e.dom.elLegendWrap.classList.add("apexcharts-legend"),
                e.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"),
                e.dom.elLegendForeign.appendChild(e.dom.elLegendWrap),
                e.dom.Paper.node.appendChild(e.dom.elLegendForeign),
                e.dom.elGraphical = e.dom.Paper.group().attr({
                    class: "apexcharts-inner apexcharts-graphical"
                }),
                e.dom.elDefs = e.dom.Paper.defs(),
                e.dom.Paper.add(e.dom.elGraphical),
                e.dom.elGraphical.add(e.dom.elDefs)
            }
        }, {
            key: "plotChartType",
            value: function(e, t) {
                var i = this.w
                  , a = i.config
                  , s = i.globals
                  , r = {
                    series: [],
                    i: []
                }
                  , n = {
                    series: [],
                    i: []
                }
                  , o = {
                    series: [],
                    i: []
                }
                  , h = {
                    series: [],
                    i: []
                }
                  , d = {
                    series: [],
                    i: []
                }
                  , u = {
                    series: [],
                    i: []
                }
                  , p = {
                    series: [],
                    i: []
                }
                  , x = {
                    series: [],
                    i: []
                }
                  , b = {
                    series: [],
                    seriesRangeEnd: [],
                    i: []
                };
                s.series.map(function(R, H) {
                    var B = 0;
                    void 0 !== e[H].type ? ("column" === e[H].type || "bar" === e[H].type ? (s.series.length > 1 && a.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"),
                    d.series.push(R),
                    d.i.push(H),
                    B++,
                    i.globals.columnSeries = d.series) : "area" === e[H].type ? (n.series.push(R),
                    n.i.push(H),
                    B++) : "line" === e[H].type ? (r.series.push(R),
                    r.i.push(H),
                    B++) : "scatter" === e[H].type ? (o.series.push(R),
                    o.i.push(H)) : "bubble" === e[H].type ? (h.series.push(R),
                    h.i.push(H),
                    B++) : "candlestick" === e[H].type ? (u.series.push(R),
                    u.i.push(H),
                    B++) : "boxPlot" === e[H].type ? (p.series.push(R),
                    p.i.push(H),
                    B++) : "rangeBar" === e[H].type ? (x.series.push(R),
                    x.i.push(H),
                    B++) : "rangeArea" === e[H].type ? (b.series.push(s.seriesRangeStart[H]),
                    b.seriesRangeEnd.push(s.seriesRangeEnd[H]),
                    b.i.push(H),
                    B++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"),
                    B > 1 && (s.comboCharts = !0)) : (r.series.push(R),
                    r.i.push(H))
                });
                var k = new vi(this.ctx,t)
                  , S = new fe(this.ctx,t);
                this.ctx.pie = new Qe(this.ctx);
                var E = new Ue(this.ctx);
                this.ctx.rangeBar = new st(this.ctx,t);
                var M = new Ye(this.ctx)
                  , l = [];
                if (s.comboCharts) {
                    if (n.series.length > 0 && l.push(k.draw(n.series, "area", n.i)),
                    d.series.length > 0)
                        if (i.config.chart.stacked) {
                            var f = new ve(this.ctx,t);
                            l.push(f.draw(d.series, d.i))
                        } else
                            this.ctx.bar = new xe(this.ctx,t),
                            l.push(this.ctx.bar.draw(d.series, d.i));
                    if (b.series.length > 0 && l.push(k.draw(b.series, "rangeArea", b.i, b.seriesRangeEnd)),
                    r.series.length > 0 && l.push(k.draw(r.series, "line", r.i)),
                    u.series.length > 0 && l.push(S.draw(u.series, "candlestick", u.i)),
                    p.series.length > 0 && l.push(S.draw(p.series, "boxPlot", p.i)),
                    x.series.length > 0 && l.push(this.ctx.rangeBar.draw(x.series, x.i)),
                    o.series.length > 0) {
                        var w = new vi(this.ctx,t,!0);
                        l.push(w.draw(o.series, "scatter", o.i))
                    }
                    if (h.series.length > 0) {
                        var _ = new vi(this.ctx,t,!0);
                        l.push(_.draw(h.series, "bubble", h.i))
                    }
                } else
                    switch (a.chart.type) {
                    case "line":
                        l = k.draw(s.series, "line");
                        break;
                    case "area":
                        l = k.draw(s.series, "area");
                        break;
                    case "bar":
                        a.chart.stacked ? l = new ve(this.ctx,t).draw(s.series) : (this.ctx.bar = new xe(this.ctx,t),
                        l = this.ctx.bar.draw(s.series));
                        break;
                    case "candlestick":
                        l = new fe(this.ctx,t).draw(s.series, "candlestick");
                        break;
                    case "boxPlot":
                        l = new fe(this.ctx,t).draw(s.series, a.chart.type);
                        break;
                    case "rangeBar":
                        l = this.ctx.rangeBar.draw(s.series);
                        break;
                    case "rangeArea":
                        l = k.draw(s.seriesRangeStart, "rangeArea", void 0, s.seriesRangeEnd);
                        break;
                    case "heatmap":
                        l = new Pe(this.ctx,t).draw(s.series);
                        break;
                    case "treemap":
                        l = new Ji(this.ctx,t).draw(s.series);
                        break;
                    case "pie":
                    case "donut":
                    case "polarArea":
                        l = this.ctx.pie.draw(s.series);
                        break;
                    case "radialBar":
                        l = E.draw(s.series);
                        break;
                    case "radar":
                        l = M.draw(s.series);
                        break;
                    default:
                        l = k.draw(s.series)
                    }
                return l
            }
        }, {
            key: "setSVGDimensions",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                e.svgWidth = t.chart.width,
                e.svgHeight = t.chart.height;
                var i = D.getDimensions(this.el)
                  , a = t.chart.width.toString().split(/[0-9]+/g).pop();
                "%" === a ? D.isNumber(i[0]) && (0 === i[0].width && (i = D.getDimensions(this.el.parentNode)),
                e.svgWidth = i[0] * parseInt(t.chart.width, 10) / 100) : "px" !== a && "" !== a || (e.svgWidth = parseInt(t.chart.width, 10));
                var s = t.chart.height.toString().split(/[0-9]+/g).pop();
                if ("auto" !== e.svgHeight && "" !== e.svgHeight)
                    if ("%" === s) {
                        var r = D.getDimensions(this.el.parentNode);
                        e.svgHeight = r[1] * parseInt(t.chart.height, 10) / 100
                    } else
                        e.svgHeight = parseInt(t.chart.height, 10);
                else
                    e.svgHeight = e.axisCharts ? e.svgWidth / 1.61 : e.svgWidth / 1.2;
                e.svgWidth < 0 && (e.svgWidth = 0),
                e.svgHeight < 0 && (e.svgHeight = 0),
                U.setAttrs(e.dom.Paper.node, {
                    width: e.svgWidth,
                    height: e.svgHeight
                }),
                "%" !== s && (e.dom.Paper.node.parentNode.parentNode.style.minHeight = e.svgHeight + (t.chart.sparkline.enabled ? 0 : e.axisCharts ? t.chart.parentHeightOffset : 0) + "px"),
                e.dom.elWrap.style.width = e.svgWidth + "px",
                e.dom.elWrap.style.height = e.svgHeight + "px"
            }
        }, {
            key: "shiftGraphPosition",
            value: function() {
                var e = this.w.globals;
                U.setAttrs(e.dom.elGraphical.node, {
                    transform: "translate(" + e.translateX + ", " + e.translateY + ")"
                })
            }
        }, {
            key: "resizeNonAxisCharts",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , i = 0
                  , a = e.config.chart.sparkline.enabled ? 1 : 15;
                a += e.config.grid.padding.bottom,
                "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || !e.config.legend.show || e.config.legend.floating || (i = new ci(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                var s = e.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie")
                  , r = 2.05 * e.globals.radialSize;
                if (s && !e.config.chart.sparkline.enabled && 0 !== e.config.plotOptions.radialBar.startAngle) {
                    var n = D.getBoundingClientRect(s);
                    r = n.bottom,
                    r = Math.max(2.05 * e.globals.radialSize, n.bottom - n.top)
                }
                var h = r + t.translateY + i + a;
                t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", h),
                e.config.chart.height && String(e.config.chart.height).indexOf("%") > 0 || (t.dom.elWrap.style.height = h + "px",
                U.setAttrs(t.dom.Paper.node, {
                    height: h
                }),
                t.dom.Paper.node.parentNode.parentNode.style.minHeight = h + "px")
            }
        }, {
            key: "coreCalculations",
            value: function() {
                new Di(this.ctx).init()
            }
        }, {
            key: "resetGlobals",
            value: function() {
                var e = this
                  , t = function() {
                    return e.w.config.series.map(function(s) {
                        return []
                    })
                }
                  , i = new yt
                  , a = this.w.globals;
                i.initGlobalVars(a),
                a.seriesXvalues = t(),
                a.seriesYvalues = t()
            }
        }, {
            key: "isMultipleY",
            value: function() {
                if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
                    return this.w.globals.isMultipleYAxis = !0,
                    !0
            }
        }, {
            key: "xySettings",
            value: function() {
                var e = null
                  , t = this.w;
                if (t.globals.axisCharts) {
                    if ("back" === t.config.xaxis.crosshairs.position && new fi(this.ctx).drawXCrosshairs(),
                    "back" === t.config.yaxis[0].crosshairs.position && new fi(this.ctx).drawYCrosshairs(),
                    "datetime" === t.config.xaxis.type && void 0 === t.config.xaxis.labels.formatter) {
                        this.ctx.timeScale = new ba(this.ctx);
                        var i = [];
                        isFinite(t.globals.minX) && isFinite(t.globals.maxX) && !t.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minX, t.globals.maxX) : t.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minY, t.globals.maxY)),
                        this.ctx.timeScale.recalcDimensionsBasedOnFormat(i)
                    }
                    e = new ae(this.ctx).getCalculatedRatios()
                }
                return e
            }
        }, {
            key: "updateSourceChart",
            value: function(e) {
                this.ctx.w.globals.selection = void 0,
                this.ctx.updateHelpers._updateOptions({
                    chart: {
                        selection: {
                            xaxis: {
                                min: e.w.globals.minX,
                                max: e.w.globals.maxX
                            }
                        }
                    }
                }, !1, !1)
            }
        }, {
            key: "setupBrushHandler",
            value: function() {
                var e = this
                  , t = this.w;
                if (t.config.chart.brush.enabled && "function" != typeof t.config.chart.events.selection) {
                    var i = Array.isArray(t.config.chart.brush.targets) || [t.config.chart.brush.target];
                    i.forEach(function(a) {
                        var s = ApexCharts.getChartByID(a);
                        s.w.globals.brushSource = e.ctx,
                        "function" != typeof s.w.config.chart.events.zoomed && (s.w.config.chart.events.zoomed = function() {
                            e.updateSourceChart(s)
                        }
                        ),
                        "function" != typeof s.w.config.chart.events.scrolled && (s.w.config.chart.events.scrolled = function() {
                            e.updateSourceChart(s)
                        }
                        )
                    }),
                    t.config.chart.events.selection = function(a, s) {
                        i.forEach(function(r) {
                            var n = ApexCharts.getChartByID(r)
                              , o = D.clone(t.config.yaxis);
                            if (t.config.chart.brush.autoScaleYaxis && 1 === n.w.globals.series.length) {
                                var h = new Jt(n);
                                o = h.autoScaleY(n, o, s)
                            }
                            var d = n.w.config.yaxis.reduce(function(u, p, x) {
                                return [].concat(J(u), [K(K({}, n.w.config.yaxis[x]), {}, {
                                    min: o[0].min,
                                    max: o[0].max
                                })])
                            }, []);
                            n.ctx.updateHelpers._updateOptions({
                                xaxis: {
                                    min: s.xaxis.min,
                                    max: s.xaxis.max
                                },
                                yaxis: d
                            }, !1, !1, !1, !1)
                        })
                    }
                }
            }
        }]),
        C
    }(), ya = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "_updateOptions",
            value: function(e) {
                var t = this
                  , i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
                  , r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                return new Promise(function(n) {
                    var o = [t.ctx];
                    s && (o = t.ctx.getSyncedCharts()),
                    t.ctx.w.globals.isExecCalled && (o = [t.ctx],
                    t.ctx.w.globals.isExecCalled = !1),
                    o.forEach(function(h, d) {
                        var u = h.w;
                        if (u.globals.shouldAnimate = a,
                        i || (u.globals.resized = !0,
                        u.globals.dataChanged = !0,
                        a && h.series.getPreviousPaths()),
                        e && "object" === Ke(e) && (h.config = new St(e),
                        e = ae.extendArrayProps(h.config, e, u),
                        h.w.globals.chartID !== t.ctx.w.globals.chartID && delete e.series,
                        u.config = D.extend(u.config, e),
                        r && (u.globals.lastXAxis = e.xaxis ? D.clone(e.xaxis) : [],
                        u.globals.lastYAxis = e.yaxis ? D.clone(e.yaxis) : [],
                        u.globals.initialConfig = D.extend({}, u.config),
                        u.globals.initialSeries = D.clone(u.config.series),
                        e.series))) {
                            for (var p = 0; p < u.globals.collapsedSeriesIndices.length; p++) {
                                var x = u.config.series[u.globals.collapsedSeriesIndices[p]];
                                u.globals.collapsedSeries[p].data = u.globals.axisCharts ? x.data.slice() : x
                            }
                            for (var b = 0; b < u.globals.ancillaryCollapsedSeriesIndices.length; b++) {
                                var k = u.config.series[u.globals.ancillaryCollapsedSeriesIndices[b]];
                                u.globals.ancillaryCollapsedSeries[b].data = u.globals.axisCharts ? k.data.slice() : k
                            }
                            h.series.emptyCollapsedSeries(u.config.series)
                        }
                        return h.update(e).then(function() {
                            d === o.length - 1 && n(h)
                        })
                    })
                }
                )
            }
        }, {
            key: "_updateSeries",
            value: function(e, t) {
                var i = this
                  , a = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                return new Promise(function(s) {
                    var r, n = i.w;
                    return n.globals.shouldAnimate = t,
                    n.globals.dataChanged = !0,
                    t && i.ctx.series.getPreviousPaths(),
                    n.globals.axisCharts ? (0 === (r = e.map(function(o, h) {
                        return i._extendSeries(o, h)
                    })).length && (r = [{
                        data: []
                    }]),
                    n.config.series = r) : n.config.series = e.slice(),
                    a && (n.globals.initialConfig.series = D.clone(n.config.series),
                    n.globals.initialSeries = D.clone(n.config.series)),
                    i.ctx.update().then(function() {
                        s(i.ctx)
                    })
                }
                )
            }
        }, {
            key: "_extendSeries",
            value: function(e, t) {
                var i = this.w
                  , a = i.config.series[t];
                return K(K({}, i.config.series[t]), {}, {
                    name: e.name ? e.name : a && a.name,
                    color: e.color ? e.color : a && a.color,
                    type: e.type ? e.type : a && a.type,
                    group: e.group ? e.group : a && a.group,
                    data: e.data ? e.data : a && a.data
                })
            }
        }, {
            key: "toggleDataPointSelection",
            value: function(e, t) {
                var i = this.w
                  , a = null
                  , s = ".apexcharts-series[data\\:realIndex='".concat(e, "']");
                return i.globals.axisCharts ? a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(t, "'], ").concat(s, " circle[j='").concat(t, "'], ").concat(s, " rect[j='").concat(t, "']")).members[0] : void 0 === t && (a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(e, "']")).members[0],
                "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(e)),
                a ? (new U(this.ctx).pathMouseDown(a, null),
                a.node ? a.node : null) : (console.warn("toggleDataPointSelection: Element not found"),
                null)
            }
        }, {
            key: "forceXAxisUpdate",
            value: function(e) {
                var t = this.w;
                if (["min", "max"].forEach(function(a) {
                    void 0 !== e.xaxis[a] && (t.config.xaxis[a] = e.xaxis[a],
                    t.globals.lastXAxis[a] = e.xaxis[a])
                }),
                e.xaxis.categories && e.xaxis.categories.length && (t.config.xaxis.categories = e.xaxis.categories),
                t.config.xaxis.convertedCatToNumeric) {
                    var i = new xt(e);
                    e = i.convertCatToNumericXaxis(e, this.ctx)
                }
                return e
            }
        }, {
            key: "forceYAxisUpdate",
            value: function(e) {
                return e.chart && e.chart.stacked && "100%" === e.chart.stackType && (Array.isArray(e.yaxis) ? e.yaxis.forEach(function(t, i) {
                    e.yaxis[i].min = 0,
                    e.yaxis[i].max = 100
                }) : (e.yaxis.min = 0,
                e.yaxis.max = 100)),
                e
            }
        }, {
            key: "revertDefaultAxisMinMax",
            value: function(e) {
                var t = this
                  , i = this.w
                  , a = i.globals.lastXAxis
                  , s = i.globals.lastYAxis;
                e && e.xaxis && (a = e.xaxis),
                e && e.yaxis && (s = e.yaxis),
                i.config.xaxis.min = a.min,
                i.config.xaxis.max = a.max,
                i.config.yaxis.map(function(n, o) {
                    i.globals.zoomed || void 0 !== s[o] ? function(n) {
                        void 0 !== s[n] && (i.config.yaxis[n].min = s[n].min,
                        i.config.yaxis[n].max = s[n].max)
                    }(o) : void 0 !== t.ctx.opts.yaxis[o] && (n.min = t.ctx.opts.yaxis[o].min,
                    n.max = t.ctx.opts.yaxis[o].max)
                })
            }
        }]),
        C
    }();
    bi = typeof window < "u" ? window : void 0,
    yi = function(C, e) {
        var t = (void 0 !== this ? this : C).SVG = function(l) {
            if (t.supported)
                return l = new t.Doc(l),
                t.parser.draw || t.prepare(),
                l
        }
        ;
        if (t.ns = "http://www.w3.org/2000/svg",
        t.xmlns = "http://www.w3.org/2000/xmlns/",
        t.xlink = "http://www.w3.org/1999/xlink",
        t.svgjs = "http://svgjs.dev",
        t.supported = !0,
        !t.supported)
            return !1;
        t.did = 1e3,
        t.eid = function(l) {
            return "Svgjs" + d(l) + t.did++
        }
        ,
        t.create = function(l) {
            var f = e.createElementNS(this.ns, l);
            return f.setAttribute("id", this.eid(l)),
            f
        }
        ,
        t.extend = function() {
            var l, f;
            f = (l = [].slice.call(arguments)).pop();
            for (var w = l.length - 1; w >= 0; w--)
                if (l[w])
                    for (var _ in f)
                        l[w].prototype[_] = f[_];
            t.Set && t.Set.inherit && t.Set.inherit()
        }
        ,
        t.invent = function(l) {
            var f = "function" == typeof l.create ? l.create : function() {
                this.constructor.call(this, t.create(l.create))
            }
            ;
            return l.inherit && (f.prototype = new l.inherit),
            l.extend && t.extend(f, l.extend),
            l.construct && t.extend(l.parent || t.Container, l.construct),
            f
        }
        ,
        t.adopt = function(l) {
            return l ? l.instance ? l.instance : ((f = "svg" == l.nodeName ? l.parentNode instanceof C.SVGElement ? new t.Nested : new t.Doc : "linearGradient" == l.nodeName ? new t.Gradient("linear") : "radialGradient" == l.nodeName ? new t.Gradient("radial") : t[d(l.nodeName)] ? new (t[d(l.nodeName)]) : new t.Element(l)).type = l.nodeName,
            f.node = l,
            l.instance = f,
            f instanceof t.Doc && f.namespace().defs(),
            f.setData(JSON.parse(l.getAttribute("svgjs:data")) || {}),
            f) : null;
            var f
        }
        ,
        t.prepare = function() {
            var l = e.getElementsByTagName("body")[0]
              , f = (l ? new t.Doc(l) : t.adopt(e.documentElement).nested()).size(2, 0);
            t.parser = {
                body: l || e.documentElement,
                draw: f.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                poly: f.polyline().node,
                path: f.path().node,
                native: t.create("svg")
            }
        }
        ,
        t.parser = {
            native: t.create("svg")
        },
        e.addEventListener("DOMContentLoaded", function() {
            t.parser.draw || t.prepare()
        }, !1),
        t.regex = {
            numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
            hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
            rgb: /rgb\((\d+),(\d+),(\d+)\)/,
            reference: /#([a-z0-9\-_]+)/i,
            transforms: /\)\s*,?\s*/,
            whitespace: /\s/g,
            isHex: /^#[a-f0-9]{3,6}$/i,
            isRgb: /^rgb\(/,
            isCss: /[^:]+:[^;]+;?/,
            isBlank: /^(\s+)?$/,
            isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
            isPercent: /^-?[\d\.]+%$/,
            isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
            delimiter: /[\s,]+/,
            hyphen: /([^e])\-/gi,
            pathLetters: /[MLHVCSQTAZ]/gi,
            isPathLetter: /[MLHVCSQTAZ]/i,
            numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
            dots: /\./g
        },
        t.utils = {
            map: function(l, f) {
                for (var w = l.length, _ = [], R = 0; R < w; R++)
                    _.push(f(l[R]));
                return _
            },
            filter: function(l, f) {
                for (var w = l.length, _ = [], R = 0; R < w; R++)
                    f(l[R]) && _.push(l[R]);
                return _
            },
            filterSVGElements: function(l) {
                return this.filter(l, function(f) {
                    return f instanceof C.SVGElement
                })
            }
        },
        t.defaults = {
            attrs: {
                "fill-opacity": 1,
                "stroke-opacity": 1,
                "stroke-width": 0,
                "stroke-linejoin": "miter",
                "stroke-linecap": "butt",
                fill: "#000000",
                stroke: "#000000",
                opacity: 1,
                x: 0,
                y: 0,
                cx: 0,
                cy: 0,
                width: 0,
                height: 0,
                r: 0,
                rx: 0,
                ry: 0,
                offset: 0,
                "stop-opacity": 1,
                "stop-color": "#000000",
                "font-size": 16,
                "font-family": "Helvetica, Arial, sans-serif",
                "text-anchor": "start"
            }
        },
        t.Color = function(l) {
            var f, w;
            this.r = 0,
            this.g = 0,
            this.b = 0,
            l && ("string" == typeof l ? t.regex.isRgb.test(l) ? (f = t.regex.rgb.exec(l.replace(t.regex.whitespace, "")),
            this.r = parseInt(f[1]),
            this.g = parseInt(f[2]),
            this.b = parseInt(f[3])) : t.regex.isHex.test(l) && (f = t.regex.hex.exec(4 == (w = l).length ? ["#", w.substring(1, 2), w.substring(1, 2), w.substring(2, 3), w.substring(2, 3), w.substring(3, 4), w.substring(3, 4)].join("") : w),
            this.r = parseInt(f[1], 16),
            this.g = parseInt(f[2], 16),
            this.b = parseInt(f[3], 16)) : "object" === Ke(l) && (this.r = l.r,
            this.g = l.g,
            this.b = l.b))
        }
        ,
        t.extend(t.Color, {
            toString: function() {
                return this.toHex()
            },
            toHex: function() {
                return "#" + u(this.r) + u(this.g) + u(this.b)
            },
            toRgb: function() {
                return "rgb(" + [this.r, this.g, this.b].join() + ")"
            },
            brightness: function() {
                return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
            },
            morph: function(l) {
                return this.destination = new t.Color(l),
                this
            },
            at: function(l) {
                return this.destination ? new t.Color({
                    r: ~~(this.r + (this.destination.r - this.r) * (l = l < 0 ? 0 : l > 1 ? 1 : l)),
                    g: ~~(this.g + (this.destination.g - this.g) * l),
                    b: ~~(this.b + (this.destination.b - this.b) * l)
                }) : this
            }
        }),
        t.Color.test = function(l) {
            return t.regex.isHex.test(l += "") || t.regex.isRgb.test(l)
        }
        ,
        t.Color.isRgb = function(l) {
            return l && "number" == typeof l.r && "number" == typeof l.g && "number" == typeof l.b
        }
        ,
        t.Color.isColor = function(l) {
            return t.Color.isRgb(l) || t.Color.test(l)
        }
        ,
        t.Array = function(l, f) {
            0 == (l = (l || []).valueOf()).length && f && (l = f.valueOf()),
            this.value = this.parse(l)
        }
        ,
        t.extend(t.Array, {
            toString: function() {
                return this.value.join(" ")
            },
            valueOf: function() {
                return this.value
            },
            parse: function(l) {
                return l = l.valueOf(),
                Array.isArray(l) ? l : this.split(l)
            }
        }),
        t.PointArray = function(l, f) {
            t.Array.call(this, l, f || [[0, 0]])
        }
        ,
        t.PointArray.prototype = new t.Array,
        t.PointArray.prototype.constructor = t.PointArray;
        for (var i = {
            M: function(l, f, w) {
                return f.x = w.x = l[0],
                f.y = w.y = l[1],
                ["M", f.x, f.y]
            },
            L: function(l, f) {
                return f.x = l[0],
                f.y = l[1],
                ["L", l[0], l[1]]
            },
            H: function(l, f) {
                return f.x = l[0],
                ["H", l[0]]
            },
            V: function(l, f) {
                return f.y = l[0],
                ["V", l[0]]
            },
            C: function(l, f) {
                return f.x = l[4],
                f.y = l[5],
                ["C", l[0], l[1], l[2], l[3], l[4], l[5]]
            },
            Q: function(l, f) {
                return f.x = l[2],
                f.y = l[3],
                ["Q", l[0], l[1], l[2], l[3]]
            },
            S: function(l, f) {
                return f.x = l[2],
                f.y = l[3],
                ["S", l[0], l[1], l[2], l[3]]
            },
            Z: function(l, f, w) {
                return f.x = w.x,
                f.y = w.y,
                ["Z"]
            }
        }, a = "mlhvqtcsaz".split(""), s = 0, r = a.length; s < r; ++s)
            i[a[s]] = function(l) {
                return function(f, w, _) {
                    if ("H" == l)
                        f[0] = f[0] + w.x;
                    else if ("V" == l)
                        f[0] = f[0] + w.y;
                    else if ("A" == l)
                        f[5] = f[5] + w.x,
                        f[6] = f[6] + w.y;
                    else
                        for (var R = 0, H = f.length; R < H; ++R)
                            f[R] = f[R] + (R % 2 ? w.y : w.x);
                    if (i && "function" == typeof i[l])
                        return i[l](f, w, _)
                }
            }(a[s].toUpperCase());
        t.PathArray = function(l, f) {
            t.Array.call(this, l, f || [["M", 0, 0]])
        }
        ,
        t.PathArray.prototype = new t.Array,
        t.PathArray.prototype.constructor = t.PathArray,
        t.extend(t.PathArray, {
            toString: function() {
                return function(l) {
                    for (var f = 0, w = l.length, _ = ""; f < w; f++)
                        _ += l[f][0],
                        null != l[f][1] && (_ += l[f][1],
                        null != l[f][2] && (_ += " ",
                        _ += l[f][2],
                        null != l[f][3] && (_ += " ",
                        _ += l[f][3],
                        _ += " ",
                        _ += l[f][4],
                        null != l[f][5] && (_ += " ",
                        _ += l[f][5],
                        _ += " ",
                        _ += l[f][6],
                        null != l[f][7] && (_ += " ",
                        _ += l[f][7])))));
                    return _ + " "
                }(this.value)
            },
            move: function(l, f) {
                return this.bbox(),
                this
            },
            at: function(l) {
                if (!this.destination)
                    return this;
                for (var f = this.value, w = this.destination.value, _ = [], R = new t.PathArray, H = 0, B = f.length; H < B; H++) {
                    _[H] = [f[H][0]];
                    for (var j = 1, ce = f[H].length; j < ce; j++)
                        _[H][j] = f[H][j] + (w[H][j] - f[H][j]) * l;
                    "A" === _[H][0] && (_[H][4] = +(0 != _[H][4]),
                    _[H][5] = +(0 != _[H][5]))
                }
                return R.value = _,
                R
            },
            parse: function(l) {
                if (l instanceof t.PathArray)
                    return l.valueOf();
                var f, w = {
                    M: 2,
                    L: 2,
                    H: 1,
                    V: 1,
                    C: 6,
                    S: 4,
                    Q: 4,
                    T: 2,
                    A: 7,
                    Z: 0
                };
                l = "string" == typeof l ? l.replace(t.regex.numbersWithDots, o).replace(t.regex.pathLetters, " $& ").replace(t.regex.hyphen, "$1 -").trim().split(t.regex.delimiter) : l.reduce(function(ce, me) {
                    return [].concat.call(ce, me)
                }, []);
                var _ = []
                  , R = new t.Point
                  , H = new t.Point
                  , B = 0
                  , j = l.length;
                do {
                    t.regex.isPathLetter.test(l[B]) ? (f = l[B],
                    ++B) : "M" == f ? f = "L" : "m" == f && (f = "l"),
                    _.push(i[f].call(null, l.slice(B, B += w[f.toUpperCase()]).map(parseFloat), R, H))
                } while (j > B);
                return _
            },
            bbox: function() {
                return t.parser.draw || t.prepare(),
                t.parser.path.setAttribute("d", this.toString()),
                t.parser.path.getBBox()
            }
        }),
        t.Number = t.invent({
            create: function(l, f) {
                this.value = 0,
                this.unit = f || "",
                "number" == typeof l ? this.value = isNaN(l) ? 0 : isFinite(l) ? l : l < 0 ? -34e37 : 34e37 : "string" == typeof l ? (f = l.match(t.regex.numberAndUnit)) && (this.value = parseFloat(f[1]),
                "%" == f[5] ? this.value /= 100 : "s" == f[5] && (this.value *= 1e3),
                this.unit = f[5]) : l instanceof t.Number && (this.value = l.valueOf(),
                this.unit = l.unit)
            },
            extend: {
                toString: function() {
                    return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                },
                toJSON: function() {
                    return this.toString()
                },
                valueOf: function() {
                    return this.value
                },
                plus: function(l) {
                    return l = new t.Number(l),
                    new t.Number(this + l,this.unit || l.unit)
                },
                minus: function(l) {
                    return l = new t.Number(l),
                    new t.Number(this - l,this.unit || l.unit)
                },
                times: function(l) {
                    return l = new t.Number(l),
                    new t.Number(this * l,this.unit || l.unit)
                },
                divide: function(l) {
                    return l = new t.Number(l),
                    new t.Number(this / l,this.unit || l.unit)
                },
                to: function(l) {
                    var f = new t.Number(this);
                    return "string" == typeof l && (f.unit = l),
                    f
                },
                morph: function(l) {
                    return this.destination = new t.Number(l),
                    l.relative && (this.destination.value += this.value),
                    this
                },
                at: function(l) {
                    return this.destination ? new t.Number(this.destination).minus(this).times(l).plus(this) : this
                }
            }
        }),
        t.Element = t.invent({
            create: function(l) {
                this._stroke = t.defaults.attrs.stroke,
                this._event = null,
                this.dom = {},
                (this.node = l) && (this.type = l.nodeName,
                this.node.instance = this,
                this._stroke = l.getAttribute("stroke") || this._stroke)
            },
            extend: {
                x: function(l) {
                    return this.attr("x", l)
                },
                y: function(l) {
                    return this.attr("y", l)
                },
                cx: function(l) {
                    return null == l ? this.x() + this.width() / 2 : this.x(l - this.width() / 2)
                },
                cy: function(l) {
                    return null == l ? this.y() + this.height() / 2 : this.y(l - this.height() / 2)
                },
                move: function(l, f) {
                    return this.x(l).y(f)
                },
                center: function(l, f) {
                    return this.cx(l).cy(f)
                },
                width: function(l) {
                    return this.attr("width", l)
                },
                height: function(l) {
                    return this.attr("height", l)
                },
                size: function(l, f) {
                    var w = p(this, l, f);
                    return this.width(new t.Number(w.width)).height(new t.Number(w.height))
                },
                clone: function(l) {
                    this.writeDataToDom();
                    var f = k(this.node.cloneNode(!0));
                    return l ? l.add(f) : this.after(f),
                    f
                },
                remove: function() {
                    return this.parent() && this.parent().removeElement(this),
                    this
                },
                replace: function(l) {
                    return this.after(l).remove(),
                    l
                },
                addTo: function(l) {
                    return l.put(this)
                },
                putIn: function(l) {
                    return l.add(this)
                },
                id: function(l) {
                    return this.attr("id", l)
                },
                show: function() {
                    return this.style("display", "")
                },
                hide: function() {
                    return this.style("display", "none")
                },
                visible: function() {
                    return "none" != this.style("display")
                },
                toString: function() {
                    return this.attr("id")
                },
                classes: function() {
                    var l = this.attr("class");
                    return null == l ? [] : l.trim().split(t.regex.delimiter)
                },
                hasClass: function(l) {
                    return -1 != this.classes().indexOf(l)
                },
                addClass: function(l) {
                    if (!this.hasClass(l)) {
                        var f = this.classes();
                        f.push(l),
                        this.attr("class", f.join(" "))
                    }
                    return this
                },
                removeClass: function(l) {
                    return this.hasClass(l) && this.attr("class", this.classes().filter(function(f) {
                        return f != l
                    }).join(" ")),
                    this
                },
                toggleClass: function(l) {
                    return this.hasClass(l) ? this.removeClass(l) : this.addClass(l)
                },
                reference: function(l) {
                    return t.get(this.attr(l))
                },
                parent: function(l) {
                    var f = this;
                    if (!f.node.parentNode)
                        return null;
                    if (f = t.adopt(f.node.parentNode),
                    !l)
                        return f;
                    for (; f && f.node instanceof C.SVGElement; ) {
                        if ("string" == typeof l ? f.matches(l) : f instanceof l)
                            return f;
                        if (!f.node.parentNode || "#document" == f.node.parentNode.nodeName)
                            return null;
                        f = t.adopt(f.node.parentNode)
                    }
                },
                doc: function() {
                    return this instanceof t.Doc ? this : this.parent(t.Doc)
                },
                parents: function(l) {
                    var f = []
                      , w = this;
                    do {
                        if (!(w = w.parent(l)) || !w.node)
                            break;
                        f.push(w)
                    } while (w.parent);
                    return f
                },
                matches: function(l) {
                    return ((f = this.node).matches || f.matchesSelector || f.msMatchesSelector || f.mozMatchesSelector || f.webkitMatchesSelector || f.oMatchesSelector).call(f, l);
                    var f
                },
                native: function() {
                    return this.node
                },
                svg: function(l) {
                    var f = e.createElement("svg");
                    if (!(l && this instanceof t.Parent))
                        return f.appendChild(l = e.createElement("svg")),
                        this.writeDataToDom(),
                        l.appendChild(this.node.cloneNode(!0)),
                        f.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                    f.innerHTML = "<svg>" + l.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                    for (var w = 0, _ = f.firstChild.childNodes.length; w < _; w++)
                        this.node.appendChild(f.firstChild.firstChild);
                    return this
                },
                writeDataToDom: function() {
                    return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
                        this.writeDataToDom()
                    }),
                    this.node.removeAttribute("svgjs:data"),
                    Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)),
                    this
                },
                setData: function(l) {
                    return this.dom = l,
                    this
                },
                is: function(l) {
                    return this instanceof l
                }
            }
        }),
        t.easing = {
            "-": function(l) {
                return l
            },
            "<>": function(l) {
                return -Math.cos(l * Math.PI) / 2 + .5
            },
            ">": function(l) {
                return Math.sin(l * Math.PI / 2)
            },
            "<": function(l) {
                return 1 - Math.cos(l * Math.PI / 2)
            }
        },
        t.morph = function(l) {
            return function(f, w) {
                return new t.MorphObj(f,w).at(l)
            }
        }
        ,
        t.Situation = t.invent({
            create: function(l) {
                this.init = !1,
                this.reversed = !1,
                this.reversing = !1,
                this.duration = new t.Number(l.duration).valueOf(),
                this.delay = new t.Number(l.delay).valueOf(),
                this.start = +new Date + this.delay,
                this.finish = this.start + this.duration,
                this.ease = l.ease,
                this.loop = 0,
                this.loops = !1,
                this.animations = {},
                this.attrs = {},
                this.styles = {},
                this.transforms = [],
                this.once = {}
            }
        }),
        t.FX = t.invent({
            create: function(l) {
                this._target = l,
                this.situations = [],
                this.active = !1,
                this.situation = null,
                this.paused = !1,
                this.lastPos = 0,
                this.pos = 0,
                this.absPos = 0,
                this._speed = 1
            },
            extend: {
                animate: function(l, f, w) {
                    "object" === Ke(l) && (f = l.ease,
                    w = l.delay,
                    l = l.duration);
                    var _ = new t.Situation({
                        duration: l || 1e3,
                        delay: w || 0,
                        ease: t.easing[f || "-"] || f
                    });
                    return this.queue(_),
                    this
                },
                target: function(l) {
                    return l && l instanceof t.Element ? (this._target = l,
                    this) : this._target
                },
                timeToAbsPos: function(l) {
                    return (l - this.situation.start) / (this.situation.duration / this._speed)
                },
                absPosToTime: function(l) {
                    return this.situation.duration / this._speed * l + this.situation.start
                },
                startAnimFrame: function() {
                    this.stopAnimFrame(),
                    this.animationFrame = C.requestAnimationFrame(function() {
                        this.step()
                    }
                    .bind(this))
                },
                stopAnimFrame: function() {
                    C.cancelAnimationFrame(this.animationFrame)
                },
                start: function() {
                    return !this.active && this.situation && (this.active = !0,
                    this.startCurrent()),
                    this
                },
                startCurrent: function() {
                    return this.situation.start = +new Date + this.situation.delay / this._speed,
                    this.situation.finish = this.situation.start + this.situation.duration / this._speed,
                    this.initAnimations().step()
                },
                queue: function(l) {
                    return ("function" == typeof l || l instanceof t.Situation) && this.situations.push(l),
                    this.situation || (this.situation = this.situations.shift()),
                    this
                },
                dequeue: function() {
                    return this.stop(),
                    this.situation = this.situations.shift(),
                    this.situation && (this.situation instanceof t.Situation ? this.start() : this.situation.call(this)),
                    this
                },
                initAnimations: function() {
                    var l, f = this.situation;
                    if (f.init)
                        return this;
                    for (var w in f.animations) {
                        l = this.target()[w](),
                        Array.isArray(l) || (l = [l]),
                        Array.isArray(f.animations[w]) || (f.animations[w] = [f.animations[w]]);
                        for (var _ = l.length; _--; )
                            f.animations[w][_]instanceof t.Number && (l[_] = new t.Number(l[_])),
                            f.animations[w][_] = l[_].morph(f.animations[w][_])
                    }
                    for (var w in f.attrs)
                        f.attrs[w] = new t.MorphObj(this.target().attr(w),f.attrs[w]);
                    for (var w in f.styles)
                        f.styles[w] = new t.MorphObj(this.target().style(w),f.styles[w]);
                    return f.initialTransformation = this.target().matrixify(),
                    f.init = !0,
                    this
                },
                clearQueue: function() {
                    return this.situations = [],
                    this
                },
                clearCurrent: function() {
                    return this.situation = null,
                    this
                },
                stop: function(l, f) {
                    var w = this.active;
                    return this.active = !1,
                    f && this.clearQueue(),
                    l && this.situation && (!w && this.startCurrent(),
                    this.atEnd()),
                    this.stopAnimFrame(),
                    this.clearCurrent()
                },
                after: function(l) {
                    var f = this.last();
                    return this.target().on("finished.fx", function w(_) {
                        _.detail.situation == f && (l.call(this, f),
                        this.off("finished.fx", w))
                    }),
                    this._callStart()
                },
                during: function(l) {
                    var f = this.last()
                      , w = function(_) {
                        _.detail.situation == f && l.call(this, _.detail.pos, t.morph(_.detail.pos), _.detail.eased, f)
                    };
                    return this.target().off("during.fx", w).on("during.fx", w),
                    this.after(function() {
                        this.off("during.fx", w)
                    }),
                    this._callStart()
                },
                afterAll: function(l) {
                    var f = function w(_) {
                        l.call(this),
                        this.off("allfinished.fx", w)
                    };
                    return this.target().off("allfinished.fx", f).on("allfinished.fx", f),
                    this._callStart()
                },
                last: function() {
                    return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                },
                add: function(l, f, w) {
                    return this.last()[w || "animations"][l] = f,
                    this._callStart()
                },
                step: function(l) {
                    var f, w, _;
                    l || (this.absPos = this.timeToAbsPos(+new Date)),
                    !1 !== this.situation.loops ? (f = Math.max(this.absPos, 0),
                    w = Math.floor(f),
                    !0 === this.situation.loops || w < this.situation.loops ? (this.pos = f - w,
                    _ = this.situation.loop,
                    this.situation.loop = w) : (this.absPos = this.situation.loops,
                    this.pos = 1,
                    _ = this.situation.loop - 1,
                    this.situation.loop = this.situation.loops),
                    this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - _) % 2))) : (this.absPos = Math.min(this.absPos, 1),
                    this.pos = this.absPos),
                    this.pos < 0 && (this.pos = 0),
                    this.situation.reversed && (this.pos = 1 - this.pos);
                    var R = this.situation.ease(this.pos);
                    for (var H in this.situation.once)
                        H > this.lastPos && H <= R && (this.situation.once[H].call(this.target(), this.pos, R),
                        delete this.situation.once[H]);
                    return this.active && this.target().fire("during", {
                        pos: this.pos,
                        eased: R,
                        fx: this,
                        situation: this.situation
                    }),
                    this.situation ? (this.eachAt(),
                    1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(),
                    this.target().fire("finished", {
                        fx: this,
                        situation: this.situation
                    }),
                    this.situations.length || (this.target().fire("allfinished"),
                    this.situations.length || (this.target().off(".fx"),
                    this.active = !1)),
                    this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(),
                    this.lastPos = R,
                    this) : this
                },
                eachAt: function() {
                    var l, f = this, w = this.target(), _ = this.situation;
                    for (var R in _.animations)
                        l = [].concat(_.animations[R]).map(function(j) {
                            return "string" != typeof j && j.at ? j.at(_.ease(f.pos), f.pos) : j
                        }),
                        w[R].apply(w, l);
                    for (var R in _.attrs)
                        l = [R].concat(_.attrs[R]).map(function(ce) {
                            return "string" != typeof ce && ce.at ? ce.at(_.ease(f.pos), f.pos) : ce
                        }),
                        w.attr.apply(w, l);
                    for (var R in _.styles)
                        l = [R].concat(_.styles[R]).map(function(ce) {
                            return "string" != typeof ce && ce.at ? ce.at(_.ease(f.pos), f.pos) : ce
                        }),
                        w.style.apply(w, l);
                    if (_.transforms.length) {
                        l = _.initialTransformation,
                        R = 0;
                        for (var H = _.transforms.length; R < H; R++) {
                            var B = _.transforms[R];
                            B instanceof t.Matrix ? l = B.relative ? l.multiply((new t.Matrix).morph(B).at(_.ease(this.pos))) : l.morph(B).at(_.ease(this.pos)) : (B.relative || B.undo(l.extract()),
                            l = l.multiply(B.at(_.ease(this.pos))))
                        }
                        w.matrix(l)
                    }
                    return this
                },
                once: function(l, f, w) {
                    var _ = this.last();
                    return w || (l = _.ease(l)),
                    _.once[l] = f,
                    this
                },
                _callStart: function() {
                    return setTimeout(function() {
                        this.start()
                    }
                    .bind(this), 0),
                    this
                }
            },
            parent: t.Element,
            construct: {
                animate: function(l, f, w) {
                    return (this.fx || (this.fx = new t.FX(this))).animate(l, f, w)
                },
                delay: function(l) {
                    return (this.fx || (this.fx = new t.FX(this))).delay(l)
                },
                stop: function(l, f) {
                    return this.fx && this.fx.stop(l, f),
                    this
                },
                finish: function() {
                    return this.fx && this.fx.finish(),
                    this
                }
            }
        }),
        t.MorphObj = t.invent({
            create: function(l, f) {
                return t.Color.isColor(f) ? new t.Color(l).morph(f) : t.regex.delimiter.test(l) ? t.regex.pathLetters.test(l) ? new t.PathArray(l).morph(f) : new t.Array(l).morph(f) : t.regex.numberAndUnit.test(f) ? new t.Number(l).morph(f) : (this.value = l,
                void (this.destination = f))
            },
            extend: {
                at: function(l, f) {
                    return f < 1 ? this.value : this.destination
                },
                valueOf: function() {
                    return this.value
                }
            }
        }),
        t.extend(t.FX, {
            attr: function(l, f, w) {
                if ("object" === Ke(l))
                    for (var _ in l)
                        this.attr(_, l[_]);
                else
                    this.add(l, f, "attrs");
                return this
            },
            plot: function(l, f, w, _) {
                return 4 == arguments.length ? this.plot([l, f, w, _]) : this.add("plot", new (this.target().morphArray)(l))
            }
        }),
        t.Box = t.invent({
            create: function(l, f, w, _) {
                if (!("object" !== Ke(l) || l instanceof t.Element))
                    return t.Box.call(this, null != l.left ? l.left : l.x, null != l.top ? l.top : l.y, l.width, l.height);
                var R;
                4 == arguments.length && (this.x = l,
                this.y = f,
                this.width = w,
                this.height = _),
                null == (R = this).x && (R.x = 0,
                R.y = 0,
                R.width = 0,
                R.height = 0),
                R.w = R.width,
                R.h = R.height,
                R.x2 = R.x + R.width,
                R.y2 = R.y + R.height,
                R.cx = R.x + R.width / 2,
                R.cy = R.y + R.height / 2
            }
        }),
        t.BBox = t.invent({
            create: function(l) {
                if (t.Box.apply(this, [].slice.call(arguments)),
                l instanceof t.Element) {
                    var f;
                    try {
                        if (!e.documentElement.contains) {
                            for (var w = l.node; w.parentNode; )
                                w = w.parentNode;
                            if (w != e)
                                throw new Error("Element not in the dom")
                        }
                        f = l.node.getBBox()
                    } catch {
                        if (l instanceof t.Shape) {
                            t.parser.draw || t.prepare();
                            var _ = l.clone(t.parser.draw.instance).show();
                            _ && _.node && "function" == typeof _.node.getBBox && (f = _.node.getBBox()),
                            _ && "function" == typeof _.remove && _.remove()
                        } else
                            f = {
                                x: l.node.clientLeft,
                                y: l.node.clientTop,
                                width: l.node.clientWidth,
                                height: l.node.clientHeight
                            }
                    }
                    t.Box.call(this, f)
                }
            },
            inherit: t.Box,
            parent: t.Element,
            construct: {
                bbox: function() {
                    return new t.BBox(this)
                }
            }
        }),
        t.BBox.prototype.constructor = t.BBox,
        t.Matrix = t.invent({
            create: function(l) {
                var f = b([1, 0, 0, 1, 0, 0]);
                l = null === l ? f : l instanceof t.Element ? l.matrixify() : "string" == typeof l ? b(l.split(t.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? b([].slice.call(arguments)) : Array.isArray(l) ? b(l) : l && "object" === Ke(l) ? l : f;
                for (var w = E.length - 1; w >= 0; --w)
                    this[E[w]] = null != l[E[w]] ? l[E[w]] : f[E[w]]
            },
            extend: {
                extract: function() {
                    var l = x(this, 0, 1);
                    x(this, 1, 0);
                    var f = 180 / Math.PI * Math.atan2(l.y, l.x) - 90;
                    return {
                        x: this.e,
                        y: this.f,
                        transformedX: (this.e * Math.cos(f * Math.PI / 180) + this.f * Math.sin(f * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                        transformedY: (this.f * Math.cos(f * Math.PI / 180) + this.e * Math.sin(-f * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                        rotation: f,
                        a: this.a,
                        b: this.b,
                        c: this.c,
                        d: this.d,
                        e: this.e,
                        f: this.f,
                        matrix: new t.Matrix(this)
                    }
                },
                clone: function() {
                    return new t.Matrix(this)
                },
                morph: function(l) {
                    return this.destination = new t.Matrix(l),
                    this
                },
                multiply: function(l) {
                    return new t.Matrix(this.native().multiply((f = l,
                    f instanceof t.Matrix || (f = new t.Matrix(f)),
                    f).native()));
                    var f
                },
                inverse: function() {
                    return new t.Matrix(this.native().inverse())
                },
                translate: function(l, f) {
                    return new t.Matrix(this.native().translate(l || 0, f || 0))
                },
                native: function() {
                    for (var l = t.parser.native.createSVGMatrix(), f = E.length - 1; f >= 0; f--)
                        l[E[f]] = this[E[f]];
                    return l
                },
                toString: function() {
                    return "matrix(" + S(this.a) + "," + S(this.b) + "," + S(this.c) + "," + S(this.d) + "," + S(this.e) + "," + S(this.f) + ")"
                }
            },
            parent: t.Element,
            construct: {
                ctm: function() {
                    return new t.Matrix(this.node.getCTM())
                },
                screenCTM: function() {
                    if (this instanceof t.Nested) {
                        var l = this.rect(1, 1)
                          , f = l.node.getScreenCTM();
                        return l.remove(),
                        new t.Matrix(f)
                    }
                    return new t.Matrix(this.node.getScreenCTM())
                }
            }
        }),
        t.Point = t.invent({
            create: function(l, f) {
                var w;
                w = Array.isArray(l) ? {
                    x: l[0],
                    y: l[1]
                } : "object" === Ke(l) ? {
                    x: l.x,
                    y: l.y
                } : null != l ? {
                    x: l,
                    y: f ?? l
                } : {
                    x: 0,
                    y: 0
                },
                this.x = w.x,
                this.y = w.y
            },
            extend: {
                clone: function() {
                    return new t.Point(this)
                },
                morph: function(l, f) {
                    return this.destination = new t.Point(l,f),
                    this
                }
            }
        }),
        t.extend(t.Element, {
            point: function(l, f) {
                return new t.Point(l,f).transform(this.screenCTM().inverse())
            }
        }),
        t.extend(t.Element, {
            attr: function(l, f, w) {
                if (null == l) {
                    for (l = {},
                    w = (f = this.node.attributes).length - 1; w >= 0; w--)
                        l[f[w].nodeName] = t.regex.isNumber.test(f[w].nodeValue) ? parseFloat(f[w].nodeValue) : f[w].nodeValue;
                    return l
                }
                if ("object" === Ke(l))
                    for (var _ in l)
                        this.attr(_, l[_]);
                else if (null === f)
                    this.node.removeAttribute(l);
                else {
                    if (null == f)
                        return null == (f = this.node.getAttribute(l)) ? t.defaults.attrs[l] : t.regex.isNumber.test(f) ? parseFloat(f) : f;
                    "stroke-width" == l ? this.attr("stroke", parseFloat(f) > 0 ? this._stroke : null) : "stroke" == l && (this._stroke = f),
                    "fill" != l && "stroke" != l || (t.regex.isImage.test(f) && (f = this.doc().defs().image(f, 0, 0)),
                    f instanceof t.Image && (f = this.doc().defs().pattern(0, 0, function() {
                        this.add(f)
                    }))),
                    "number" == typeof f ? f = new t.Number(f) : t.Color.isColor(f) ? f = new t.Color(f) : Array.isArray(f) && (f = new t.Array(f)),
                    "leading" == l ? this.leading && this.leading(f) : "string" == typeof w ? this.node.setAttributeNS(w, l, f.toString()) : this.node.setAttribute(l, f.toString()),
                    !this.rebuild || "font-size" != l && "x" != l || this.rebuild(l, f)
                }
                return this
            }
        }),
        t.extend(t.Element, {
            transform: function(l, f) {
                var w;
                return "object" !== Ke(l) ? (w = new t.Matrix(this).extract(),
                "string" == typeof l ? w[l] : w) : (w = new t.Matrix(this),
                f = !!f || !!l.relative,
                null != l.a && (w = f ? w.multiply(new t.Matrix(l)) : new t.Matrix(l)),
                this.attr("transform", w))
            }
        }),
        t.extend(t.Element, {
            untransform: function() {
                return this.attr("transform", null)
            },
            matrixify: function() {
                return (this.attr("transform") || "").split(t.regex.transforms).slice(0, -1).map(function(l) {
                    var f = l.trim().split("(");
                    return [f[0], f[1].split(t.regex.delimiter).map(function(w) {
                        return parseFloat(w)
                    })]
                }).reduce(function(l, f) {
                    return "matrix" == f[0] ? l.multiply(b(f[1])) : l[f[0]].apply(l, f[1])
                }, new t.Matrix)
            },
            toParent: function(l) {
                if (this == l)
                    return this;
                var f = this.screenCTM()
                  , w = l.screenCTM().inverse();
                return this.addTo(l).untransform().transform(w.multiply(f)),
                this
            },
            toDoc: function() {
                return this.toParent(this.doc())
            }
        }),
        t.Transformation = t.invent({
            create: function(l, f) {
                if (arguments.length > 1 && "boolean" != typeof f)
                    return this.constructor.call(this, [].slice.call(arguments));
                if (Array.isArray(l))
                    for (var w = 0, _ = this.arguments.length; w < _; ++w)
                        this[this.arguments[w]] = l[w];
                else if (l && "object" === Ke(l))
                    for (w = 0,
                    _ = this.arguments.length; w < _; ++w)
                        this[this.arguments[w]] = l[this.arguments[w]];
                this.inversed = !1,
                !0 === f && (this.inversed = !0)
            }
        }),
        t.Translate = t.invent({
            parent: t.Matrix,
            inherit: t.Transformation,
            create: function(l, f) {
                this.constructor.apply(this, [].slice.call(arguments))
            },
            extend: {
                arguments: ["transformedX", "transformedY"],
                method: "translate"
            }
        }),
        t.extend(t.Element, {
            style: function(l, f) {
                if (0 == arguments.length)
                    return this.node.style.cssText || "";
                if (arguments.length < 2)
                    if ("object" === Ke(l))
                        for (var w in l)
                            this.style(w, l[w]);
                    else {
                        if (!t.regex.isCss.test(l))
                            return this.node.style[h(l)];
                        for (l = l.split(/\s*;\s*/).filter(function(_) {
                            return !!_
                        }).map(function(_) {
                            return _.split(/\s*:\s*/)
                        }); f = l.pop(); )
                            this.style(f[0], f[1])
                    }
                else
                    this.node.style[h(l)] = null === f || t.regex.isBlank.test(f) ? "" : f;
                return this
            }
        }),
        t.Parent = t.invent({
            create: function(l) {
                this.constructor.call(this, l)
            },
            inherit: t.Element,
            extend: {
                children: function() {
                    return t.utils.map(t.utils.filterSVGElements(this.node.childNodes), function(l) {
                        return t.adopt(l)
                    })
                },
                add: function(l, f) {
                    return null == f ? this.node.appendChild(l.node) : l.node != this.node.childNodes[f] && this.node.insertBefore(l.node, this.node.childNodes[f]),
                    this
                },
                put: function(l, f) {
                    return this.add(l, f),
                    l
                },
                has: function(l) {
                    return this.index(l) >= 0
                },
                index: function(l) {
                    return [].slice.call(this.node.childNodes).indexOf(l.node)
                },
                get: function(l) {
                    return t.adopt(this.node.childNodes[l])
                },
                first: function() {
                    return this.get(0)
                },
                last: function() {
                    return this.get(this.node.childNodes.length - 1)
                },
                each: function(l, f) {
                    for (var w = this.children(), _ = 0, R = w.length; _ < R; _++)
                        w[_]instanceof t.Element && l.apply(w[_], [_, w]),
                        f && w[_]instanceof t.Container && w[_].each(l, f);
                    return this
                },
                removeElement: function(l) {
                    return this.node.removeChild(l.node),
                    this
                },
                clear: function() {
                    for (; this.node.hasChildNodes(); )
                        this.node.removeChild(this.node.lastChild);
                    return delete this._defs,
                    this
                },
                defs: function() {
                    return this.doc().defs()
                }
            }
        }),
        t.extend(t.Parent, {
            ungroup: function(l, f) {
                return 0 === f || this instanceof t.Defs || this.node == t.parser.draw || (l = l || (this instanceof t.Doc ? this : this.parent(t.Parent)),
                f = f || 1 / 0,
                this.each(function() {
                    return this instanceof t.Defs ? this : this instanceof t.Parent ? this.ungroup(l, f - 1) : this.toParent(l)
                }),
                this.node.firstChild || this.remove()),
                this
            },
            flatten: function(l, f) {
                return this.ungroup(l, f)
            }
        }),
        t.Container = t.invent({
            create: function(l) {
                this.constructor.call(this, l)
            },
            inherit: t.Parent
        }),
        t.ViewBox = t.invent({
            parent: t.Container,
            construct: {}
        }),
        ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(l) {
            t.Element.prototype[l] = function(f) {
                return t.on(this.node, l, f),
                this
            }
        }),
        t.listeners = [],
        t.handlerMap = [],
        t.listenerId = 0,
        t.on = function(l, f, w, _, R) {
            var H = w.bind(_ || l.instance || l)
              , B = (t.handlerMap.indexOf(l) + 1 || t.handlerMap.push(l)) - 1
              , j = f.split(".")[0]
              , ce = f.split(".")[1] || "*";
            t.listeners[B] = t.listeners[B] || {},
            t.listeners[B][j] = t.listeners[B][j] || {},
            t.listeners[B][j][ce] = t.listeners[B][j][ce] || {},
            w._svgjsListenerId || (w._svgjsListenerId = ++t.listenerId),
            t.listeners[B][j][ce][w._svgjsListenerId] = H,
            l.addEventListener(j, H, R || {
                passive: !0
            })
        }
        ,
        t.off = function(l, f, w) {
            var _ = t.handlerMap.indexOf(l)
              , R = f && f.split(".")[0]
              , H = f && f.split(".")[1]
              , B = "";
            if (-1 != _)
                if (w) {
                    if ("function" == typeof w && (w = w._svgjsListenerId),
                    !w)
                        return;
                    t.listeners[_][R] && t.listeners[_][R][H || "*"] && (l.removeEventListener(R, t.listeners[_][R][H || "*"][w], !1),
                    delete t.listeners[_][R][H || "*"][w])
                } else if (H && R) {
                    if (t.listeners[_][R] && t.listeners[_][R][H]) {
                        for (var j in t.listeners[_][R][H])
                            t.off(l, [R, H].join("."), j);
                        delete t.listeners[_][R][H]
                    }
                } else if (H)
                    for (var ce in t.listeners[_])
                        for (var B in t.listeners[_][ce])
                            H === B && t.off(l, [ce, H].join("."));
                else if (R) {
                    if (t.listeners[_][R]) {
                        for (var B in t.listeners[_][R])
                            t.off(l, [R, B].join("."));
                        delete t.listeners[_][R]
                    }
                } else {
                    for (var ce in t.listeners[_])
                        t.off(l, ce);
                    delete t.listeners[_],
                    delete t.handlerMap[_]
                }
        }
        ,
        t.extend(t.Element, {
            on: function(l, f, w, _) {
                return t.on(this.node, l, f, w, _),
                this
            },
            off: function(l, f) {
                return t.off(this.node, l, f),
                this
            },
            fire: function(l, f) {
                return this.node.dispatchEvent(l instanceof C.Event ? l : l = new t.CustomEvent(l,{
                    detail: f,
                    cancelable: !0
                })),
                this._event = l,
                this
            },
            event: function() {
                return this._event
            }
        }),
        t.Defs = t.invent({
            create: "defs",
            inherit: t.Container
        }),
        t.G = t.invent({
            create: "g",
            inherit: t.Container,
            extend: {
                x: function(l) {
                    return null == l ? this.transform("x") : this.transform({
                        x: l - this.x()
                    }, !0)
                }
            },
            construct: {
                group: function() {
                    return this.put(new t.G)
                }
            }
        }),
        t.Doc = t.invent({
            create: function(l) {
                l && ("svg" == (l = "string" == typeof l ? e.getElementById(l) : l).nodeName ? this.constructor.call(this, l) : (this.constructor.call(this, t.create("svg")),
                l.appendChild(this.node),
                this.size("100%", "100%")),
                this.namespace().defs())
            },
            inherit: t.Container,
            extend: {
                namespace: function() {
                    return this.attr({
                        xmlns: t.ns,
                        version: "1.1"
                    }).attr("xmlns:xlink", t.xlink, t.xmlns).attr("xmlns:svgjs", t.svgjs, t.xmlns)
                },
                defs: function() {
                    var l;
                    return this._defs || (this._defs = (l = this.node.getElementsByTagName("defs")[0]) ? t.adopt(l) : new t.Defs,
                    this.node.appendChild(this._defs.node)),
                    this._defs
                },
                parent: function() {
                    return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                },
                remove: function() {
                    return this.parent() && this.parent().removeChild(this.node),
                    this
                },
                clear: function() {
                    for (; this.node.hasChildNodes(); )
                        this.node.removeChild(this.node.lastChild);
                    return delete this._defs,
                    t.parser.draw && !t.parser.draw.parentNode && this.node.appendChild(t.parser.draw),
                    this
                },
                clone: function(l) {
                    this.writeDataToDom();
                    var f = this.node
                      , w = k(f.cloneNode(!0));
                    return l ? (l.node || l).appendChild(w.node) : f.parentNode.insertBefore(w.node, f.nextSibling),
                    w
                }
            }
        }),
        t.extend(t.Element, {}),
        t.Gradient = t.invent({
            create: function(l) {
                this.constructor.call(this, t.create(l + "Gradient")),
                this.type = l
            },
            inherit: t.Container,
            extend: {
                at: function(l, f, w) {
                    return this.put(new t.Stop).update(l, f, w)
                },
                update: function(l) {
                    return this.clear(),
                    "function" == typeof l && l.call(this, this),
                    this
                },
                fill: function() {
                    return "url(#" + this.id() + ")"
                },
                toString: function() {
                    return this.fill()
                },
                attr: function(l, f, w) {
                    return "transform" == l && (l = "gradientTransform"),
                    t.Container.prototype.attr.call(this, l, f, w)
                }
            },
            construct: {
                gradient: function(l, f) {
                    return this.defs().gradient(l, f)
                }
            }
        }),
        t.extend(t.Gradient, t.FX, {
            from: function(l, f) {
                return this.attr("radial" == (this._target || this).type ? {
                    fx: new t.Number(l),
                    fy: new t.Number(f)
                } : {
                    x1: new t.Number(l),
                    y1: new t.Number(f)
                })
            },
            to: function(l, f) {
                return this.attr("radial" == (this._target || this).type ? {
                    cx: new t.Number(l),
                    cy: new t.Number(f)
                } : {
                    x2: new t.Number(l),
                    y2: new t.Number(f)
                })
            }
        }),
        t.extend(t.Defs, {
            gradient: function(l, f) {
                return this.put(new t.Gradient(l)).update(f)
            }
        }),
        t.Stop = t.invent({
            create: "stop",
            inherit: t.Element,
            extend: {
                update: function(l) {
                    return ("number" == typeof l || l instanceof t.Number) && (l = {
                        offset: arguments[0],
                        color: arguments[1],
                        opacity: arguments[2]
                    }),
                    null != l.opacity && this.attr("stop-opacity", l.opacity),
                    null != l.color && this.attr("stop-color", l.color),
                    null != l.offset && this.attr("offset", new t.Number(l.offset)),
                    this
                }
            }
        }),
        t.Pattern = t.invent({
            create: "pattern",
            inherit: t.Container,
            extend: {
                fill: function() {
                    return "url(#" + this.id() + ")"
                },
                update: function(l) {
                    return this.clear(),
                    "function" == typeof l && l.call(this, this),
                    this
                },
                toString: function() {
                    return this.fill()
                },
                attr: function(l, f, w) {
                    return "transform" == l && (l = "patternTransform"),
                    t.Container.prototype.attr.call(this, l, f, w)
                }
            },
            construct: {
                pattern: function(l, f, w) {
                    return this.defs().pattern(l, f, w)
                }
            }
        }),
        t.extend(t.Defs, {
            pattern: function(l, f, w) {
                return this.put(new t.Pattern).update(w).attr({
                    x: 0,
                    y: 0,
                    width: l,
                    height: f,
                    patternUnits: "userSpaceOnUse"
                })
            }
        }),
        t.Shape = t.invent({
            create: function(l) {
                this.constructor.call(this, l)
            },
            inherit: t.Element
        }),
        t.Symbol = t.invent({
            create: "symbol",
            inherit: t.Container,
            construct: {
                symbol: function() {
                    return this.put(new t.Symbol)
                }
            }
        }),
        t.Use = t.invent({
            create: "use",
            inherit: t.Shape,
            extend: {
                element: function(l, f) {
                    return this.attr("href", (f || "") + "#" + l, t.xlink)
                }
            },
            construct: {
                use: function(l, f) {
                    return this.put(new t.Use).element(l, f)
                }
            }
        }),
        t.Rect = t.invent({
            create: "rect",
            inherit: t.Shape,
            construct: {
                rect: function(l, f) {
                    return this.put(new t.Rect).size(l, f)
                }
            }
        }),
        t.Circle = t.invent({
            create: "circle",
            inherit: t.Shape,
            construct: {
                circle: function(l) {
                    return this.put(new t.Circle).rx(new t.Number(l).divide(2)).move(0, 0)
                }
            }
        }),
        t.extend(t.Circle, t.FX, {
            rx: function(l) {
                return this.attr("r", l)
            },
            ry: function(l) {
                return this.rx(l)
            }
        }),
        t.Ellipse = t.invent({
            create: "ellipse",
            inherit: t.Shape,
            construct: {
                ellipse: function(l, f) {
                    return this.put(new t.Ellipse).size(l, f).move(0, 0)
                }
            }
        }),
        t.extend(t.Ellipse, t.Rect, t.FX, {
            rx: function(l) {
                return this.attr("rx", l)
            },
            ry: function(l) {
                return this.attr("ry", l)
            }
        }),
        t.extend(t.Circle, t.Ellipse, {
            x: function(l) {
                return null == l ? this.cx() - this.rx() : this.cx(l + this.rx())
            },
            y: function(l) {
                return null == l ? this.cy() - this.ry() : this.cy(l + this.ry())
            },
            cx: function(l) {
                return null == l ? this.attr("cx") : this.attr("cx", l)
            },
            cy: function(l) {
                return null == l ? this.attr("cy") : this.attr("cy", l)
            },
            width: function(l) {
                return null == l ? 2 * this.rx() : this.rx(new t.Number(l).divide(2))
            },
            height: function(l) {
                return null == l ? 2 * this.ry() : this.ry(new t.Number(l).divide(2))
            },
            size: function(l, f) {
                var w = p(this, l, f);
                return this.rx(new t.Number(w.width).divide(2)).ry(new t.Number(w.height).divide(2))
            }
        }),
        t.Line = t.invent({
            create: "line",
            inherit: t.Shape,
            extend: {
                array: function() {
                    return new t.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]])
                },
                plot: function(l, f, w, _) {
                    return null == l ? this.array() : (l = void 0 !== f ? {
                        x1: l,
                        y1: f,
                        x2: w,
                        y2: _
                    } : new t.PointArray(l).toLine(),
                    this.attr(l))
                },
                move: function(l, f) {
                    return this.attr(this.array().move(l, f).toLine())
                },
                size: function(l, f) {
                    var w = p(this, l, f);
                    return this.attr(this.array().size(w.width, w.height).toLine())
                }
            },
            construct: {
                line: function(l, f, w, _) {
                    return t.Line.prototype.plot.apply(this.put(new t.Line), null != l ? [l, f, w, _] : [0, 0, 0, 0])
                }
            }
        }),
        t.Polyline = t.invent({
            create: "polyline",
            inherit: t.Shape,
            construct: {
                polyline: function(l) {
                    return this.put(new t.Polyline).plot(l || new t.PointArray)
                }
            }
        }),
        t.Polygon = t.invent({
            create: "polygon",
            inherit: t.Shape,
            construct: {
                polygon: function(l) {
                    return this.put(new t.Polygon).plot(l || new t.PointArray)
                }
            }
        }),
        t.extend(t.Polyline, t.Polygon, {
            array: function() {
                return this._array || (this._array = new t.PointArray(this.attr("points")))
            },
            plot: function(l) {
                return null == l ? this.array() : this.clear().attr("points", "string" == typeof l ? l : this._array = new t.PointArray(l))
            },
            clear: function() {
                return delete this._array,
                this
            },
            move: function(l, f) {
                return this.attr("points", this.array().move(l, f))
            },
            size: function(l, f) {
                var w = p(this, l, f);
                return this.attr("points", this.array().size(w.width, w.height))
            }
        }),
        t.extend(t.Line, t.Polyline, t.Polygon, {
            morphArray: t.PointArray,
            x: function(l) {
                return null == l ? this.bbox().x : this.move(l, this.bbox().y)
            },
            y: function(l) {
                return null == l ? this.bbox().y : this.move(this.bbox().x, l)
            },
            width: function(l) {
                var f = this.bbox();
                return null == l ? f.width : this.size(l, f.height)
            },
            height: function(l) {
                var f = this.bbox();
                return null == l ? f.height : this.size(f.width, l)
            }
        }),
        t.Path = t.invent({
            create: "path",
            inherit: t.Shape,
            extend: {
                morphArray: t.PathArray,
                array: function() {
                    return this._array || (this._array = new t.PathArray(this.attr("d")))
                },
                plot: function(l) {
                    return null == l ? this.array() : this.clear().attr("d", "string" == typeof l ? l : this._array = new t.PathArray(l))
                },
                clear: function() {
                    return delete this._array,
                    this
                }
            },
            construct: {
                path: function(l) {
                    return this.put(new t.Path).plot(l || new t.PathArray)
                }
            }
        }),
        t.Image = t.invent({
            create: "image",
            inherit: t.Shape,
            extend: {
                load: function(l) {
                    if (!l)
                        return this;
                    var f = this
                      , w = new C.Image;
                    return t.on(w, "load", function() {
                        t.off(w);
                        var _ = f.parent(t.Pattern);
                        null !== _ && (0 == f.width() && 0 == f.height() && f.size(w.width, w.height),
                        _ && 0 == _.width() && 0 == _.height() && _.size(f.width(), f.height()),
                        "function" == typeof f._loaded && f._loaded.call(f, {
                            width: w.width,
                            height: w.height,
                            ratio: w.width / w.height,
                            url: l
                        }))
                    }),
                    t.on(w, "error", function(_) {
                        t.off(w),
                        "function" == typeof f._error && f._error.call(f, _)
                    }),
                    this.attr("href", w.src = this.src = l, t.xlink)
                },
                loaded: function(l) {
                    return this._loaded = l,
                    this
                },
                error: function(l) {
                    return this._error = l,
                    this
                }
            },
            construct: {
                image: function(l, f, w) {
                    return this.put(new t.Image).load(l).size(f || 0, w || f || 0)
                }
            }
        }),
        t.Text = t.invent({
            create: function() {
                this.constructor.call(this, t.create("text")),
                this.dom.leading = new t.Number(1.3),
                this._rebuild = !0,
                this._build = !1,
                this.attr("font-family", t.defaults.attrs["font-family"])
            },
            inherit: t.Shape,
            extend: {
                x: function(l) {
                    return null == l ? this.attr("x") : this.attr("x", l)
                },
                text: function(l) {
                    if (void 0 === l) {
                        l = "";
                        for (var f = this.node.childNodes, w = 0, _ = f.length; w < _; ++w)
                            0 != w && 3 != f[w].nodeType && 1 == t.adopt(f[w]).dom.newLined && (l += "\n"),
                            l += f[w].textContent;
                        return l
                    }
                    if (this.clear().build(!0),
                    "function" == typeof l)
                        l.call(this, this);
                    else {
                        w = 0;
                        for (var R = (l = l.split("\n")).length; w < R; w++)
                            this.tspan(l[w]).newLine()
                    }
                    return this.build(!1).rebuild()
                },
                size: function(l) {
                    return this.attr("font-size", l).rebuild()
                },
                leading: function(l) {
                    return null == l ? this.dom.leading : (this.dom.leading = new t.Number(l),
                    this.rebuild())
                },
                lines: function() {
                    var l = (this.textPath && this.textPath() || this).node
                      , f = t.utils.map(t.utils.filterSVGElements(l.childNodes), function(w) {
                        return t.adopt(w)
                    });
                    return new t.Set(f)
                },
                rebuild: function(l) {
                    if ("boolean" == typeof l && (this._rebuild = l),
                    this._rebuild) {
                        var f = this
                          , w = 0
                          , _ = this.dom.leading * new t.Number(this.attr("font-size"));
                        this.lines().each(function() {
                            this.dom.newLined && (f.textPath() || this.attr("x", f.attr("x")),
                            "\n" == this.text() ? w += _ : (this.attr("dy", _ + w),
                            w = 0))
                        }),
                        this.fire("rebuild")
                    }
                    return this
                },
                build: function(l) {
                    return this._build = !!l,
                    this
                },
                setData: function(l) {
                    return this.dom = l,
                    this.dom.leading = new t.Number(l.leading || 1.3),
                    this
                }
            },
            construct: {
                text: function(l) {
                    return this.put(new t.Text).text(l)
                },
                plain: function(l) {
                    return this.put(new t.Text).plain(l)
                }
            }
        }),
        t.Tspan = t.invent({
            create: "tspan",
            inherit: t.Shape,
            extend: {
                text: function(l) {
                    return null == l ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof l ? l.call(this, this) : this.plain(l),
                    this)
                },
                dx: function(l) {
                    return this.attr("dx", l)
                },
                dy: function(l) {
                    return this.attr("dy", l)
                },
                newLine: function() {
                    var l = this.parent(t.Text);
                    return this.dom.newLined = !0,
                    this.dy(l.dom.leading * l.attr("font-size")).attr("x", l.x())
                }
            }
        }),
        t.extend(t.Text, t.Tspan, {
            plain: function(l) {
                return !1 === this._build && this.clear(),
                this.node.appendChild(e.createTextNode(l)),
                this
            },
            tspan: function(l) {
                var f = (this.textPath && this.textPath() || this).node
                  , w = new t.Tspan;
                return !1 === this._build && this.clear(),
                f.appendChild(w.node),
                w.text(l)
            },
            clear: function() {
                for (var l = (this.textPath && this.textPath() || this).node; l.hasChildNodes(); )
                    l.removeChild(l.lastChild);
                return this
            },
            length: function() {
                return this.node.getComputedTextLength()
            }
        }),
        t.TextPath = t.invent({
            create: "textPath",
            inherit: t.Parent,
            parent: t.Text,
            construct: {
                morphArray: t.PathArray,
                array: function() {
                    var l = this.track();
                    return l ? l.array() : null
                },
                plot: function(l) {
                    var f = this.track()
                      , w = null;
                    return f && (w = f.plot(l)),
                    null == l ? w : this
                },
                track: function() {
                    var l = this.textPath();
                    if (l)
                        return l.reference("href")
                },
                textPath: function() {
                    if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName)
                        return t.adopt(this.node.firstChild)
                }
            }
        }),
        t.Nested = t.invent({
            create: function() {
                this.constructor.call(this, t.create("svg")),
                this.style("overflow", "visible")
            },
            inherit: t.Container,
            construct: {
                nested: function() {
                    return this.put(new t.Nested)
                }
            }
        });
        var n = {
            stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
            fill: ["color", "opacity", "rule"],
            prefix: function(l, f) {
                return "color" == f ? l : l + "-" + f
            }
        };
        function o(l, f, w, _) {
            return w + _.replace(t.regex.dots, " .")
        }
        function h(l) {
            return l.toLowerCase().replace(/-(.)/g, function(f, w) {
                return w.toUpperCase()
            })
        }
        function d(l) {
            return l.charAt(0).toUpperCase() + l.slice(1)
        }
        function u(l) {
            var f = l.toString(16);
            return 1 == f.length ? "0" + f : f
        }
        function p(l, f, w) {
            if (null == f || null == w) {
                var _ = l.bbox();
                null == f ? f = _.width / _.height * w : null == w && (w = _.height / _.width * f)
            }
            return {
                width: f,
                height: w
            }
        }
        function x(l, f, w) {
            return {
                x: f * l.a + w * l.c + 0,
                y: f * l.b + w * l.d + 0
            }
        }
        function b(l) {
            return {
                a: l[0],
                b: l[1],
                c: l[2],
                d: l[3],
                e: l[4],
                f: l[5]
            }
        }
        function k(l) {
            for (var f = l.childNodes.length - 1; f >= 0; f--)
                l.childNodes[f]instanceof C.SVGElement && k(l.childNodes[f]);
            return t.adopt(l).id(t.eid(l.nodeName))
        }
        function S(l) {
            return Math.abs(l) > 1e-37 ? l : 0
        }
        ["fill", "stroke"].forEach(function(l) {
            var f = {};
            f[l] = function(w) {
                if (void 0 === w)
                    return this;
                if ("string" == typeof w || t.Color.isRgb(w) || w && "function" == typeof w.fill)
                    this.attr(l, w);
                else
                    for (var _ = n[l].length - 1; _ >= 0; _--)
                        null != w[n[l][_]] && this.attr(n.prefix(l, n[l][_]), w[n[l][_]]);
                return this
            }
            ,
            t.extend(t.Element, t.FX, f)
        }),
        t.extend(t.Element, t.FX, {
            translate: function(l, f) {
                return this.transform({
                    x: l,
                    y: f
                })
            },
            matrix: function(l) {
                return this.attr("transform", new t.Matrix(6 == arguments.length ? [].slice.call(arguments) : l))
            },
            opacity: function(l) {
                return this.attr("opacity", l)
            },
            dx: function(l) {
                return this.x(new t.Number(l).plus(this instanceof t.FX ? 0 : this.x()), !0)
            },
            dy: function(l) {
                return this.y(new t.Number(l).plus(this instanceof t.FX ? 0 : this.y()), !0)
            }
        }),
        t.extend(t.Path, {
            length: function() {
                return this.node.getTotalLength()
            },
            pointAt: function(l) {
                return this.node.getPointAtLength(l)
            }
        }),
        t.Set = t.invent({
            create: function(l) {
                Array.isArray(l) ? this.members = l : this.clear()
            },
            extend: {
                add: function() {
                    for (var l = [].slice.call(arguments), f = 0, w = l.length; f < w; f++)
                        this.members.push(l[f]);
                    return this
                },
                remove: function(l) {
                    var f = this.index(l);
                    return f > -1 && this.members.splice(f, 1),
                    this
                },
                each: function(l) {
                    for (var f = 0, w = this.members.length; f < w; f++)
                        l.apply(this.members[f], [f, this.members]);
                    return this
                },
                clear: function() {
                    return this.members = [],
                    this
                },
                length: function() {
                    return this.members.length
                },
                has: function(l) {
                    return this.index(l) >= 0
                },
                index: function(l) {
                    return this.members.indexOf(l)
                },
                get: function(l) {
                    return this.members[l]
                },
                first: function() {
                    return this.get(0)
                },
                last: function() {
                    return this.get(this.members.length - 1)
                },
                valueOf: function() {
                    return this.members
                }
            },
            construct: {
                set: function(l) {
                    return new t.Set(l)
                }
            }
        }),
        t.FX.Set = t.invent({
            create: function(l) {
                this.set = l
            }
        }),
        t.Set.inherit = function() {
            var l = [];
            for (var f in t.Shape.prototype)
                "function" == typeof t.Shape.prototype[f] && "function" != typeof t.Set.prototype[f] && l.push(f);
            for (var f in l.forEach(function(_) {
                t.Set.prototype[_] = function() {
                    for (var R = 0, H = this.members.length; R < H; R++)
                        this.members[R] && "function" == typeof this.members[R][_] && this.members[R][_].apply(this.members[R], arguments);
                    return "animate" == _ ? this.fx || (this.fx = new t.FX.Set(this)) : this
                }
            }),
            l = [],
            t.FX.prototype)
                "function" == typeof t.FX.prototype[f] && "function" != typeof t.FX.Set.prototype[f] && l.push(f);
            l.forEach(function(w) {
                t.FX.Set.prototype[w] = function() {
                    for (var _ = 0, R = this.set.members.length; _ < R; _++)
                        this.set.members[_].fx[w].apply(this.set.members[_].fx, arguments);
                    return this
                }
            })
        }
        ,
        t.extend(t.Element, {}),
        t.extend(t.Element, {
            remember: function(l, f) {
                if ("object" === Ke(arguments[0]))
                    for (var w in l)
                        this.remember(w, l[w]);
                else {
                    if (1 == arguments.length)
                        return this.memory()[l];
                    this.memory()[l] = f
                }
                return this
            },
            forget: function() {
                if (0 == arguments.length)
                    this._memory = {};
                else
                    for (var l = arguments.length - 1; l >= 0; l--)
                        delete this.memory()[arguments[l]];
                return this
            },
            memory: function() {
                return this._memory || (this._memory = {})
            }
        }),
        t.get = function(l) {
            var f = e.getElementById(function(w) {
                var _ = (w || "").toString().match(t.regex.reference);
                if (_)
                    return _[1]
            }(l) || l);
            return t.adopt(f)
        }
        ,
        t.select = function(l, f) {
            return new t.Set(t.utils.map((f || e).querySelectorAll(l), function(w) {
                return t.adopt(w)
            }))
        }
        ,
        t.extend(t.Parent, {
            select: function(l) {
                return t.select(l, this.node)
            }
        });
        var E = "abcdef".split("");
        if ("function" != typeof C.CustomEvent) {
            var M = function(l, f) {
                f = f || {
                    bubbles: !1,
                    cancelable: !1,
                    detail: void 0
                };
                var w = e.createEvent("CustomEvent");
                return w.initCustomEvent(l, f.bubbles, f.cancelable, f.detail),
                w
            };
            M.prototype = C.Event.prototype,
            t.CustomEvent = M
        } else
            t.CustomEvent = C.CustomEvent;
        return t
    }
    ,
    "function" == typeof define && define.amd ? define(function() {
        return yi(bi, bi.document)
    }) : "object" === (typeof exports > "u" ? "undefined" : Ke(exports)) && typeof module < "u" ? module.exports = bi.document ? yi(bi, bi.document) : function(C) {
        return yi(C, C.document)
    }
    : bi.SVG = yi(bi, bi.document),
    function() {
        SVG.Filter = SVG.invent({
            create: "filter",
            inherit: SVG.Parent,
            extend: {
                source: "SourceGraphic",
                sourceAlpha: "SourceAlpha",
                background: "BackgroundImage",
                backgroundAlpha: "BackgroundAlpha",
                fill: "FillPaint",
                stroke: "StrokePaint",
                autoSetIn: !0,
                put: function(r, n) {
                    return this.add(r, n),
                    !r.attr("in") && this.autoSetIn && r.attr("in", this.source),
                    r.attr("result") || r.attr("result", r),
                    r
                },
                blend: function(r, n, o) {
                    return this.put(new SVG.BlendEffect(r,n,o))
                },
                colorMatrix: function(r, n) {
                    return this.put(new SVG.ColorMatrixEffect(r,n))
                },
                convolveMatrix: function(r) {
                    return this.put(new SVG.ConvolveMatrixEffect(r))
                },
                componentTransfer: function(r) {
                    return this.put(new SVG.ComponentTransferEffect(r))
                },
                composite: function(r, n, o) {
                    return this.put(new SVG.CompositeEffect(r,n,o))
                },
                flood: function(r, n) {
                    return this.put(new SVG.FloodEffect(r,n))
                },
                offset: function(r, n) {
                    return this.put(new SVG.OffsetEffect(r,n))
                },
                image: function(r) {
                    return this.put(new SVG.ImageEffect(r))
                },
                merge: function() {
                    var r = [void 0];
                    for (var n in arguments)
                        r.push(arguments[n]);
                    return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, r)))
                },
                gaussianBlur: function(r, n) {
                    return this.put(new SVG.GaussianBlurEffect(r,n))
                },
                morphology: function(r, n) {
                    return this.put(new SVG.MorphologyEffect(r,n))
                },
                diffuseLighting: function(r, n, o) {
                    return this.put(new SVG.DiffuseLightingEffect(r,n,o))
                },
                displacementMap: function(r, n, o, h, d) {
                    return this.put(new SVG.DisplacementMapEffect(r,n,o,h,d))
                },
                specularLighting: function(r, n, o, h) {
                    return this.put(new SVG.SpecularLightingEffect(r,n,o,h))
                },
                tile: function() {
                    return this.put(new SVG.TileEffect)
                },
                turbulence: function(r, n, o, h, d) {
                    return this.put(new SVG.TurbulenceEffect(r,n,o,h,d))
                },
                toString: function() {
                    return "url(#" + this.attr("id") + ")"
                }
            }
        }),
        SVG.extend(SVG.Defs, {
            filter: function(r) {
                var n = this.put(new SVG.Filter);
                return "function" == typeof r && r.call(n, n),
                n
            }
        }),
        SVG.extend(SVG.Container, {
            filter: function(r) {
                return this.defs().filter(r)
            }
        }),
        SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
            filter: function(r) {
                return this.filterer = r instanceof SVG.Element ? r : this.doc().filter(r),
                this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer),
                this.attr("filter", this.filterer),
                this.filterer
            },
            unfilter: function(r) {
                return this.filterer && !0 === r && this.filterer.remove(),
                delete this.filterer,
                this.attr("filter", null)
            }
        }),
        SVG.Effect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Element,
            extend: {
                in: function(r) {
                    return null == r ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", r)
                },
                result: function(r) {
                    return null == r ? this.attr("result") : this.attr("result", r)
                },
                toString: function() {
                    return this.result()
                }
            }
        }),
        SVG.ParentEffect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Parent,
            extend: {
                in: function(r) {
                    return null == r ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", r)
                },
                result: function(r) {
                    return null == r ? this.attr("result") : this.attr("result", r)
                },
                toString: function() {
                    return this.result()
                }
            }
        });
        var C = {
            blend: function(r, n) {
                return this.parent() && this.parent().blend(this, r, n)
            },
            colorMatrix: function(r, n) {
                return this.parent() && this.parent().colorMatrix(r, n).in(this)
            },
            convolveMatrix: function(r) {
                return this.parent() && this.parent().convolveMatrix(r).in(this)
            },
            componentTransfer: function(r) {
                return this.parent() && this.parent().componentTransfer(r).in(this)
            },
            composite: function(r, n) {
                return this.parent() && this.parent().composite(this, r, n)
            },
            flood: function(r, n) {
                return this.parent() && this.parent().flood(r, n)
            },
            offset: function(r, n) {
                return this.parent() && this.parent().offset(r, n).in(this)
            },
            image: function(r) {
                return this.parent() && this.parent().image(r)
            },
            merge: function() {
                return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
            },
            gaussianBlur: function(r, n) {
                return this.parent() && this.parent().gaussianBlur(r, n).in(this)
            },
            morphology: function(r, n) {
                return this.parent() && this.parent().morphology(r, n).in(this)
            },
            diffuseLighting: function(r, n, o) {
                return this.parent() && this.parent().diffuseLighting(r, n, o).in(this)
            },
            displacementMap: function(r, n, o, h) {
                return this.parent() && this.parent().displacementMap(this, r, n, o, h)
            },
            specularLighting: function(r, n, o, h) {
                return this.parent() && this.parent().specularLighting(r, n, o, h).in(this)
            },
            tile: function() {
                return this.parent() && this.parent().tile().in(this)
            },
            turbulence: function(r, n, o, h, d) {
                return this.parent() && this.parent().turbulence(r, n, o, h, d).in(this)
            }
        };
        SVG.extend(SVG.Effect, C),
        SVG.extend(SVG.ParentEffect, C),
        SVG.ChildEffect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Element,
            extend: {
                in: function(r) {
                    this.attr("in", r)
                }
            }
        });
        var e = {
            blend: function(r, n, o) {
                this.attr({
                    in: r,
                    in2: n,
                    mode: o || "normal"
                })
            },
            colorMatrix: function(r, n) {
                "matrix" == r && (n = a(n)),
                this.attr({
                    type: r,
                    values: void 0 === n ? null : n
                })
            },
            convolveMatrix: function(r) {
                r = a(r),
                this.attr({
                    order: Math.sqrt(r.split(" ").length),
                    kernelMatrix: r
                })
            },
            composite: function(r, n, o) {
                this.attr({
                    in: r,
                    in2: n,
                    operator: o
                })
            },
            flood: function(r, n) {
                this.attr("flood-color", r),
                null != n && this.attr("flood-opacity", n)
            },
            offset: function(r, n) {
                this.attr({
                    dx: r,
                    dy: n
                })
            },
            image: function(r) {
                this.attr("href", r, SVG.xlink)
            },
            displacementMap: function(r, n, o, h, d) {
                this.attr({
                    in: r,
                    in2: n,
                    scale: o,
                    xChannelSelector: h,
                    yChannelSelector: d
                })
            },
            gaussianBlur: function(r, n) {
                this.attr("stdDeviation", null != r || null != n ? function(o) {
                    if (!Array.isArray(o))
                        return o;
                    for (var h = 0, d = o.length, u = []; h < d; h++)
                        u.push(o[h]);
                    return u.join(" ")
                }(Array.prototype.slice.call(arguments)) : "0 0")
            },
            morphology: function(r, n) {
                this.attr({
                    operator: r,
                    radius: n
                })
            },
            tile: function() {},
            turbulence: function(r, n, o, h, d) {
                this.attr({
                    numOctaves: n,
                    seed: o,
                    stitchTiles: h,
                    baseFrequency: r,
                    type: d
                })
            }
        }
          , t = {
            merge: function() {
                var r;
                if (arguments[0]instanceof SVG.Set) {
                    var n = this;
                    arguments[0].each(function(h) {
                        this instanceof SVG.MergeNode ? n.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && n.put(new SVG.MergeNode(this))
                    })
                } else {
                    r = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                    for (var o = 0; o < r.length; o++)
                        r[o]instanceof SVG.MergeNode ? this.put(r[o]) : this.put(new SVG.MergeNode(r[o]))
                }
            },
            componentTransfer: function(r) {
                if (this.rgb = new SVG.Set,
                ["r", "g", "b", "a"].forEach(function(o) {
                    this[o] = new (SVG["Func" + o.toUpperCase()])("identity"),
                    this.rgb.add(this[o]),
                    this.node.appendChild(this[o].node)
                }
                .bind(this)),
                r)
                    for (var n in r.rgb && (["r", "g", "b"].forEach(function(o) {
                        this[o].attr(r.rgb)
                    }
                    .bind(this)),
                    delete r.rgb),
                    r)
                        this[n].attr(r[n])
            },
            diffuseLighting: function(r, n, o) {
                this.attr({
                    surfaceScale: r,
                    diffuseConstant: n,
                    kernelUnitLength: o
                })
            },
            specularLighting: function(r, n, o, h) {
                this.attr({
                    surfaceScale: r,
                    diffuseConstant: n,
                    specularExponent: o,
                    kernelUnitLength: h
                })
            }
        }
          , i = {
            distantLight: function(r, n) {
                this.attr({
                    azimuth: r,
                    elevation: n
                })
            },
            pointLight: function(r, n, o) {
                this.attr({
                    x: r,
                    y: n,
                    z: o
                })
            },
            spotLight: function(r, n, o, h, d, u) {
                this.attr({
                    x: r,
                    y: n,
                    z: o,
                    pointsAtX: h,
                    pointsAtY: d,
                    pointsAtZ: u
                })
            },
            mergeNode: function(r) {
                this.attr("in", r)
            }
        };
        function a(r) {
            return Array.isArray(r) && (r = new SVG.Array(r)),
            r.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
        }
        function s() {
            var r = function() {};
            for (var n in "function" == typeof arguments[arguments.length - 1] && (r = arguments[arguments.length - 1],
            Array.prototype.splice.call(arguments, arguments.length - 1, 1)),
            arguments)
                for (var o in arguments[n])
                    r(arguments[n][o], o, arguments[n])
        }
        ["r", "g", "b", "a"].forEach(function(r) {
            i["Func" + r.toUpperCase()] = function(n) {
                switch (this.attr("type", n),
                n) {
                case "table":
                    this.attr("tableValues", arguments[1]);
                    break;
                case "linear":
                    this.attr("slope", arguments[1]),
                    this.attr("intercept", arguments[2]);
                    break;
                case "gamma":
                    this.attr("amplitude", arguments[1]),
                    this.attr("exponent", arguments[2]),
                    this.attr("offset", arguments[2])
                }
            }
        }),
        s(e, function(r, n) {
            var o = n.charAt(0).toUpperCase() + n.slice(1);
            SVG[o + "Effect"] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + o)),
                    r.apply(this, arguments),
                    this.result(this.attr("id") + "Out")
                },
                inherit: SVG.Effect,
                extend: {}
            })
        }),
        s(t, function(r, n) {
            var o = n.charAt(0).toUpperCase() + n.slice(1);
            SVG[o + "Effect"] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + o)),
                    r.apply(this, arguments),
                    this.result(this.attr("id") + "Out")
                },
                inherit: SVG.ParentEffect,
                extend: {}
            })
        }),
        s(i, function(r, n) {
            var o = n.charAt(0).toUpperCase() + n.slice(1);
            SVG[o] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + o)),
                    r.apply(this, arguments)
                },
                inherit: SVG.ChildEffect,
                extend: {}
            })
        }),
        SVG.extend(SVG.MergeEffect, {
            in: function(r) {
                return r instanceof SVG.MergeNode ? this.add(r, 0) : this.add(new SVG.MergeNode(r), 0),
                this
            }
        }),
        SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
            in2: function(r) {
                return null == r ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", r)
            }
        }),
        SVG.filter = {
            sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
        }
    }
    .call(void 0),
    function() {
        function C(s, r, n, o, h, d, u) {
            for (var p = s.slice(r, n || u), x = o.slice(h, d || u), b = 0, k = {
                pos: [0, 0],
                start: [0, 0]
            }, S = {
                pos: [0, 0],
                start: [0, 0]
            }; p[b] = e.call(k, p[b]),
            x[b] = e.call(S, x[b]),
            p[b][0] != x[b][0] || "M" == p[b][0] || "A" == p[b][0] && (p[b][4] != x[b][4] || p[b][5] != x[b][5]) ? (Array.prototype.splice.apply(p, [b, 1].concat(i.call(k, p[b]))),
            Array.prototype.splice.apply(x, [b, 1].concat(i.call(S, x[b])))) : (p[b] = t.call(k, p[b]),
            x[b] = t.call(S, x[b])),
            ++b != p.length || b != x.length; )
                b == p.length && p.push(["C", k.pos[0], k.pos[1], k.pos[0], k.pos[1], k.pos[0], k.pos[1]]),
                b == x.length && x.push(["C", S.pos[0], S.pos[1], S.pos[0], S.pos[1], S.pos[0], S.pos[1]]);
            return {
                start: p,
                dest: x
            }
        }
        function e(s) {
            switch (s[0]) {
            case "z":
            case "Z":
                s[0] = "L",
                s[1] = this.start[0],
                s[2] = this.start[1];
                break;
            case "H":
                s[0] = "L",
                s[2] = this.pos[1];
                break;
            case "V":
                s[0] = "L",
                s[2] = s[1],
                s[1] = this.pos[0];
                break;
            case "T":
                s[0] = "Q",
                s[3] = s[1],
                s[4] = s[2],
                s[1] = this.reflection[1],
                s[2] = this.reflection[0];
                break;
            case "S":
                s[0] = "C",
                s[6] = s[4],
                s[5] = s[3],
                s[4] = s[2],
                s[3] = s[1],
                s[2] = this.reflection[1],
                s[1] = this.reflection[0]
            }
            return s
        }
        function t(s) {
            var r = s.length;
            return this.pos = [s[r - 2], s[r - 1]],
            -1 != "SCQT".indexOf(s[0]) && (this.reflection = [2 * this.pos[0] - s[r - 4], 2 * this.pos[1] - s[r - 3]]),
            s
        }
        function i(s) {
            var r = [s];
            switch (s[0]) {
            case "M":
                return this.pos = this.start = [s[1], s[2]],
                r;
            case "L":
                s[5] = s[3] = s[1],
                s[6] = s[4] = s[2],
                s[1] = this.pos[0],
                s[2] = this.pos[1];
                break;
            case "Q":
                s[6] = s[4],
                s[5] = s[3],
                s[4] = 1 * s[4] / 3 + 2 * s[2] / 3,
                s[3] = 1 * s[3] / 3 + 2 * s[1] / 3,
                s[2] = 1 * this.pos[1] / 3 + 2 * s[2] / 3,
                s[1] = 1 * this.pos[0] / 3 + 2 * s[1] / 3;
                break;
            case "A":
                s = (r = function(n, o) {
                    var h, d, u, p, x, b, k, S, E, M, l, f, w, _, R, H, B, j, ce, me, ue, Ee, Ie, rt, nt, ht, vt = Math.abs(o[1]), mt = Math.abs(o[2]), _t = o[3] % 360, ii = o[4], Li = o[5], ra = o[6], ai = o[7], qt = new SVG.Point(n), Ut = new SVG.Point(ra,ai), ga = [];
                    if (0 === vt || 0 === mt || qt.x === Ut.x && qt.y === Ut.y)
                        return [["C", qt.x, qt.y, Ut.x, Ut.y, Ut.x, Ut.y]];
                    for ((d = (h = new SVG.Point((qt.x - Ut.x) / 2,(qt.y - Ut.y) / 2).transform((new SVG.Matrix).rotate(_t))).x * h.x / (vt * vt) + h.y * h.y / (mt * mt)) > 1 && (vt *= d = Math.sqrt(d),
                    mt *= d),
                    u = (new SVG.Matrix).rotate(_t).scale(1 / vt, 1 / mt).rotate(-_t),
                    qt = qt.transform(u),
                    b = (p = [(Ut = Ut.transform(u)).x - qt.x, Ut.y - qt.y])[0] * p[0] + p[1] * p[1],
                    x = Math.sqrt(b),
                    p[0] /= x,
                    p[1] /= x,
                    k = b < 4 ? Math.sqrt(1 - b / 4) : 0,
                    ii === Li && (k *= -1),
                    S = new SVG.Point((Ut.x + qt.x) / 2 + k * -p[1],(Ut.y + qt.y) / 2 + k * p[0]),
                    E = new SVG.Point(qt.x - S.x,qt.y - S.y),
                    M = new SVG.Point(Ut.x - S.x,Ut.y - S.y),
                    l = Math.acos(E.x / Math.sqrt(E.x * E.x + E.y * E.y)),
                    E.y < 0 && (l *= -1),
                    f = Math.acos(M.x / Math.sqrt(M.x * M.x + M.y * M.y)),
                    M.y < 0 && (f *= -1),
                    Li && l > f && (f += 2 * Math.PI),
                    !Li && l < f && (f -= 2 * Math.PI),
                    H = [],
                    B = l,
                    w = (f - l) / (_ = Math.ceil(2 * Math.abs(l - f) / Math.PI)),
                    R = 4 * Math.tan(w / 4) / 3,
                    ue = 0; ue <= _; ue++)
                        ce = Math.cos(B),
                        j = Math.sin(B),
                        me = new SVG.Point(S.x + ce,S.y + j),
                        H[ue] = [new SVG.Point(me.x + R * j,me.y - R * ce), me, new SVG.Point(me.x - R * j,me.y + R * ce)],
                        B += w;
                    for (H[0][0] = H[0][1].clone(),
                    H[H.length - 1][2] = H[H.length - 1][1].clone(),
                    u = (new SVG.Matrix).rotate(_t).scale(vt, mt).rotate(-_t),
                    ue = 0,
                    Ee = H.length; ue < Ee; ue++)
                        H[ue][0] = H[ue][0].transform(u),
                        H[ue][1] = H[ue][1].transform(u),
                        H[ue][2] = H[ue][2].transform(u);
                    for (ue = 1,
                    Ee = H.length; ue < Ee; ue++)
                        Ie = (me = H[ue - 1][2]).x,
                        rt = me.y,
                        nt = (me = H[ue][0]).x,
                        ht = me.y,
                        ra = (me = H[ue][1]).x,
                        ga.push(["C", Ie, rt, nt, ht, ra, ai = me.y]);
                    return ga
                }(this.pos, s))[0]
            }
            return s[0] = "C",
            this.pos = [s[5], s[6]],
            this.reflection = [2 * s[5] - s[3], 2 * s[6] - s[4]],
            r
        }
        function a(s, r) {
            if (!1 === r)
                return !1;
            for (var n = r, o = s.length; n < o; ++n)
                if ("M" == s[n][0])
                    return n;
            return !1
        }
        SVG.extend(SVG.PathArray, {
            morph: function(s) {
                for (var r = this.value, n = this.parse(s), o = 0, h = 0, d = !1, u = !1; !1 !== o || !1 !== h; ) {
                    var p;
                    d = a(r, !1 !== o && o + 1),
                    u = a(n, !1 !== h && h + 1),
                    !1 === o && (o = 0 == (p = new SVG.PathArray(x.start).bbox()).height || 0 == p.width ? r.push(r[0]) - 1 : r.push(["M", p.x + p.width / 2, p.y + p.height / 2]) - 1),
                    !1 === h && (h = 0 == (p = new SVG.PathArray(x.dest).bbox()).height || 0 == p.width ? n.push(n[0]) - 1 : n.push(["M", p.x + p.width / 2, p.y + p.height / 2]) - 1);
                    var x = C(r, o, d, n, h, u);
                    r = r.slice(0, o).concat(x.start, !1 === d ? [] : r.slice(d)),
                    n = n.slice(0, h).concat(x.dest, !1 === u ? [] : n.slice(u)),
                    o = !1 !== d && o + x.start.length,
                    h = !1 !== u && h + x.dest.length
                }
                return this.value = r,
                this.destination = new SVG.PathArray,
                this.destination.value = n,
                this
            }
        })
    }(),
    function() {
        function C(e) {
            e.remember("_draggable", this),
            this.el = e
        }
        C.prototype.init = function(e, t) {
            var i = this;
            this.constraint = e,
            this.value = t,
            this.el.on("mousedown.drag", function(a) {
                i.start(a)
            }),
            this.el.on("touchstart.drag", function(a) {
                i.start(a)
            })
        }
        ,
        C.prototype.transformPoint = function(e, t) {
            var i = (e = e || window.event).changedTouches && e.changedTouches[0] || e;
            return this.p.x = i.clientX - (t || 0),
            this.p.y = i.clientY,
            this.p.matrixTransform(this.m)
        }
        ,
        C.prototype.getBBox = function() {
            var e = this.el.bbox();
            return this.el instanceof SVG.Nested && (e = this.el.rbox()),
            (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (e.x = this.el.x(),
            e.y = this.el.y()),
            e
        }
        ,
        C.prototype.start = function(e) {
            if ("click" != e.type && "mousedown" != e.type && "mousemove" != e.type || 1 == (e.which || e.buttons)) {
                var t = this;
                if (this.el.fire("beforedrag", {
                    event: e,
                    handler: this
                }),
                !this.el.event().defaultPrevented) {
                    e.preventDefault(),
                    e.stopPropagation(),
                    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc),
                    this.p = this.parent.node.createSVGPoint(),
                    this.m = this.el.node.getScreenCTM().inverse();
                    var i, a = this.getBBox();
                    if (this.el instanceof SVG.Text)
                        switch (i = this.el.node.getComputedTextLength(),
                        this.el.attr("text-anchor")) {
                        case "middle":
                            i /= 2;
                            break;
                        case "start":
                            i = 0
                        }
                    this.startPoints = {
                        point: this.transformPoint(e, i),
                        box: a,
                        transform: this.el.transform()
                    },
                    SVG.on(window, "mousemove.drag", function(s) {
                        t.drag(s)
                    }),
                    SVG.on(window, "touchmove.drag", function(s) {
                        t.drag(s)
                    }),
                    SVG.on(window, "mouseup.drag", function(s) {
                        t.end(s)
                    }),
                    SVG.on(window, "touchend.drag", function(s) {
                        t.end(s)
                    }),
                    this.el.fire("dragstart", {
                        event: e,
                        p: this.startPoints.point,
                        m: this.m,
                        handler: this
                    })
                }
            }
        }
        ,
        C.prototype.drag = function(e) {
            var t = this.getBBox()
              , i = this.transformPoint(e)
              , a = this.startPoints.box.x + i.x - this.startPoints.point.x
              , s = this.startPoints.box.y + i.y - this.startPoints.point.y
              , r = this.constraint
              , n = i.x - this.startPoints.point.x
              , o = i.y - this.startPoints.point.y;
            if (this.el.fire("dragmove", {
                event: e,
                p: i,
                m: this.m,
                handler: this
            }),
            this.el.event().defaultPrevented)
                return i;
            if ("function" == typeof r) {
                var h = r.call(this.el, a, s, this.m);
                "boolean" == typeof h && (h = {
                    x: h,
                    y: h
                }),
                !0 === h.x ? this.el.x(a) : !1 !== h.x && this.el.x(h.x),
                !0 === h.y ? this.el.y(s) : !1 !== h.y && this.el.y(h.y)
            } else
                "object" == typeof r && (null != r.minX && a < r.minX ? n = (a = r.minX) - this.startPoints.box.x : null != r.maxX && a > r.maxX - t.width && (n = (a = r.maxX - t.width) - this.startPoints.box.x),
                null != r.minY && s < r.minY ? o = (s = r.minY) - this.startPoints.box.y : null != r.maxY && s > r.maxY - t.height && (o = (s = r.maxY - t.height) - this.startPoints.box.y),
                null != r.snapToGrid && (a -= a % r.snapToGrid,
                s -= s % r.snapToGrid,
                n -= n % r.snapToGrid,
                o -= o % r.snapToGrid),
                this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                    x: n,
                    y: o
                }, !0) : this.el.move(a, s));
            return i
        }
        ,
        C.prototype.end = function(e) {
            var t = this.drag(e);
            this.el.fire("dragend", {
                event: e,
                p: t,
                m: this.m,
                handler: this
            }),
            SVG.off(window, "mousemove.drag"),
            SVG.off(window, "touchmove.drag"),
            SVG.off(window, "mouseup.drag"),
            SVG.off(window, "touchend.drag")
        }
        ,
        SVG.extend(SVG.Element, {
            draggable: function(e, t) {
                "function" != typeof e && "object" != typeof e || (t = e,
                e = !0);
                var i = this.remember("_draggable") || new C(this);
                return (e = void 0 === e || e) ? i.init(t || {}, e) : (this.off("mousedown.drag"),
                this.off("touchstart.drag")),
                this
            }
        })
    }
    .call(void 0),
    function() {
        function C(e) {
            this.el = e,
            e.remember("_selectHandler", this),
            this.pointSelection = {
                isSelected: !1
            },
            this.rectSelection = {
                isSelected: !1
            },
            this.pointsList = {
                lt: [0, 0],
                rt: ["width", 0],
                rb: ["width", "height"],
                lb: [0, "height"],
                t: ["width", 0],
                r: ["width", "height"],
                b: ["width", "height"],
                l: [0, "height"]
            },
            this.pointCoord = function(t, i, a) {
                var s = "string" != typeof t ? t : i[t];
                return a ? s / 2 : s
            }
            ,
            this.pointCoords = function(t, i) {
                var a = this.pointsList[t];
                return {
                    x: this.pointCoord(a[0], i, "t" === t || "b" === t),
                    y: this.pointCoord(a[1], i, "r" === t || "l" === t)
                }
            }
        }
        C.prototype.init = function(e, t) {
            var i = this.el.bbox();
            this.options = {};
            var a = this.el.selectize.defaults.points;
            for (var s in this.el.selectize.defaults)
                this.options[s] = this.el.selectize.defaults[s],
                void 0 !== t[s] && (this.options[s] = t[s]);
            var r = ["points", "pointsExclude"];
            for (var s in r) {
                var n = this.options[r[s]];
                "string" == typeof n ? n = n.length > 0 ? n.split(/\s*,\s*/i) : [] : "boolean" == typeof n && "points" === r[s] && (n = n ? a : []),
                this.options[r[s]] = n
            }
            this.options.points = [a, this.options.points].reduce(function(o, h) {
                return o.filter(function(d) {
                    return h.indexOf(d) > -1
                })
            }),
            this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(o, h) {
                return o.filter(function(d) {
                    return h.indexOf(d) < 0
                })
            }),
            this.parent = this.el.parent(),
            this.nested = this.nested || this.parent.group(),
            this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)),
            this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(e) : this.selectRect(e),
            this.observe(),
            this.cleanup()
        }
        ,
        C.prototype.selectPoints = function(e) {
            return this.pointSelection.isSelected = e,
            this.pointSelection.set || (this.pointSelection.set = this.parent.set(),
            this.drawPoints()),
            this
        }
        ,
        C.prototype.getPointArray = function() {
            var e = this.el.bbox();
            return this.el.array().valueOf().map(function(t) {
                return [t[0] - e.x, t[1] - e.y]
            })
        }
        ,
        C.prototype.drawPoints = function() {
            for (var e = this, t = this.getPointArray(), i = 0, a = t.length; i < a; ++i) {
                var s = function(n) {
                    return function(o) {
                        (o = o || window.event).preventDefault ? o.preventDefault() : o.returnValue = !1,
                        o.stopPropagation(),
                        e.el.fire("point", {
                            x: o.pageX || o.touches[0].pageX,
                            y: o.pageY || o.touches[0].pageY,
                            i: n,
                            event: o
                        })
                    }
                }(i)
                  , r = this.drawPoint(t[i][0], t[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s).on("mousedown", s);
                this.pointSelection.set.add(r)
            }
        }
        ,
        C.prototype.drawPoint = function(e, t) {
            var i = this.options.pointType;
            switch (i) {
            case "circle":
                return this.drawCircle(e, t);
            case "rect":
                return this.drawRect(e, t);
            default:
                if ("function" == typeof i)
                    return i.call(this, e, t);
                throw new Error("Unknown " + i + " point type!")
            }
        }
        ,
        C.prototype.drawCircle = function(e, t) {
            return this.nested.circle(this.options.pointSize).center(e, t)
        }
        ,
        C.prototype.drawRect = function(e, t) {
            return this.nested.rect(this.options.pointSize, this.options.pointSize).center(e, t)
        }
        ,
        C.prototype.updatePointSelection = function() {
            var e = this.getPointArray();
            this.pointSelection.set.each(function(t) {
                this.cx() === e[t][0] && this.cy() === e[t][1] || this.center(e[t][0], e[t][1])
            })
        }
        ,
        C.prototype.updateRectSelection = function() {
            var e = this
              , t = this.el.bbox();
            if (this.rectSelection.set.get(0).attr({
                width: t.width,
                height: t.height
            }),
            this.options.points.length && this.options.points.map(function(a, s) {
                var r = e.pointCoords(a, t);
                e.rectSelection.set.get(s + 1).center(r.x, r.y)
            }),
            this.options.rotationPoint) {
                var i = this.rectSelection.set.length();
                this.rectSelection.set.get(i - 1).center(t.width / 2, 20)
            }
        }
        ,
        C.prototype.selectRect = function(e) {
            var t = this
              , i = this.el.bbox();
            function a(n) {
                return function(o) {
                    (o = o || window.event).preventDefault ? o.preventDefault() : o.returnValue = !1,
                    o.stopPropagation(),
                    t.el.fire(n, {
                        x: o.pageX || o.touches[0].pageX,
                        y: o.pageY || o.touches[0].pageY,
                        event: o
                    })
                }
            }
            if (this.rectSelection.isSelected = e,
            this.rectSelection.set = this.rectSelection.set || this.parent.set(),
            this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)),
            this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(n, o) {
                var h = t.pointCoords(n, i)
                  , d = t.drawPoint(h.x, h.y).attr("class", t.options.classPoints + "_" + n).on("mousedown", a(n)).on("touchstart", a(n));
                t.rectSelection.set.add(d)
            }),
            this.rectSelection.set.each(function() {
                this.addClass(t.options.classPoints)
            })),
            this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
                var s = function(n) {
                    (n = n || window.event).preventDefault ? n.preventDefault() : n.returnValue = !1,
                    n.stopPropagation(),
                    t.el.fire("rot", {
                        x: n.pageX || n.touches[0].pageX,
                        y: n.pageY || n.touches[0].pageY,
                        event: n
                    })
                }
                  , r = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s).on("mousedown", s);
                this.rectSelection.set.add(r)
            }
        }
        ,
        C.prototype.handler = function() {
            var e = this.el.bbox();
            this.nested.matrix(new SVG.Matrix(this.el).translate(e.x, e.y)),
            this.rectSelection.isSelected && this.updateRectSelection(),
            this.pointSelection.isSelected && this.updatePointSelection()
        }
        ,
        C.prototype.observe = function() {
            var e = this;
            if (MutationObserver)
                if (this.rectSelection.isSelected || this.pointSelection.isSelected)
                    this.observerInst = this.observerInst || new MutationObserver(function() {
                        e.handler()
                    }
                    ),
                    this.observerInst.observe(this.el.node, {
                        attributes: !0
                    });
                else
                    try {
                        this.observerInst.disconnect(),
                        delete this.observerInst
                    } catch {}
            else
                this.el.off("DOMAttrModified.select"),
                (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
                    e.handler()
                })
        }
        ,
        C.prototype.cleanup = function() {
            !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
                this.remove()
            }),
            this.rectSelection.set.clear(),
            delete this.rectSelection.set),
            !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
                this.remove()
            }),
            this.pointSelection.set.clear(),
            delete this.pointSelection.set),
            this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(),
            delete this.nested)
        }
        ,
        SVG.extend(SVG.Element, {
            selectize: function(e, t) {
                return "object" == typeof e && (t = e,
                e = !0),
                (this.remember("_selectHandler") || new C(this)).init(void 0 === e || e, t || {}),
                this
            }
        }),
        SVG.Element.prototype.selectize.defaults = {
            points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
            pointsExclude: [],
            classRect: "svg_select_boundingRect",
            classPoints: "svg_select_points",
            pointSize: 7,
            rotationPoint: !0,
            deepSelect: !1,
            pointType: "circle"
        }
    }(),
    function() {
        (function() {
            function C(e) {
                e.remember("_resizeHandler", this),
                this.el = e,
                this.parameters = {},
                this.lastUpdateCall = null,
                this.p = e.doc().node.createSVGPoint()
            }
            C.prototype.transformPoint = function(e, t, i) {
                return this.p.x = e - (this.offset.x - window.pageXOffset),
                this.p.y = t - (this.offset.y - window.pageYOffset),
                this.p.matrixTransform(i || this.m)
            }
            ,
            C.prototype._extractPosition = function(e) {
                return {
                    x: null != e.clientX ? e.clientX : e.touches[0].clientX,
                    y: null != e.clientY ? e.clientY : e.touches[0].clientY
                }
            }
            ,
            C.prototype.init = function(e) {
                var t = this;
                if (this.stop(),
                "stop" !== e) {
                    for (var i in this.options = {},
                    this.el.resize.defaults)
                        this.options[i] = this.el.resize.defaults[i],
                        void 0 !== e[i] && (this.options[i] = e[i]);
                    this.el.on("lt.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("rt.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("rb.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("lb.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("t.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("r.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("b.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("l.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("rot.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.el.on("point.resize", function(a) {
                        t.resize(a || window.event)
                    }),
                    this.update()
                }
            }
            ,
            C.prototype.stop = function() {
                return this.el.off("lt.resize"),
                this.el.off("rt.resize"),
                this.el.off("rb.resize"),
                this.el.off("lb.resize"),
                this.el.off("t.resize"),
                this.el.off("r.resize"),
                this.el.off("b.resize"),
                this.el.off("l.resize"),
                this.el.off("rot.resize"),
                this.el.off("point.resize"),
                this
            }
            ,
            C.prototype.resize = function(e) {
                var t = this;
                this.m = this.el.node.getScreenCTM().inverse(),
                this.offset = {
                    x: window.pageXOffset,
                    y: window.pageYOffset
                };
                var i = this._extractPosition(e.detail.event);
                if (this.parameters = {
                    type: this.el.type,
                    p: this.transformPoint(i.x, i.y),
                    x: e.detail.x,
                    y: e.detail.y,
                    box: this.el.bbox(),
                    rotation: this.el.transform().rotation
                },
                "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]),
                void 0 !== e.detail.i) {
                    var a = this.el.array().valueOf();
                    this.parameters.i = e.detail.i,
                    this.parameters.pointCoords = [a[e.detail.i][0], a[e.detail.i][1]]
                }
                switch (e.type) {
                case "lt":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r);
                        if (this.parameters.box.width - n[0] > 0 && this.parameters.box.height - n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x + n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize - n[0]);
                            n = this.checkAspectRatio(n),
                            this.el.move(this.parameters.box.x + n[0], this.parameters.box.y + n[1]).size(this.parameters.box.width - n[0], this.parameters.box.height - n[1])
                        }
                    }
                    ;
                    break;
                case "rt":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, 2);
                        if (this.parameters.box.width + n[0] > 0 && this.parameters.box.height - n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x - n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize + n[0]);
                            n = this.checkAspectRatio(n, !0),
                            this.el.move(this.parameters.box.x, this.parameters.box.y + n[1]).size(this.parameters.box.width + n[0], this.parameters.box.height - n[1])
                        }
                    }
                    ;
                    break;
                case "rb":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, 0);
                        if (this.parameters.box.width + n[0] > 0 && this.parameters.box.height + n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x - n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize + n[0]);
                            n = this.checkAspectRatio(n),
                            this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + n[0], this.parameters.box.height + n[1])
                        }
                    }
                    ;
                    break;
                case "lb":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, 1);
                        if (this.parameters.box.width - n[0] > 0 && this.parameters.box.height + n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x + n[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize - n[0]);
                            n = this.checkAspectRatio(n, !0),
                            this.el.move(this.parameters.box.x + n[0], this.parameters.box.y).size(this.parameters.box.width - n[0], this.parameters.box.height + n[1])
                        }
                    }
                    ;
                    break;
                case "t":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, 2);
                        if (this.parameters.box.height - n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y + n[1]).height(this.parameters.box.height - n[1])
                        }
                    }
                    ;
                    break;
                case "r":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, 0);
                        if (this.parameters.box.width + n[0] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + n[0])
                        }
                    }
                    ;
                    break;
                case "b":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, 0);
                        if (this.parameters.box.height + n[1] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + n[1])
                        }
                    }
                    ;
                    break;
                case "l":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, 1);
                        if (this.parameters.box.width - n[0] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x + n[0], this.parameters.box.y).width(this.parameters.box.width - n[0])
                        }
                    }
                    ;
                    break;
                case "rot":
                    this.calc = function(s, r) {
                        var n = s + this.parameters.p.x
                          , o = r + this.parameters.p.y
                          , h = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2)
                          , d = Math.atan2(o - this.parameters.box.y - this.parameters.box.height / 2, n - this.parameters.box.x - this.parameters.box.width / 2)
                          , u = this.parameters.rotation + 180 * (d - h) / Math.PI + this.options.snapToAngle / 2;
                        this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(u - u % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                    }
                    ;
                    break;
                case "point":
                    this.calc = function(s, r) {
                        var n = this.snapToGrid(s, r, this.parameters.pointCoords[0], this.parameters.pointCoords[1])
                          , o = this.el.array().valueOf();
                        o[this.parameters.i][0] = this.parameters.pointCoords[0] + n[0],
                        o[this.parameters.i][1] = this.parameters.pointCoords[1] + n[1],
                        this.el.plot(o)
                    }
                }
                this.el.fire("resizestart", {
                    dx: this.parameters.x,
                    dy: this.parameters.y,
                    event: e
                }),
                SVG.on(window, "touchmove.resize", function(s) {
                    t.update(s || window.event)
                }),
                SVG.on(window, "touchend.resize", function() {
                    t.done()
                }),
                SVG.on(window, "mousemove.resize", function(s) {
                    t.update(s || window.event)
                }),
                SVG.on(window, "mouseup.resize", function() {
                    t.done()
                })
            }
            ,
            C.prototype.update = function(e) {
                if (e) {
                    var t = this._extractPosition(e)
                      , i = this.transformPoint(t.x, t.y)
                      , a = i.x - this.parameters.p.x
                      , s = i.y - this.parameters.p.y;
                    this.lastUpdateCall = [a, s],
                    this.calc(a, s),
                    this.el.fire("resizing", {
                        dx: a,
                        dy: s,
                        event: e
                    })
                } else
                    this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
            }
            ,
            C.prototype.done = function() {
                this.lastUpdateCall = null,
                SVG.off(window, "mousemove.resize"),
                SVG.off(window, "mouseup.resize"),
                SVG.off(window, "touchmove.resize"),
                SVG.off(window, "touchend.resize"),
                this.el.fire("resizedone")
            }
            ,
            C.prototype.snapToGrid = function(e, t, i, a) {
                var s;
                return s = void 0 !== a ? [(i + e) % this.options.snapToGrid, (a + t) % this.options.snapToGrid] : [(this.parameters.box.x + e + (1 & (i = i ?? 3) ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + t + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid],
                e < 0 && (s[0] -= this.options.snapToGrid),
                t < 0 && (s[1] -= this.options.snapToGrid),
                e -= Math.abs(s[0]) < this.options.snapToGrid / 2 ? s[0] : s[0] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid),
                t -= Math.abs(s[1]) < this.options.snapToGrid / 2 ? s[1] : s[1] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid),
                this.constraintToBox(e, t, i, a)
            }
            ,
            C.prototype.constraintToBox = function(e, t, i, a) {
                var s, r, n = this.options.constraint || {};
                return void 0 !== a ? (s = i,
                r = a) : (s = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width),
                r = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)),
                void 0 !== n.minX && s + e < n.minX && (e = n.minX - s),
                void 0 !== n.maxX && s + e > n.maxX && (e = n.maxX - s),
                void 0 !== n.minY && r + t < n.minY && (t = n.minY - r),
                void 0 !== n.maxY && r + t > n.maxY && (t = n.maxY - r),
                [e, t]
            }
            ,
            C.prototype.checkAspectRatio = function(e, t) {
                if (!this.options.saveAspectRatio)
                    return e;
                var i = e.slice()
                  , a = this.parameters.box.width / this.parameters.box.height
                  , s = this.parameters.box.width + e[0]
                  , r = this.parameters.box.height - e[1]
                  , n = s / r;
                return n < a ? (i[1] = s / a - this.parameters.box.height,
                t && (i[1] = -i[1])) : n > a && (i[0] = this.parameters.box.width - r * a,
                t && (i[0] = -i[0])),
                i
            }
            ,
            SVG.extend(SVG.Element, {
                resize: function(e) {
                    return (this.remember("_resizeHandler") || new C(this)).init(e || {}),
                    this
                }
            }),
            SVG.Element.prototype.resize.defaults = {
                snapToAngle: .1,
                snapToGrid: 1,
                constraint: {},
                saveAspectRatio: !1
            }
        }
        ).call(this)
    }(),
    void 0 === window.Apex && (window.Apex = {});
    var ca = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "initModules",
            value: function() {
                this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"],
                this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"],
                this.ctx.animations = new Se(this.ctx),
                this.ctx.axes = new ni(this.ctx),
                this.ctx.core = new Ri(this.ctx.el,this.ctx),
                this.ctx.config = new St({}),
                this.ctx.data = new Ct(this.ctx),
                this.ctx.grid = new Be(this.ctx),
                this.ctx.graphics = new U(this.ctx),
                this.ctx.coreUtils = new ae(this.ctx),
                this.ctx.crosshairs = new fi(this.ctx),
                this.ctx.events = new aa(this.ctx),
                this.ctx.exports = new Ft(this.ctx),
                this.ctx.localization = new Ai(this.ctx),
                this.ctx.options = new kt,
                this.ctx.responsive = new _i(this.ctx),
                this.ctx.series = new Lt(this.ctx),
                this.ctx.theme = new pi(this.ctx),
                this.ctx.formatters = new At(this.ctx),
                this.ctx.titleSubtitle = new Gt(this.ctx),
                this.ctx.legend = new ci(this.ctx),
                this.ctx.toolbar = new mi(this.ctx),
                this.ctx.tooltip = new X(this.ctx),
                this.ctx.dimensions = new Gi(this.ctx),
                this.ctx.updateHelpers = new ya(this.ctx),
                this.ctx.zoomPanSelection = new Pt(this.ctx),
                this.ctx.w.globals.tooltip = new X(this.ctx)
            }
        }]),
        C
    }()
      , Ei = function() {
        function C(e) {
            Q(this, C),
            this.ctx = e,
            this.w = e.w
        }
        return Te(C, [{
            key: "clear",
            value: function(e) {
                var t = e.isUpdating;
                this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(),
                this.ctx.toolbar && this.ctx.toolbar.destroy(),
                this.ctx.animations = null,
                this.ctx.axes = null,
                this.ctx.annotations = null,
                this.ctx.core = null,
                this.ctx.data = null,
                this.ctx.grid = null,
                this.ctx.series = null,
                this.ctx.responsive = null,
                this.ctx.theme = null,
                this.ctx.formatters = null,
                this.ctx.titleSubtitle = null,
                this.ctx.legend = null,
                this.ctx.dimensions = null,
                this.ctx.options = null,
                this.ctx.crosshairs = null,
                this.ctx.zoomPanSelection = null,
                this.ctx.updateHelpers = null,
                this.ctx.toolbar = null,
                this.ctx.localization = null,
                this.ctx.w.globals.tooltip = null,
                this.clearDomElements({
                    isUpdating: t
                })
            }
        }, {
            key: "killSVG",
            value: function(e) {
                e.each(function(t, i) {
                    this.removeClass("*"),
                    this.off(),
                    this.stop()
                }, !0),
                e.ungroup(),
                e.clear()
            }
        }, {
            key: "clearDomElements",
            value: function(e) {
                var t = this
                  , a = this.w.globals.dom.Paper.node;
                a.parentNode && a.parentNode.parentNode && !e.isUpdating && (a.parentNode.parentNode.style.minHeight = "unset");
                var s = this.w.globals.dom.baseEl;
                s && this.ctx.eventList.forEach(function(n) {
                    s.removeEventListener(n, t.ctx.events.documentEvent)
                });
                var r = this.w.globals.dom;
                if (null !== this.ctx.el)
                    for (; this.ctx.el.firstChild; )
                        this.ctx.el.removeChild(this.ctx.el.firstChild);
                this.killSVG(r.Paper),
                r.Paper.remove(),
                r.elWrap = null,
                r.elGraphical = null,
                r.elLegendWrap = null,
                r.elLegendForeign = null,
                r.baseEl = null,
                r.elGridRect = null,
                r.elGridRectMask = null,
                r.elGridRectMarkerMask = null,
                r.elForecastMask = null,
                r.elNonForecastMask = null,
                r.elDefs = null
            }
        }]),
        C
    }()
      , Vi = new WeakMap
      , Oi = function() {
        function C(e, t) {
            Q(this, C),
            this.opts = t,
            this.ctx = this,
            this.w = new ri(t).init(),
            this.el = e,
            this.w.globals.cuid = D.randomId(),
            this.w.globals.chartID = this.w.config.chart.id ? D.escapeString(this.w.config.chart.id) : this.w.globals.cuid,
            new ca(this).initModules(),
            this.create = D.bind(this.create, this),
            this.windowResizeHandler = this._windowResizeHandler.bind(this),
            this.parentResizeHandler = this._parentResizeCallback.bind(this)
        }
        return Te(C, [{
            key: "render",
            value: function() {
                var e = this;
                return new Promise(function(t, i) {
                    if (null !== e.el) {
                        void 0 === Apex._chartInstances && (Apex._chartInstances = []),
                        e.w.config.chart.id && Apex._chartInstances.push({
                            id: e.w.globals.chartID,
                            group: e.w.config.chart.group,
                            chart: e
                        }),
                        e.setLocale(e.w.config.chart.defaultLocale);
                        var a = e.w.config.chart.events.beforeMount;
                        if ("function" == typeof a && a(e, e.w),
                        e.events.fireEvent("beforeMount", [e, e.w]),
                        window.addEventListener("resize", e.windowResizeHandler),
                        function(d, u) {
                            var p = !1;
                            if (d.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                                var x = d.getBoundingClientRect();
                                "none" !== d.style.display && 0 !== x.width || (p = !0)
                            }
                            var b = new ResizeObserver(function(k) {
                                p && u.call(d, k),
                                p = !0
                            }
                            );
                            d.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(d.children).forEach(function(k) {
                                return b.observe(k)
                            }) : b.observe(d),
                            Vi.set(u, b)
                        }(e.el.parentNode, e.parentResizeHandler),
                        !e.css) {
                            var s = e.el.getRootNode && e.el.getRootNode()
                              , r = D.is("ShadowRoot", s)
                              , n = e.el.ownerDocument
                              , o = n.getElementById("apexcharts-css");
                            !r && o || (e.css = document.createElement("style"),
                            e.css.id = "apexcharts-css",
                            e.css.textContent = '@keyframes opaque {\n  0% {\n      opacity: 0\n  }\n\n  to {\n      opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n  0%,to {\n      opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\n.legend-mouseover-inactive {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255,255,255,.96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30,.8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0,0,0,.7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0!important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0,0,0,.7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n      opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\n  opacity: 0\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers{\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows{\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers{\n  pointer-events: none\n}',
                            r ? s.prepend(e.css) : n.head.appendChild(e.css))
                        }
                        var h = e.create(e.w.config.series, {});
                        if (!h)
                            return t(e);
                        e.mount(h).then(function() {
                            "function" == typeof e.w.config.chart.events.mounted && e.w.config.chart.events.mounted(e, e.w),
                            e.events.fireEvent("mounted", [e, e.w]),
                            t(h)
                        }).catch(function(d) {
                            i(d)
                        })
                    } else
                        i(new Error("Element not found"))
                }
                )
            }
        }, {
            key: "create",
            value: function(e, t) {
                var i = this.w;
                new ca(this).initModules();
                var a = this.w.globals;
                if (a.noData = !1,
                a.animationEnded = !1,
                this.responsive.checkResponsiveConfig(t),
                i.config.xaxis.convertedCatToNumeric && new xt(i.config).convertCatToNumericXaxis(i.config, this.ctx),
                null === this.el || (this.core.setupElements(),
                "treemap" === i.config.chart.type && (i.config.grid.show = !1,
                i.config.yaxis[0].show = !1),
                0 === a.svgWidth))
                    return a.animationEnded = !0,
                    null;
                var s = ae.checkComboSeries(e);
                a.comboCharts = s.comboCharts,
                a.comboBarCount = s.comboBarCount;
                var r = e.every(function(d) {
                    return d.data && 0 === d.data.length
                });
                (0 === e.length || r) && this.series.handleNoData(),
                this.events.setupEventHandlers(),
                this.data.parseData(e),
                this.theme.init(),
                new ye(this).setGlobalMarkerSize(),
                this.formatters.setLabelFormatters(),
                this.titleSubtitle.draw(),
                a.noData && a.collapsedSeries.length !== a.series.length && !i.config.legend.showForSingleSeries || this.legend.init(),
                this.series.hasAllSeriesEqualX(),
                a.axisCharts && (this.core.coreCalculations(),
                "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters(),
                this.ctx.toolbar.minX = i.globals.minX,
                this.ctx.toolbar.maxX = i.globals.maxX),
                this.formatters.heatmapLabelFormatters(),
                new ae(this).getLargestMarkerSize(),
                this.dimensions.plotCoords();
                var n = this.core.xySettings();
                this.grid.createGridMask();
                var o = this.core.plotChartType(e, n)
                  , h = new It(this);
                return h.bringForward(),
                i.config.dataLabels.background.enabled && h.dataLabelsBackground(),
                this.core.shiftGraphPosition(),
                {
                    elGraph: o,
                    xyRatios: n,
                    dimensions: {
                        plot: {
                            left: i.globals.translateX,
                            top: i.globals.translateY,
                            width: i.globals.gridWidth,
                            height: i.globals.gridHeight
                        }
                    }
                }
            }
        }, {
            key: "mount",
            value: function() {
                var e = this
                  , t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , i = this
                  , a = i.w;
                return new Promise(function(s, r) {
                    if (null === i.el)
                        return r(new Error("Not enough data to display or target element not found"));
                    (null === t || a.globals.allSeriesCollapsed) && i.series.handleNoData(),
                    i.grid = new Be(i);
                    var n, o, h = i.grid.drawGrid();
                    if (i.annotations = new Kt(i),
                    i.annotations.drawImageAnnos(),
                    i.annotations.drawTextAnnos(),
                    "back" === a.config.grid.position && (h && a.globals.dom.elGraphical.add(h.el),
                    null != h && null !== (n = h.elGridBorders) && void 0 !== n && n.node && a.globals.dom.elGraphical.add(h.elGridBorders)),
                    Array.isArray(t.elGraph))
                        for (var d = 0; d < t.elGraph.length; d++)
                            a.globals.dom.elGraphical.add(t.elGraph[d]);
                    else
                        a.globals.dom.elGraphical.add(t.elGraph);
                    "front" === a.config.grid.position && (h && a.globals.dom.elGraphical.add(h.el),
                    null != h && null !== (o = h.elGridBorders) && void 0 !== o && o.node && a.globals.dom.elGraphical.add(h.elGridBorders)),
                    "front" === a.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(),
                    "front" === a.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(),
                    "treemap" !== a.config.chart.type && i.axes.drawAxis(a.config.chart.type, h);
                    var u = new Ot(e.ctx,h)
                      , p = new ia(e.ctx,h);
                    if (null !== h && (u.xAxisLabelCorrections(h.xAxisTickWidth),
                    p.setYAxisTextAlignments(),
                    a.config.yaxis.map(function(b, k) {
                        -1 === a.globals.ignoreYAxisIndexes.indexOf(k) && p.yAxisTitleRotate(k, b.opposite)
                    })),
                    i.annotations.drawAxesAnnotations(),
                    !a.globals.noData) {
                        if (a.config.tooltip.enabled && !a.globals.noData && i.w.globals.tooltip.drawTooltip(t.xyRatios),
                        a.globals.axisCharts && (a.globals.isXNumeric || a.config.xaxis.convertedCatToNumeric || a.globals.isRangeBar))
                            (a.config.chart.zoom.enabled || a.config.chart.selection && a.config.chart.selection.enabled || a.config.chart.pan && a.config.chart.pan.enabled) && i.zoomPanSelection.init({
                                xyRatios: t.xyRatios
                            });
                        else {
                            var x = a.config.chart.toolbar.tools;
                            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(b) {
                                x[b] = !1
                            })
                        }
                        a.config.chart.toolbar.show && !a.globals.allSeriesCollapsed && i.toolbar.createToolbar()
                    }
                    a.globals.memory.methodsToExec.length > 0 && a.globals.memory.methodsToExec.forEach(function(b) {
                        b.method(b.params, !1, b.context)
                    }),
                    a.globals.axisCharts || a.globals.noData || i.core.resizeNonAxisCharts(),
                    s(i)
                }
                )
            }
        }, {
            key: "destroy",
            value: function() {
                var e, t;
                window.removeEventListener("resize", this.windowResizeHandler),
                (t = Vi.get(e = this.parentResizeHandler)) && (t.disconnect(),
                Vi.delete(e));
                var i = this.w.config.chart.id;
                i && Apex._chartInstances.forEach(function(a, s) {
                    a.id === D.escapeString(i) && Apex._chartInstances.splice(s, 1)
                }),
                new Ei(this.ctx).clear({
                    isUpdating: !1
                })
            }
        }, {
            key: "updateOptions",
            value: function(e) {
                var t = this
                  , i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
                  , r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
                  , n = this.w;
                return n.globals.selection = void 0,
                e.series && (this.series.resetSeries(!1, !0, !1),
                e.series.length && e.series[0].data && (e.series = e.series.map(function(o, h) {
                    return t.updateHelpers._extendSeries(o, h)
                })),
                this.updateHelpers.revertDefaultAxisMinMax()),
                e.xaxis && (e = this.updateHelpers.forceXAxisUpdate(e)),
                e.yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)),
                n.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(),
                e.theme && (e = this.theme.updateThemeOptions(e)),
                this.updateHelpers._updateOptions(e, i, a, s, r)
            }
        }, {
            key: "updateSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                return this.series.resetSeries(!1),
                this.updateHelpers.revertDefaultAxisMinMax(),
                this.updateHelpers._updateSeries(e, t, i)
            }
        }, {
            key: "appendSeries",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , a = this.w.config.series.slice();
                return a.push(e),
                this.series.resetSeries(!1),
                this.updateHelpers.revertDefaultAxisMinMax(),
                this.updateHelpers._updateSeries(a, t, i)
            }
        }, {
            key: "appendData",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = this;
                i.w.globals.dataChanged = !0,
                i.series.getPreviousPaths();
                for (var a = i.w.config.series.slice(), s = 0; s < a.length; s++)
                    if (null != e[s])
                        for (var r = 0; r < e[s].data.length; r++)
                            a[s].data.push(e[s].data[r]);
                return i.w.config.series = a,
                t && (i.w.globals.initialSeries = D.clone(i.w.config.series)),
                this.update()
            }
        }, {
            key: "update",
            value: function(e) {
                var t = this;
                return new Promise(function(i, a) {
                    new Ei(t.ctx).clear({
                        isUpdating: !0
                    });
                    var s = t.create(t.w.config.series, e);
                    if (!s)
                        return i(t);
                    t.mount(s).then(function() {
                        "function" == typeof t.w.config.chart.events.updated && t.w.config.chart.events.updated(t, t.w),
                        t.events.fireEvent("updated", [t, t.w]),
                        t.w.globals.isDirty = !0,
                        i(t)
                    }).catch(function(r) {
                        a(r)
                    })
                }
                )
            }
        }, {
            key: "getSyncedCharts",
            value: function() {
                var e = this.getGroupedCharts()
                  , t = [this];
                return e.length && (t = [],
                e.forEach(function(i) {
                    t.push(i)
                })),
                t
            }
        }, {
            key: "getGroupedCharts",
            value: function() {
                var e = this;
                return Apex._chartInstances.filter(function(t) {
                    if (t.group)
                        return !0
                }).map(function(t) {
                    return e.w.config.chart.group === t.group ? t.chart : e
                })
            }
        }, {
            key: "toggleSeries",
            value: function(e) {
                return this.series.toggleSeries(e)
            }
        }, {
            key: "highlightSeriesOnLegendHover",
            value: function(e, t) {
                return this.series.toggleSeriesOnHover(e, t)
            }
        }, {
            key: "showSeries",
            value: function(e) {
                this.series.showSeries(e)
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                this.series.hideSeries(e)
            }
        }, {
            key: "isSeriesHidden",
            value: function(e) {
                this.series.isSeriesHidden(e)
            }
        }, {
            key: "resetSeries",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.series.resetSeries(e, t)
            }
        }, {
            key: "addEventListener",
            value: function(e, t) {
                this.events.addEventListener(e, t)
            }
        }, {
            key: "removeEventListener",
            value: function(e, t) {
                this.events.removeEventListener(e, t)
            }
        }, {
            key: "addXaxisAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , a = this;
                i && (a = i),
                a.annotations.addXaxisAnnotationExternal(e, t, a)
            }
        }, {
            key: "addYaxisAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , a = this;
                i && (a = i),
                a.annotations.addYaxisAnnotationExternal(e, t, a)
            }
        }, {
            key: "addPointAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , a = this;
                i && (a = i),
                a.annotations.addPointAnnotationExternal(e, t, a)
            }
        }, {
            key: "clearAnnotations",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0
                  , t = this;
                e && (t = e),
                t.annotations.clearAnnotations(t)
            }
        }, {
            key: "removeAnnotation",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0
                  , i = this;
                t && (i = t),
                i.annotations.removeAnnotation(i, e)
            }
        }, {
            key: "getChartArea",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
            }
        }, {
            key: "getSeriesTotalXRange",
            value: function(e, t) {
                return this.coreUtils.getSeriesTotalsXRange(e, t)
            }
        }, {
            key: "getHighestValueInSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return new Di(this.ctx).getMinYMaxY(e).highestY
            }
        }, {
            key: "getLowestValueInSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return new Di(this.ctx).getMinYMaxY(e).lowestY
            }
        }, {
            key: "getSeriesTotal",
            value: function() {
                return this.w.globals.seriesTotals
            }
        }, {
            key: "toggleDataPointSelection",
            value: function(e, t) {
                return this.updateHelpers.toggleDataPointSelection(e, t)
            }
        }, {
            key: "zoomX",
            value: function(e, t) {
                this.ctx.toolbar.zoomUpdateOptions(e, t)
            }
        }, {
            key: "setLocale",
            value: function(e) {
                this.localization.setCurrentLocaleValues(e)
            }
        }, {
            key: "dataURI",
            value: function(e) {
                return new Ft(this.ctx).dataURI(e)
            }
        }, {
            key: "exportToCSV",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return new Ft(this.ctx).exportToCSV(e)
            }
        }, {
            key: "paper",
            value: function() {
                return this.w.globals.dom.Paper
            }
        }, {
            key: "_parentResizeCallback",
            value: function() {
                this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
            }
        }, {
            key: "_windowResize",
            value: function() {
                var e = this;
                clearTimeout(this.w.globals.resizeTimer),
                this.w.globals.resizeTimer = window.setTimeout(function() {
                    e.w.globals.resized = !0,
                    e.w.globals.dataChanged = !1,
                    e.ctx.update()
                }, 150)
            }
        }, {
            key: "_windowResizeHandler",
            value: function() {
                var e = this.w.config.chart.redrawOnWindowResize;
                "function" == typeof e && (e = e()),
                e && this._windowResize()
            }
        }], [{
            key: "getChartByID",
            value: function(e) {
                var t = D.escapeString(e);
                if (Apex._chartInstances) {
                    var i = Apex._chartInstances.filter(function(a) {
                        return a.id === t
                    })[0];
                    return i && i.chart
                }
            }
        }, {
            key: "initOnLoad",
            value: function() {
                for (var e = document.querySelectorAll("[data-apexcharts]"), t = 0; t < e.length; t++)
                    new C(e[t],JSON.parse(e[t].getAttribute("data-options"))).render()
            }
        }, {
            key: "exec",
            value: function(e, t) {
                var i = this.getChartByID(e);
                if (i) {
                    i.w.globals.isExecCalled = !0;
                    var a = null;
                    if (-1 !== i.publicMethods.indexOf(t)) {
                        for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), n = 2; n < s; n++)
                            r[n - 2] = arguments[n];
                        a = i[t].apply(i, r)
                    }
                    return a
                }
            }
        }, {
            key: "merge",
            value: function(e, t) {
                return D.extend(e, t)
            }
        }]),
        C
    }();
    return Oi
});
